<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C#:值类型和引用类型的具体类型和区别</title>
      <link href="/2021/10/19/C-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/10/19/C-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>先放上一个图表示值类型和引用类型的所有数据类型：</p><p><img src="https://raw.githubusercontent.com/petertan123/cloudimg/master/img/2009020510331710.jpg" alt="img"></p><p>（1）最根本的一个区别：<span style="color:red"><strong>值类型的变量直接存储数据，将数据存储在栈中。而引用类型的变量持有的是数据的引用，数据存储在堆中（对其的实例引用存储在栈中）（面试碰到的话后续还可以引申栈和堆的一些区别，比如GC标记压缩的垃圾回收方法等等）。</strong></span></p><p>（2）<span style="color:red">同时对于struct（值类型）和class（引用类型）来说，struct和class都可以实现接口（函数），但是struct在赋值时（如struct s1=s2）会直接创建s2的副本并赋值给s1，而对于class赋值时（class c1=c2）时会将两个类指向同一个引用，后续操作会同时改变同一个堆中实例。</span></p><p>（3）<span style="color:red">所有的值类型都继承System.ValueType，引用类型继承自System.Object。（其实引用类型和值类型都继承自System.Object类，不同的是，几乎所有的引用类型都直接从System.Object继承，而值类型则继承其子类，即直接继承System.ValueType）</span></p><p><span style="color:blue">△ 如果一个值类型被声明在一个方法体外并且在一个引用类型中，那它就会在堆上进行分配。</span></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> C# </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode记录：211 添加与搜索单词-数据结构设计</title>
      <link href="/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h2><p><img src="/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20211019103409399.png" alt="image-20211019103409399"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    比较典型的一道前缀树的题目，注意在构建前缀树的过程中不要粗心大意即可，前缀树的定义可以参考<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/">208. 实现 Trie (前缀树) 的官方题解</a>。</p><p><span style="color:red">1.用一个is_end来记录是否到达结尾，2.结点向下的多叉树子结点用vector&lt;TrieNode *&gt;来记录</span></p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TrieNode *&gt; childs;</span><br><span class="line">    <span class="keyword">bool</span> is_end;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>(<span class="keyword">bool</span> _is_end=<span class="literal">false</span>)&#123;</span><br><span class="line">        childs=vector&lt;TrieNode *&gt;(<span class="number">26</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        is_end=_is_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        head_node=<span class="keyword">new</span> <span class="built_in">TrieNode</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于前缀树的word增加</span></span><br><span class="line">        <span class="keyword">int</span> length=word.<span class="built_in">length</span>();</span><br><span class="line">        TrieNode *temp=head_node;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch=word[i];</span><br><span class="line">            <span class="keyword">int</span> index=ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;childs[index]==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                temp-&gt;childs[index]=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp-&gt;childs[index];</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;is_end=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于前缀树的word搜索</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word,<span class="number">0</span>,head_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word,<span class="keyword">int</span> index,TrieNode* node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//循环跳出条件</span></span><br><span class="line">        <span class="keyword">if</span> (index==word.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;is_end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> ch=word[index];</span><br><span class="line">        <span class="keyword">if</span> (ch!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index_=ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            TrieNode* temp=node-&gt;childs[index_];</span><br><span class="line">            <span class="keyword">if</span>(temp!=<span class="literal">nullptr</span>&amp;&amp;<span class="built_in">search</span>(word,index+<span class="number">1</span>,temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                TrieNode* temp=node-&gt;childs[i];</span><br><span class="line">                <span class="keyword">if</span>(temp!=<span class="literal">nullptr</span>&amp;&amp;<span class="built_in">search</span>(word,index+<span class="number">1</span>,temp))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *head_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session和Cookie的区别、联系</title>
      <link href="/2021/10/18/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB/"/>
      <url>/2021/10/18/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考：https://www.cnblogs.com/ITCodeMonkey/p/7874343.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity服务器--什么是RPC?</title>
      <link href="/2021/10/18/Unity%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%BB%80%E4%B9%88%E6%98%AFRPC/"/>
      <url>/2021/10/18/Unity%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%BB%80%E4%B9%88%E6%98%AFRPC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>在学习ET框架中Client与Server交互时的message信息中碰到的RpcId，之前没有太了解，固趁这个机会了解以下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">知乎参考：https://zhuanlan.zhihu.com/p/76727302</span><br></pre></td></tr></table></figure><p>此篇可能会慢慢更新。。。</p><h2 id="RPC-调用分类"><a href="#RPC-调用分类" class="headerlink" title="RPC 调用分类"></a>RPC 调用分类</h2><p>RPC调用分为以下两种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 同步调用  --c2s_new,s2c_new</span><br><span class="line">   客户方等待调用执行完成并返回结果。 </span><br><span class="line">2. 异步调用  --c2s_new,sreq_new</span><br><span class="line">   客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。 </span><br><span class="line">   若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 网络 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode记录:476 数字的补数</title>
      <link href="/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/"/>
      <url>/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/image-20211018101215331.png" alt="image-20211018101215331"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题的解题思路其实比较清晰，就是求二进制然后取反重新计算新数，可以直接在求解二进制的过程中直接得出最终的结果。</p><p>​    以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先求出其二进制数</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123; <span class="comment">//这里因为题目要求其实num/2!=0也可以</span></span><br><span class="line">            <span class="keyword">int</span> temp=(num%<span class="number">2</span>+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">            result+=<span class="built_in">pow</span>(<span class="number">2</span>,count++)*temp;</span><br><span class="line">            num/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        <span style="color:red">单看这个可能问题已经解决了，但是题目中想让我们实现的位运算其实并没有做到，在看到一些大佬的题解后，其实还有更简单直接的方法。</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp = num, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            c =  (c &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num ^ c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        <span style="color:blue">这里的思路是：求出temp有多少位以后利用得出一个全1的c，再通过num^c（异或）就能得出最终结果，更符合题目的要求。</span></p><p>​    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++运算符优先级参考：https://www.sojson.com/operation/cxx.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET6.0框架初步</title>
      <link href="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/"/>
      <url>/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    因为学校毕设选题选择了Unity游戏开发相关的内容，并且ECS一直是我比较想去了解的方面，所以选择了ET作为毕设游戏所采用的框架。</p><h2 id="ECS相对于传统面向对象模式"><a href="#ECS相对于传统面向对象模式" class="headerlink" title="ECS相对于传统面向对象模式"></a>ECS相对于传统面向对象模式</h2><p>​    以前曾开发过ARPG的demo和2D横版过关的demo，所采用的都是传统的面向对象的思路和方法。采用类继承的方式，在前期的开发过程中还是比较轻松，但是在后期的基类逐渐冗余后，也能感觉到面向对象的一些的缺点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考：https://www.cnblogs.com/egametang/p/7511589.html</span><br></pre></td></tr></table></figure><p>​    在看了上面这篇文章以后，更是对一些面向对象的优缺点有了更深的体会，浓缩为以下两点。</p><h3 id="1-数据结构耦合性强"><a href="#1-数据结构耦合性强" class="headerlink" title="1.数据结构耦合性强"></a>1.数据结构耦合性强</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一旦父类中增加或删除某个字段，可能要影响到所有子类，影响到所有子类相关的逻辑。</span><br></pre></td></tr></table></figure><h3 id="2-难以热插拔"><a href="#2-难以热插拔" class="headerlink" title="2.难以热插拔"></a>2.难以热插拔</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">继承结构无法在运行时动态增加或删除字段，比如有时会需要取消player的某个功能，但这时只能进行禁用，而不能把功能完完全全的剥离出去。</span><br></pre></td></tr></table></figure><p>​    这点在lua中其实得到了很好的解决，在实习阶段我也是基本用的lua来进行minigame的开发，相对于C#来说，Lua语言其实可以选择抛弃传统的纯粹继承的方式，采用类似于<span style="color:red">单例类+require</span>的方式来进行逻辑开发，而实际上在除游戏实际角色、技能、状态机之外的情况下我也确实采用了这种方法来编写（登入，选服，匹配等等）。可以说这段经历对我来说是一段新的体验，也更加深了我想要去了解ECS组件式开发的兴趣。</p><p>​    <span style="color:blue">ET框架作为一个Unity的双端框架，采用了ECS的组件式概念来进行设计，其ECS的概念也曾经应用于热门的商业游戏守望先锋等，即实体(Entity)-组件(Component)-系统(system),其将Entity中所具有的Component抽象出来，遵循组合大于继承的原则，每位实体都通过一个或多个组件ID连接多个功能组件,避免了一些不必要的开销。</span></p><p>​    <span style="color:red"><strong>这篇文章仅用于记录下ECS学习过程中的一些心得体会，主要还是对烟雨大佬视频的一些自身收获。</strong></span></p><h2 id="1-环境配置和demo运行"><a href="#1-环境配置和demo运行" class="headerlink" title="1.环境配置和demo运行"></a>1.环境配置和demo运行</h2><p><span style="color:red"><strong>在ET/Book中已经有各种ET框架指南，本篇主要是记录一些具体过程。</strong></span></p><p>先放一下工程中整体的目录截图：</p><p>分为两个主要的sln，Unity和Server：</p><p>Unity：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017140008420.png" alt="image-20211017140008420"></p><p>Server：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017140040074.png" alt="image-20211017140040074"></p><p><strong>△Unity和Server中所有的project都要进行build的操作</strong></p><p>服务器：</p><p>​    需要安装MongoDB数据库（对于ET的初始demo来说不需要，因为其将数据库交互部分注释了）</p><p>​    需要安装Net Core 或Net Framework（我用的是Net5.0）</p><p>​    在build后启动Server.App即可开启服务器</p><p>客户端：</p><p>​    在UnityHub中打开对应项目工程后，首先在Assets/Scenes中找到启动的Init场景</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017143237959.png" alt="image-20211017143237959"></p><p>运行后即可输入账号密码进入游戏场景</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017143405871.png" alt="image-20211017143405871"></p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017143434676.png" alt="image-20211017143434676"></p><h2 id="2-导表部分"><a href="#2-导表部分" class="headerlink" title="2.导表部分"></a>2.导表部分</h2><p>先上一张导表方法图：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/ET%E5%AF%BC%E8%A1%A8%E6%96%B9%E6%B3%95.png" alt="ET导表方法"></p><p><span style="color:red">与烟雨大佬视频中的不同，现在的ET版本中导表工具已经由之前的Assets/Editor/ExcelExporterEditor/ExcelExporterEditor.cs迁移到Server/Model/ExcelExporter/ExcelExporter.cs，而在Unity中的Editor拓展也已经移除了。</span></p><h3 id="过程理解："><a href="#过程理解：" class="headerlink" title="过程理解："></a>过程理解：</h3><h4 id="导出JSON-暂存信息-："><a href="#导出JSON-暂存信息-：" class="headerlink" title="导出JSON(暂存信息)："></a>导出JSON(暂存信息)：</h4><p>让我们先打开这个ExcelExporter.cs，其在调用时已经被包含在<span style="color:red">ET/Bin/Server.dll</span>的动态链接库中，因此我们当前的目录其实就是Bin，接下来看下图中的Excel表，Json表等存放的路径就非常清晰了。</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017153220996.png" alt="image-20211017153220996"></p><p>对于Excel的读取采用了OfficeOpenXml中的ExcelPackage类来进行处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C#excelpackage读写Excel文件：https://www.cnblogs.com/sange0708/p/15005370.html</span><br></pre></td></tr></table></figure><p>先来看一下在demo中给出的AIConfig.xlsx的表格例子：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017162205295.png" alt="image-20211017162205295"></p><p>对应在ExcelPackage读取后的JSON导出代码：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017162408170.png" alt="image-20211017162408170"></p><p>可以得知对应Excel中<span style="color:blue">第二行为是否不导出为JSON，第三行的内容为变量描述、第四行为变量名、第五行为导出类型</span></p><p><span style="color:red">#作为中断读取的标志，有#的变量都不会导出为Json</span></p><p>之后是对具体变量内容的读取和写入：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017163109993.png" alt="image-20211017163109993"></p><p>根据之前读取到的头文件信息，从Excel表中的第六行开始进行读取，而后在StringBuffer中写入对应的json信息。</p><h4 id="导出类-用于反序列化-："><a href="#导出类-用于反序列化-：" class="headerlink" title="导出类(用于反序列化)："></a>导出类(用于反序列化)：</h4><p>其对<span style="color:red">headInfo</span>的读取与导出JSON是相同的，关键点在于对于class读取类的导出，用到了在Export中读取到的template.txt，它其实是一个类class的代码模板(继承自ProtoObject)，导出类做的主要工作就是将类名、域名等的信息套到这个模板代码中，并生成对应的cs文件。</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017164315689.png" alt="image-20211017164315689"></p><h4 id="根据生成的类，动态编译把JSON转译成protobuf："><a href="#根据生成的类，动态编译把JSON转译成protobuf：" class="headerlink" title="根据生成的类，动态编译把JSON转译成protobuf："></a>根据生成的类，动态编译把JSON转译成protobuf：</h4><p>比起之前版本的ET，新版本的ET是通过<strong>protobuf</strong>来作为序列化数据的。因此最关键的一步就是转译，具体的代码过程就不贴出来了。</p><h3 id="使用例子："><a href="#使用例子：" class="headerlink" title="使用例子："></a>使用例子：</h3><h4 id="导表："><a href="#导表：" class="headerlink" title="导表："></a>导表：</h4><p>​    在cmd中cd到对应的<strong>根目录/Bin</strong>文件夹中，而后执行dotnet Server.dll –AppType=ExcelExporter即可，导出的表格会分别存放在./Client/Json文件夹和./Server/Json文件夹中。</p><p>​    <img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017164636195.png" alt="image-20211017164636195"></p><h4 id="脚本使用："><a href="#脚本使用：" class="headerlink" title="脚本使用："></a>脚本使用：</h4><p>​    在具体CS脚本中的通过<span style="color:red">表格名+Category</span>的单例类就可以获取对应的表格信息（key值对应ID）。</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017170048269.png" alt="image-20211017170048269"></p><h2 id="3-Proto生成CS与拓展"><a href="#3-Proto生成CS与拓展" class="headerlink" title="3.Proto生成CS与拓展"></a>3.Proto生成CS与拓展</h2><p><span style="color:red">ET框架采用了分布式服务器的方式。</span></p><p>同样列出上方的一张图：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211018155809927.png" alt="image-20211018155809927"></p><p>我们先来找到ET/Model/Proto2CS/Program.cs文件，与导表的cs文件相同，其在具体使用的时候同样是被打成了dll放在了ET/Bin文件夹下，因此文件的根目录同样是Bin文件夹。</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211018160111894.png" alt="image-20211018160111894"></p><p>​        对于客户端和服务器的生成路径如上图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">之前在实习阶段也对proto的定义有了一些理解，但是在实际看到ET框架内的proto的时候还是和之前所认知的有一些差别，</span><br><span class="line">之前的框架是基于lua脚本因此对proto来说无需转换到CS，而如今ET框架的热更等是面向ILRuntime的。</span><br></pre></td></tr></table></figure><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211018163131915.png" alt="image-20211018163131915"></p><p>看到具体的Proto2CS的生成函数：</p><p>1.InnerMessage是服务器内部的协议生成，可能是用于分布式的多服务器沟通</p><p>2.OuterMessage则是针对于C2S和S2C之间的交互了</p><h3 id="使用例子：-1"><a href="#使用例子：-1" class="headerlink" title="使用例子："></a>使用例子：</h3><h4 id="脚本使用：-1"><a href="#脚本使用：-1" class="headerlink" title="脚本使用："></a>脚本使用：</h4><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211018171843943.png" alt="image-20211018171843943"></p>]]></content>
      
      
      <categories>
          
          <category> Unity框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> Unity </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-first-blog</title>
      <link href="/2021/10/16/my-first-blog/"/>
      <url>/2021/10/16/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>测试—Test</p><p><span style="color:red">新的开始</span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/16/hello-world/"/>
      <url>/2021/10/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
