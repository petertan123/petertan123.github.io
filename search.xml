<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode: 488.祖玛游戏</title>
      <link href="/2021/11/09/Leetcode-488-%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/11/09/Leetcode-488-%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="488-祖玛游戏"><a href="#488-祖玛游戏" class="headerlink" title="488. 祖玛游戏"></a><a href="https://leetcode-cn.com/problems/zuma-game/">488. 祖玛游戏</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211109101310993.png" alt="image-20211109101310993"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    在刚开始看题时虽然想到了可能要用dfs来解决，但是对于每次插入球后的消球过程没有特别好的解决思路，后续参考了其他的题解后才得到了<span style="color:red">快慢指针</span>用于处理插入球后的消除过程的Update思路，并且也考虑到了记忆化搜索优化超时。</p><ul><li>整个解题过程分为两个阶段，DFS+记忆化搜索+回溯与每次插入后的消除过程<ul><li>每次插入后的消除过程采用了快慢指针的方式，设slow指针和fast指针的初始值为0，fast遍历插入球后的整个字符串。<ul><li>若fast&lt;board.size()且board[fast]==board[slow]则代表当前slow和fast所指代的球的颜色是相同的，进行continue的操作</li><li>若fast-slow&gt;=3则代表当前慢指针slow到快指针fast之间为三个或三个颜色相同以上的球，因此用string.erase来进行消除操作，同时设fast=0，需要重新进行遍历</li><li>每次遍历结束的末尾需要将slow=fast，因为当前指代的是fast与slow中指代的不是相同颜色的球，所以slow的判断可以继续往下来搜索。</li></ul></li><li>主函数通过DFS+记忆化搜索+回溯的方式<ul><li>用set&lt;pair&lt;string,int&gt;&gt;的vis来存储对应的board字符串板子对应已经扔球的次数，来防止有重复的DFS过程发生</li><li>对于每次的DFS过程都需要遍历当前的board的每一个位置以及当前手上的所有球，并且创建好新的插入球的板子nb并且进行Update过程，所得到的nb进入下一层的DFS过程，<span style="color:red">并且因为是&amp;hand，记住要进行回溯操作，即在该层dfs结束后把扔进去的球重新加入到hand中。</span></li></ul></li></ul></li></ul><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> min_cnt = INT_MAX;</span><br><span class="line">    set&lt;pair&lt;string, <span class="keyword">int</span>&gt; &gt; vis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//△重点看一下这个面板的更新，消球的过程</span></span><br><span class="line">    <span class="comment">//快慢指针的使用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateBoard</span><span class="params">(string&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了最后一次判断fast需要&lt;=board.size()</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>; fast &lt;= board.<span class="built_in">size</span>(); fast++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (fast &lt; board.<span class="built_in">size</span>() &amp;&amp; board[slow] == board[fast]) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">if</span> (fast - slow &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">               board.<span class="built_in">erase</span>(slow, fast - slow);</span><br><span class="line">               fast = <span class="number">0</span>; <span class="comment">//这里一定要重新从0索引开始寻找，因为可能会因为消球出现新的情况</span></span><br><span class="line">           &#125;</span><br><span class="line">           slow = fast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dfs+记忆化搜索的思路</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(string&amp; board, string&amp; hand, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= min_cnt) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (vis.<span class="built_in">count</span>(&#123;board, cnt&#125;)) <span class="keyword">return</span>; <span class="comment">//剪枝，这里要记下cnt的原因是同一个板子可能是经过了不同次数的插球导致的</span></span><br><span class="line">        vis.<span class="built_in">insert</span>(&#123;board, cnt&#125;); <span class="comment">//将板子对应其插球个数加入到记忆化set中</span></span><br><span class="line">        <span class="keyword">if</span> (board==<span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            min_cnt = <span class="built_in">min</span>(min_cnt, cnt); <span class="comment">//找到了将球全部消除的次数，与当前最小次数取最小值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hand==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>(), m = hand.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">char</span> ch = hand[j];</span><br><span class="line">                hand.<span class="built_in">erase</span>(hand.<span class="built_in">begin</span>() + j); </span><br><span class="line">                <span class="comment">//创建新的插入球后的板子</span></span><br><span class="line">                string nb = board;</span><br><span class="line">                nb.<span class="built_in">insert</span>(nb.<span class="built_in">begin</span>() + i, ch);</span><br><span class="line">                <span class="built_in">UpdateBoard</span>(nb);</span><br><span class="line">                <span class="built_in">DFS</span>(nb, hand, cnt + <span class="number">1</span>); <span class="comment">//dfs过程</span></span><br><span class="line">                hand.<span class="built_in">insert</span>(hand.<span class="built_in">begin</span>() + j, ch); <span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(string board, string hand)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(board, hand, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> min_cnt == INT_MAX ? <span class="number">-1</span> : min_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 299.猜数字游戏</title>
      <link href="/2021/11/08/Leetcode-299-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/11/08/Leetcode-299-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299. 猜数字游戏"></a><a href="https://leetcode-cn.com/problems/bulls-and-cows/">299. 猜数字游戏</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211108101910571.png" alt="image-20211108101910571"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题公牛是比较好求的，遍历secret和guess判断对应字符是否相等即可，但是奶牛的思路需要转换，题目中的含义是数字猜对但是位置不对，这里可以分为两种情况。</p><ol><li>在对应位置上不相同时，secret中该数字的出现次数比guess少，这时对于guess来说只能填补secret字符中该数字的个数，guess多出字符无用，所以结果应取secret中该数字的次数</li><li>在对应位置上不相同时，secret中该数字的出现次数比guess多，这时对于guess来说只能填补自身数量的secret字符，secret多出字符无用，所以结果应取guess中该数字出现的次数</li></ol><p>综上所述其实可以把奶牛的求解通过这样的方式：用哈希表arr1和arr2分别存储secret和guess中对应数字的存储次数，而后对于每个数字来说求arr1与arr2中对应数字的最小值，其的和为奶牛的个数。</p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getHint</span><span class="params">(string secret, string guess)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用两个哈希表分别存储secret和guess的对应数字的个数</span></span><br><span class="line">        <span class="keyword">int</span> len=secret.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> arr1[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;,arr2[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ANum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(secret[i]==guess[i])&#123;</span><br><span class="line">                ++ANum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr1[secret[i]-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">            arr2[guess[i]-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到arr1和arr2中对应数字的最小值</span></span><br><span class="line">        <span class="keyword">int</span> BNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            BNum+=<span class="built_in">min</span>(arr1[i],arr2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组合答案</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(ANum)+<span class="string">&quot;A&quot;</span>+<span class="built_in">to_string</span>(BNum)+<span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 598.范围求和 II</title>
      <link href="/2021/11/07/Leetcode-598-%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8C-II/"/>
      <url>/2021/11/07/Leetcode-598-%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8C-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="598-范围求和-II"><a href="#598-范围求和-II" class="headerlink" title="598. 范围求和 II"></a><a href="https://leetcode-cn.com/problems/range-addition-ii/">598. 范围求和 II</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211107100449476.png" alt="image-20211107100449476"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题可以将思路转变为求operations中所表示的所有矩形中相交最多次数的矩形面积，同时根据题目要求，其每个矩形都是以左上角为起点，这样就转换为了<span style="color:red">求operations中代表矩形的长、宽的最小值</span>，其相乘即为最终结果，同时<span style="color:red">长、宽的初始值为m,n</span>。</p><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ops)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这题可以引申为求包围的最小的矩形面积</span></span><br><span class="line">        <span class="keyword">int</span> w=m,h=n;</span><br><span class="line">        <span class="keyword">int</span> len=ops.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            w=<span class="built_in">min</span>(ops[i][<span class="number">0</span>],w);</span><br><span class="line">            h=<span class="built_in">min</span>(ops[i][<span class="number">1</span>],h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w*h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 268.丢失的数字</title>
      <link href="/2021/11/06/Leetcode-268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/11/06/Leetcode-268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a><a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211106165705668.png" alt="image-20211106165705668"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题比较简单，用哈希表记录下出现的次数，然后找到哈希表中value为0的唯一值即可。</p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用哈希表记录下出现的数字</span></span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> *arr=<span class="keyword">new</span> <span class="keyword">int</span>[len]();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            arr[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到arr中值为0的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==<span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 1218.最长定差子序列</title>
      <link href="/2021/11/05/Leetcode-1218-%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2021/11/05/Leetcode-1218-%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1218-最长定差子序列"><a href="#1218-最长定差子序列" class="headerlink" title="1218. 最长定差子序列"></a><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">1218. 最长定差子序列</a></h2><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211105194905197.png" alt="image-20211105194905197"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题是动态规划的题目，其实往深了看可以作为一个背包问题，arr中元素为每件物品的权重，而等差数列则是每件物品权重判断的条件，在内部将背包问题中的max()求最大存储物品数量改为等差数列长度+1。</p><p>方法思路：</p><ul><li>map第一个元素表示符合等差数列的最后一个元素，第二个表示该等差数列的长度</li><li>遍历arr的元素，若m不存在则加入其中，若存在则获取其长度后+1赋值给当前元素对应值</li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="comment">//第一个元素表示符合等差数列的最后一个元素，第二个表示该等差数列的长度</span></span><br><span class="line">        <span class="comment">//遍历arr的元素，若m不存在则加入其中，若存在则获取其长度后+1赋值给当前元素对应值</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:arr)&#123;</span><br><span class="line">            m[num]=m[num-difference]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找最大长度</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter=m.<span class="built_in">begin</span>();iter!=m.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,iter-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 367.有效的完全平方数</title>
      <link href="/2021/11/04/Leetcode-367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
      <url>/2021/11/04/Leetcode-367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数</a></h2><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211104191909465.png" alt="image-20211104191909465"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题主要是优化的方法采取了二分法的方法，是可以作为一些题目中遍历搜索的优化解的。其余的就是注意int的乘法会造成越界，结果应该转换为long类型来存储。</p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二分法思路优化</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=num;</span><br><span class="line">        <span class="keyword">int</span> half;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            half=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> temp=(<span class="keyword">long</span>)half*half;</span><br><span class="line">            <span class="keyword">if</span>(num==temp)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;temp)&#123;</span><br><span class="line">                right=half<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=half+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 575.分糖果</title>
      <link href="/2021/11/01/Leetcode-575-%E5%88%86%E7%B3%96%E6%9E%9C/"/>
      <url>/2021/11/01/Leetcode-575-%E5%88%86%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="575-分糖果"><a href="#575-分糖果" class="headerlink" title="575. 分糖果"></a><a href="https://leetcode-cn.com/problems/distribute-candies/">575. 分糖果</a></h2><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211101124624197.png" alt="image-20211101124624197"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题比较简单，一共有两种解题思路。</p><ul><li>用hash表记录下当前糖果种类，在其与平均分数目之间取最小值</li><li>模拟整个分配过程，现将第一个分给妹妹，后续用leftCount记录下剩余可以分配的数量，并且在排序后通过candyType[i]&gt;candyType[i-1]判断是否是新种类</li></ul><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candyType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法1：</span></span><br><span class="line">        <span class="comment">//用hash表记录下当前糖果种类</span></span><br><span class="line">        <span class="comment">// unordered_map&lt;int,int&gt; m;</span></span><br><span class="line">        <span class="comment">// for(auto type:candyType)&#123;</span></span><br><span class="line">        <span class="comment">//     ++m[type];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int type_count=0;</span></span><br><span class="line">        <span class="comment">// for(auto pair:m)&#123;</span></span><br><span class="line">        <span class="comment">//     ++type_count;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// return min(type_count,(int)candyType.size()/2);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法2</span></span><br><span class="line">        <span class="comment">//模拟整个分配过程</span></span><br><span class="line">        <span class="keyword">int</span> length=candyType.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> leftCount=length/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxType=<span class="number">1</span>;<span class="comment">//现将第一个分给妹妹</span></span><br><span class="line">        <span class="built_in">sort</span>(candyType.<span class="built_in">begin</span>(),candyType.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length&amp;&amp;leftCount&gt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candyType[i]&gt;candyType[i<span class="number">-1</span>])&#123;</span><br><span class="line">                leftCount--;</span><br><span class="line">                maxType++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 500.键盘行</title>
      <link href="/2021/10/31/Leetcode-500-%E9%94%AE%E7%9B%98%E8%A1%8C/"/>
      <url>/2021/10/31/Leetcode-500-%E9%94%AE%E7%9B%98%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="500. 键盘行"></a><a href="https://leetcode-cn.com/problems/keyboard-row/">500. 键盘行</a></h2><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211031150045980.png" alt="image-20211031150045980"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题主要就是用哈希表记录下对应字符的行数，而后遍历所有的words判断字符串是否在同一行即可，时间复杂度为O(n*m)（n为words长度，m为单个word长度）</p><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ch2line[<span class="number">26</span>]=&#123;</span><br><span class="line">        <span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=words.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            string word=words[i];</span><br><span class="line">            <span class="keyword">int</span> len=word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> type=ch2line[<span class="built_in">tolower</span>(word[<span class="number">0</span>])-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(type!=ch2line[<span class="built_in">tolower</span>(word[j])-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==len) res.<span class="built_in">push_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 260:只出现一次的数字 III</title>
      <link href="/2021/10/30/Leetcode-260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-III/"/>
      <url>/2021/10/30/Leetcode-260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-III/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h1><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211030142711412.png" alt="image-20211030142711412"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题首先最简单的方法肯定是遍历+哈希表记录次数的方法，主要说第二种优化了空间复杂度的方法。</p><ul><li><p>遍历nums的所有元素并进行异或处理，得到temp</p></li><li><p>获取temp的最低位1，由此就可以将恰好出现一次的两个元素分成两组</p><ul><li>temp^(-temp)的方法获取最低位1（-temp其实对应二进制的取反+1，若原位为1则变为0，+1后&amp;为1，若原位为0则变为1，+1后向前进位且&amp;结果为0，因此恰好可以获取到最低位1）</li><li>设定lowOne=1，while(lowOne&amp;temp==0) lowOne&lt;&lt;=1; （也就是逐步左移判断）</li></ul></li><li><p>遍历nums的所有元素，根据得到得到lowOne*nums[i]判断所在组，同组的所有元素再进行异或操作，就能得到两个结果，返回即可。</p></li></ul><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用最低位1将得到的结果分成两个部分</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            temp^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最低位1的两种方法</span></span><br><span class="line">        <span class="comment">//方法1</span></span><br><span class="line">        <span class="comment">//int lowOne=temp==INT_MIN?temp:temp&amp;(-temp); </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法2</span></span><br><span class="line">        <span class="keyword">int</span> lowOne=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((lowOne&amp;temp)==<span class="number">0</span>) lowOne&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&amp;lowOne)&#123;</span><br><span class="line">                ans1^=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans2^=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;ans1,ans2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 335.路径交叉</title>
      <link href="/2021/10/29/Leetcode-335-%E8%B7%AF%E5%BE%84%E4%BA%A4%E5%8F%89/"/>
      <url>/2021/10/29/Leetcode-335-%E8%B7%AF%E5%BE%84%E4%BA%A4%E5%8F%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="335-路径交叉"><a href="#335-路径交叉" class="headerlink" title="335. 路径交叉"></a><a href="https://leetcode-cn.com/problems/self-crossing/">335. 路径交叉</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211029102151630.png" alt="image-20211029102151630"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这种归纳的题目是真的不太熟且感觉意义不大。。，根据题解，最多只需要关注最近所画的五条边即可，且总共具有四种可能的情况，如下图所示，分别根据四种可能的情况列出if的判断式子即可。</p><p><img src="https://pic.leetcode-cn.com/1635437888-JuQzXp-007S8ZIlly1ghltxkbce9j30ro0o676d.jpg" alt="示例"></p><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSelfCrossing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; distance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一道类似归纳的题目</span></span><br><span class="line">        <span class="comment">//只需要关注近5条边即可</span></span><br><span class="line">        <span class="keyword">int</span> length=distance.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="comment">//第一种情况</span></span><br><span class="line">            <span class="keyword">if</span> (distance[i<span class="number">-1</span>]&lt;=distance[i<span class="number">-3</span>]&amp;&amp;distance[i]&gt;=distance[i<span class="number">-2</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">4</span>&amp;&amp;distance[i]+distance[i<span class="number">-4</span>]==distance[i<span class="number">-2</span>]&amp;&amp;distance[i<span class="number">-1</span>]==distance[i<span class="number">-3</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">5</span>&amp;&amp;distance[i<span class="number">-4</span>]&lt;=distance[i<span class="number">-2</span>]&amp;&amp;distance[i]&gt;=distance[i<span class="number">-2</span>]-distance[i<span class="number">-4</span>]&amp;&amp;distance[i<span class="number">-1</span>]&gt;=distance[i<span class="number">-3</span>]-distance[i<span class="number">-5</span>]&amp;&amp;distance[i<span class="number">-1</span>]&lt;=distance[i<span class="number">-3</span>]&amp;&amp;distance[i<span class="number">-3</span>]&gt;=distance[i<span class="number">-5</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>869. 重新排序得到2的幂</title>
      <link href="/2021/10/28/869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/"/>
      <url>/2021/10/28/869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="869-重新排序得到-2-的幂"><a href="#869-重新排序得到-2-的幂" class="headerlink" title="869. 重新排序得到 2 的幂"></a><a href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></h2><p><img src="/2021/10/28/869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/image-20211028104103060.png" alt="image-20211028104103060"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题是可以说是把两道题混合在了一起，分别是<a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a>和<a href="https://leetcode-cn.com/problems/power-of-two/">231. 2 的幂</a>，先通过前者求出全排列（回溯），当判断出现了符合要求的数后对后续进行剪枝操作即可。</p><ul><li>注意Swap交换数字位置进行迭代之后要再通过Swap进行还原</li></ul><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isSucc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求全排列后逐个判断是否是2的幂</span></span><br><span class="line">        isSucc=<span class="literal">false</span>;</span><br><span class="line">        string str=<span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>()); <span class="comment">//先进行排序(减少无用的匹配次数)</span></span><br><span class="line">        <span class="built_in">GetAllOrder</span>(str,<span class="number">0</span>,str.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> isSucc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetAllOrder</span><span class="params">(string&amp; str,<span class="keyword">int</span> index,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(str)) isSucc=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index==<span class="number">0</span>&amp;&amp;str[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//跳过首位为0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Swap</span>(str,index,i);</span><br><span class="line">            <span class="built_in">GetAllOrder</span>(str,index+<span class="number">1</span>,length);</span><br><span class="line">            <span class="built_in">Swap</span>(str,index,i);</span><br><span class="line">            <span class="keyword">if</span>(isSucc) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> string&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> (n&amp;(n<span class="number">-1</span>))==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(string &amp;str,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp=str[n];</span><br><span class="line">        str[n]=str[m];</span><br><span class="line">        str[m]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 301 删除无效的括号</title>
      <link href="/2021/10/27/Leetcode-301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/2021/10/27/Leetcode-301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="301-删除无效的括号"><a href="#301-删除无效的括号" class="headerlink" title="301. 删除无效的括号"></a><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211027104415171.png" alt="image-20211027104415171"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题采用了BFS的思路，因为题目要求中需要删除最少的无效括号来满足要求。所以我们采用了层级划分的方法。</p><ul><li>每次递归都会遍历删除相同数量的括号所有字符串，判断其是否合法，合法则将其加入到结果res的向量中</li><li>每次递归都会在第一步后判断ans的数量是否大于0，大于则表示当前层级是删除最少的无效括号的情况，直接return即可</li><li>若无ans，则用nextSet记录下下一个层级的所有可能字符串(用str.substr(0,i)+str.substr(i+1)来进行切割)，<span style="color:red">△注意这里即便判断了s[i]==s[i-1]执行continue，还是需要set来进行去重操作，因为在最后只剩下一个括号时会导致重复情况。</span></li></ul><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//采用BFS的方式遍历,用set+判断来去重</span></span><br><span class="line">        unordered_set&lt;string&gt; set;</span><br><span class="line">        set.<span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="built_in">BFS</span>(set);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(unordered_set&lt;string&gt; &amp;curStr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//BFS层次遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:curStr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(str))&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在某个层级中有解则return</span></span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; nextSet;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:curStr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;s[i]==s[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>||s[i]==<span class="string">&#x27;)&#x27;</span>) nextSet.<span class="built_in">insert</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, i) + s.<span class="built_in">substr</span>(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">BFS</span>(nextSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 496 下一个更大元素 I</title>
      <link href="/2021/10/26/Leetcode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/"/>
      <url>/2021/10/26/Leetcode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h2><p><img src="/2021/10/26/Leetcode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/image-20211026095137887.png" alt="image-20211026095137887"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题通过暴力法的话时间复杂度为O(nums1.length*nums2.length)。</p><p>​    但是能引出一种时间复杂度为O(nums1.length+nums2.length)的思路，即单调栈+哈希表的方法。</p><p>​    整体思路(s为栈,m为哈希表,res为结果向量)：</p><ol><li><p>反向遍历nums2，每次遍历时在栈中令s.top()和nums2[i]进行比较，排出栈中所有比nums2[i]小的元素，将栈顶元素结果存储在m[nums2[i]]中，并在最后将nums2[i]加入到栈中</p></li><li><p>遍历nums1，每次遍历时将其在m中对应结果加入到res中（即res.push_back(m[nums1[i]])）;</p><p><span style="color:red">△这种思路同样能引用于在vector中寻找第一个满足于<strong>某个条件</strong>的元素，只需要通过单调栈+反向遍历的方式即可，在遍历时循环判断若当前栈顶元素满足时遍历元素是否一定满足，若是则弹出栈顶元素即可。最后再将遍历元素加入到栈顶元素中。</span></p><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//考虑使用单调栈+哈希表的方式</span></span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//构建nums2的单调栈和结果哈希表</span></span><br><span class="line">        <span class="keyword">int</span> len2=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> len1=nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len2<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;nums2[i]&gt;=s.<span class="built_in">top</span>())&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums2[i]]=s.<span class="built_in">empty</span>()?<span class="number">-1</span>:s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//nums1根据nums2的结果哈希表获取最终结果加入res</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;++i)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(m[nums1[i]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 240 搜索二维矩阵 II</title>
      <link href="/2021/10/25/Leetcode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/"/>
      <url>/2021/10/25/Leetcode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><p><img src="/2021/10/25/Leetcode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/image-20211025100921484.png" alt="image-20211025100921484"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这道题的关键是找到右上角作为起始点，这样的话整个矩阵就能看做是一个二叉搜索树。</p><ul><li>以n,m为行列，判断情况如下：<ul><li>如果target&lt;matrix[n][m]，则取二叉搜索树中的左子树，即n–</li><li>如果target&gt;matrix[n][m]，则取二叉搜索树中的右子树，即m++</li><li>如果target==matrix[n][m]，则直接返回true</li></ul></li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从右上角开始二叉树搜索</span></span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>,row=matrix.<span class="built_in">size</span>(),m=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;row&amp;&amp;m&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;matrix[n][m])&#123;</span><br><span class="line">                m--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;matrix[n][m])&#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 638大礼包（记忆化DFS）</title>
      <link href="/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/"/>
      <url>/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638. 大礼包"></a><a href="https://leetcode-cn.com/problems/shopping-offers/">638. 大礼包</a></h2><p><img src="/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/image-20211024113701934.png" alt="image-20211024113701934"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><h4 id="基础代码："><a href="#基础代码：" class="headerlink" title="基础代码："></a>基础代码：</h4><p>​    近期花时间比较长的一道题，一开始以为是动态规划的题目，后面发现思路走不通换成DFS的思路。主要还是通过深搜+剪枝来获取所有可能的情况，而后通过min()来获取其最小值。</p><ul><li>用minPrice来作为最小值的记录，在最外层for循环结束（即当前层级的所有可能性结束后）返回</li><li>记录下lastPrice，其作为递归向下寻找可能性的依据，需要作为参数单独传入dfs函数中,<span style="color:red">一开始是把minPrice传进去，思路肯定是不对的（这样的话totalPrice就没办法保存下来了）。</span></li><li>记录下curPackagePrice，表示当前购买礼包所花费的价钱，根据其和needs计算后续的总价格totalPrice。</li><li>在每次循环过后要对needs和curPackagePrice进行还原</li><li><span style="color:red"><strong>注意：minPrice仅代表当前DFS层级上的最小价格。</strong></span></li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dfs递归</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter = <span class="built_in">RemovePackages</span>(price, special, needs);</span><br><span class="line">        <span class="keyword">int</span> lastPrice=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            lastPrice+=needs[i]*price[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, filter, needs,<span class="number">0</span>,lastPrice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">RemovePackages</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs) &#123;</span><br><span class="line">        <span class="comment">//排除掉收益不如单买的special</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; special.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; special[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                temp += price[j]*special[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; special[i].<span class="built_in">back</span>()) &#123;</span><br><span class="line">                filter.<span class="built_in">push_back</span>(special[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; filter, vector&lt;<span class="keyword">int</span>&gt;&amp; needs,<span class="keyword">int</span> curPackagePrice,<span class="keyword">int</span> lastPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalPrice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = lastPrice; <span class="comment">//在当前已有</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filter.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> succ = <span class="literal">true</span>;</span><br><span class="line">            totalPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (needs[j] &lt; filter[i][j]) &#123;</span><br><span class="line">                    succ = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!succ) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//加上礼包和剩余的单买</span></span><br><span class="line">                curPackagePrice += filter[i].<span class="built_in">back</span>();</span><br><span class="line">                totalPrice += curPackagePrice;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; needs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    needs[j] -= filter[i][j];</span><br><span class="line">                    totalPrice += needs[j] * price[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice,<span class="built_in">dfs</span>(price, filter, needs,curPackagePrice,totalPrice));</span><br><span class="line">            <span class="comment">//加回之前减去的package</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>()<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                needs[j] += filter[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            curPackagePrice -= filter[i].<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="优化过程："><a href="#优化过程：" class="headerlink" title="优化过程："></a>优化过程：</h4><p><span style="color:red">△发现还是有可优化的点，可以把curPackagePrice和lastPrice去掉</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dfs递归</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter = <span class="built_in">RemovePackages</span>(price, special, needs);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, filter, needs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">RemovePackages</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs) &#123;</span><br><span class="line">        <span class="comment">//排除掉收益不如单买的special</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; special.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; special[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                temp += price[j]*special[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; special[i].<span class="built_in">back</span>()) &#123;</span><br><span class="line">                filter.<span class="built_in">push_back</span>(special[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; filter, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minPrice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            minPrice+=needs[i]*price[i]; <span class="comment">//△全买情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filter.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> succ = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (needs[j] &lt; filter[i][j]) &#123;</span><br><span class="line">                    succ = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!succ) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; needs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    needs[j] -= filter[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice,<span class="built_in">dfs</span>(price, filter, needs)+filter[i].<span class="built_in">back</span>());</span><br><span class="line">            <span class="comment">//加回之前减去的package</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>()<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                needs[j] += filter[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>附带上官方题解的记忆化深搜</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;vector&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = price.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤不需要计算的大礼包，只保留需要计算的大礼包</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filterSpecial;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; sp : special) &#123;</span><br><span class="line">            <span class="keyword">int</span> totalCount = <span class="number">0</span>, totalPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                totalCount += sp[i];</span><br><span class="line">                totalPrice += sp[i] * price[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (totalCount &gt; <span class="number">0</span> &amp;&amp; totalPrice &gt; sp[n]) &#123;</span><br><span class="line">                filterSpecial.<span class="built_in">emplace_back</span>(sp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, special, needs, filterSpecial, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索计算满足购物清单所需花费的最低价格</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; price,<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp; special, vector&lt;<span class="keyword">int</span>&gt; curNeeds, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp; filterSpecial, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!memo.<span class="built_in">count</span>(curNeeds)) &#123;</span><br><span class="line">            <span class="keyword">int</span> minPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                minPrice += curNeeds[i] * price[i]; <span class="comment">// 不购买任何大礼包，原价购买购物清单中的所有物品</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; curSpecial : filterSpecial) &#123;</span><br><span class="line">                <span class="keyword">int</span> specialPrice = curSpecial[n];</span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; nxtNeeds;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (curSpecial[i] &gt; curNeeds[i]) &#123; <span class="comment">// 不能购买超出购物清单指定数量的物品</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nxtNeeds.<span class="built_in">emplace_back</span>(curNeeds[i] - curSpecial[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nxtNeeds.<span class="built_in">size</span>() == n) &#123; <span class="comment">// 大礼包可以购买</span></span><br><span class="line">                    minPrice = <span class="built_in">min</span>(minPrice, <span class="built_in">dfs</span>(price, special, nxtNeeds, filterSpecial, n) + specialPrice);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[curNeeds] = minPrice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[curNeeds];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><span style="color:red">△查看之后发现自己上面的那种方法还是会出现重复计算的情况，没有去应用到<strong>记忆化</strong>的目的，还是再跟着思路去敲一遍。</span></p><p><span style="color:blue"><strong>稍微简化了一下题解的记忆化深搜：</strong></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;vector&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; memo; <span class="comment">//记忆化数组，记录下对应购买情况下的价格，防止重复计算</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dfs记忆化递归</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter = <span class="built_in">RemovePackages</span>(price, special, needs);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, filter, needs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">RemovePackages</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs) &#123;</span><br><span class="line">        <span class="comment">//排除掉收益不如单买的special</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; special.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; special[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                temp += price[j]*special[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; special[i].<span class="built_in">back</span>()) &#123;</span><br><span class="line">                filter.<span class="built_in">push_back</span>(special[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; filter, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!memo.<span class="built_in">count</span>(needs))&#123;</span><br><span class="line">            <span class="keyword">int</span> minPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                minPrice+=needs[i]*price[i]; <span class="comment">//△全买情况</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filter.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">bool</span> succ = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (needs[j] &lt; filter[i][j]) &#123;</span><br><span class="line">                        succ = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!succ) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; needs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                        needs[j] -= filter[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                minPrice = <span class="built_in">min</span>(minPrice,<span class="built_in">dfs</span>(price, filter, needs)+filter[i].<span class="built_in">back</span>());</span><br><span class="line">                <span class="comment">//加回之前减去的package</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>()<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                    needs[j] += filter[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[needs]=minPrice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo.<span class="built_in">count</span>(needs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后也算优化到比较好的情况：</p><p><img src="/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/image-20211024123941326.png" alt="image-20211024123941326"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET框架：Async和await，ETVoid与ETTask</title>
      <link href="/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/"/>
      <url>/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    看ET框架时发现其广泛使用了ETVoid、ETTask的异步处理方式，同时也有段时间没复习await/async的有关内容了，所以也趁这个机会重新看一看。</p><ul><li>参考资料</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4.1ETTask:</span><br><span class="line">https://www.yuque.com/et-xd/docs/wyr682</span><br><span class="line">ET篇：ETVoid和void，ETTask和Task的区别与使用时机:</span><br><span class="line">https://www.lfzxb.top/et-ettask-etvoid/</span><br><span class="line">C# async 和 await 理解：</span><br><span class="line">https://blog.csdn.net/a462533587/article/details/82261468</span><br><span class="line">字母哥：【ET框架课程】08-异步编程与ETTask的使用</span><br><span class="line">https://www.bilibili.com/video/BV1sV411J7wJ?spm_id_from=333.999.0.0</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ET方面：<ul><li>ET框架是单线程逻辑，ETTask是一个轻量级单线程的Task，相比Task性能更强，本质上可以说是协程</li><li>ETTask就是把回调改成同步的写法，具体是单线程回调还是多线程回调都与ETTask无关</li><li>ETVoid是代替async void ，意思是新开一个<span style="color:red">协程</span></li><li>ETTask的Coroutine方法是为了无GC，ETTask必须<strong>await或者调用coroutine</strong>才能回收重用ETTaskCompletionSource</li></ul></li><li>await/task方面：<ul><li>Task本身与多线程无关，而Task.Run()等创建函数中则会将线程池中的线程分配给创建出来的Task</li><li>await本身与多线程无关，只是会在async函数中根据await切分为几段，做成一个状态机，将其中的每一段都用一个task来分割，在这个task.Complete被执行的时候将状态机.next()方法压入到同步上下文中，最后调用状态机.Next()执行await之后的流程。</li></ul></li></ul><h3 id="await和async"><a href="#await和async" class="headerlink" title="await和async"></a>await和async</h3><p>首先以一个代码例子来作为切入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace asyncTest</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Test();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static async void Test()</span><br><span class="line">        &#123;</span><br><span class="line">            //MARKER:这里创建了一个新的状态机来划分await</span><br><span class="line">            Console.WriteLine(&quot;main:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            await Method4(); //这里做了第一次分割，下一行会用新的task执行</span><br><span class="line">            Method1(); </span><br><span class="line">            //开启一个新的Task</span><br><span class="line">            Task.Run(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;new task:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            &#125;);</span><br><span class="line">            Method2();</span><br><span class="line">            await Method1(); //同理</span><br><span class="line">            Method3();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static async Task Method1()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;method 1:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            await Task.Run(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot; Method 1&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; 10; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;After-------&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static async Task Method4()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;method 4:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            await Task.Run(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot; Method 4&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public static void Method2()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Method2:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            for (int i = 0; i &lt; 30; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot; Method 2&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void Method3()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Method3:&quot; + AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            for (int i = 0; i &lt; 30; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot; Method 3&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到的结果为：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211023143024534.png" alt="image-20211023143024534"></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211023143130372.png" alt="image-20211023143130372"></p><p>我们可以来捋一捋发生的情况：</p><ul><li>主线程的线程id为14452，而在等待第一次await结束前的Method4()函数也同时在主线程中执行</li><li>之后的Method1()、Method2()、await Method1() 则被划分到了新的Task内执行，因此三者的线程ID都为新的随机分配的ID，而Task.Run()作为Task创建函数则在创建时根据线程池给task分配了线程ID</li><li>最后的Method3()原因与第二点相同，其被划分到了新的Task内执行，因此其线程ID为新的随机分配的ID</li></ul><h2 id="ETVoid与ETTask"><a href="#ETVoid与ETTask" class="headerlink" title="ETVoid与ETTask"></a>ETVoid与ETTask</h2><p><span style="color:red">其实这点在烟雨大佬的博客中已经写得比较详细了，我主要是在基础上加上一些理解。</span></p><p>备用链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C# Task的GetAwaiter和ConfigureAwait：</span><br><span class="line">https://www.cnblogs.com/majiang/p/7908441.html</span><br></pre></td></tr></table></figure><p>同样以一个代码例子作为切入点（A*寻路算法的测试部分截取）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//测试函数</span><br><span class="line">public static async ETTask NodeGOHandle(this GridComponent self, NodeItem node)</span><br><span class="line">&#123;</span><br><span class="line">    //mapHolder中找到对应GO</span><br><span class="line">    GameObject go = self.GetNodeGO(node);</span><br><span class="line"></span><br><span class="line">    go.transform.Translate(go.transform.InverseTransformDirection(0,0,2));//稍微前移</span><br><span class="line">    Debug.Log($&quot;wait for x:&#123;node.x&#125;,y:&#123;node.y&#125;&quot;);</span><br><span class="line">    //await TimerComponent.Instance.WaitAsync(2000);</span><br><span class="line">    await self.test();</span><br><span class="line">    Debug.Log($&quot;finish for x:&#123;node.x&#125;,y:&#123;node.y&#125;&quot;);</span><br><span class="line">    go.transform.Translate(go.transform.InverseTransformDirection(0,0,-2));//稍微前移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static async ETTask test(this GridComponent self)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 100; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;Test&quot;+i);</span><br><span class="line">        await TimerComponent.Instance.WaitAsync(100);</span><br><span class="line">    &#125;</span><br><span class="line">    await ETTask.CompletedTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据生成找到的路径生成具体的路径展示</span><br><span class="line">public static void GeneratePath(this GridComponent self,NodeItem startNode,NodeItem endNode)</span><br><span class="line">&#123;</span><br><span class="line">    NodeItem curNode = endNode;</span><br><span class="line">    List&lt;NodeItem&gt; nodes = new List&lt;NodeItem&gt;();</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (curNode != startNode)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log($&quot;count:&#123;++count&#125;&quot;);</span><br><span class="line">        if(count==1) self.NodeGOHandle(curNode).Coroutine();</span><br><span class="line">        // nodes.Add(curNode);</span><br><span class="line">        curNode = curNode.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nodes.Reverse();</span><br><span class="line">    self.SetPath(nodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放上输出的结果：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211027132856582.png" alt="image-20211027132856582"></p><p>现在我们来逐步分析：</p><ul><li>调用GeneratePath时，首先输出count:1，然后进入到self.NodeGoHandle(curNode)的异步函数中</li><li>顺序执行NodeGOHandle中await前的部分函数，输出wait for……，进入到self.test()函数</li><li>顺序执行self.test()函数，输出Test0，此时碰到waitAsync(100)，因为waitAsync为异步函数且具有阻塞情况，此时会执行外面将要执行的函数</li></ul><p><span style="color:red">△为什么前面的NodeGoHandle和test都进行了顺序执行，而最后test则返回到原调用函数的后续部分呢？</span></p><ul><li>如果一个异步函数内部仅有await ETTask.CompletedTask或者其嵌套await的函数里面仅有await ETTask.CompletedTask，可以单纯看做一个同步函数。在这种情况下无论是.Coroutine()还是await都与同步函数调用没有区别</li><li>而在例子里，async异步函数test()中调用了waitAsync()，其是阻塞的<span style="color:blue">（对于test()来说）</span>，<span style="color:red">因此会返回到原调用函数的后续部分继续执行 且 等待其任务执行完毕后压入test()函数中的后续部分</span></li></ul><h3 id="异同点："><a href="#异同点：" class="headerlink" title="异同点："></a>异同点：</h3><ul><li><p>共同点</p><ul><li>都具有async修饰符，即都代表了异步函数</li></ul></li><li><p>不同点</p><ul><li>ETTask可以有返回值(&lt;T&gt;作为泛型即可)；可以等待返回结果(具有getAwaiter以及实现awaiter对应接口)；可以通过.Coroutine()执行无需等待返回的异步，也可以通过await执行需要等待异步返回才能继续的情况</li><li>ETVoid不能有返回值，不可以等待返回结果(即不能用await)，也无法等待自身内部任务完成后再执行下面的语句</li></ul></li></ul><h3 id="使用情况："><a href="#使用情况：" class="headerlink" title="使用情况："></a>使用情况：</h3><ul><li>ETTask<ul><li>通常用于ET的EventSystem中的事件函数，同时也用于UI创建的异步函数(ETTask&lt;UI&gt;)，其本身可以通过返回值返回异步创建后的ui</li></ul></li><li>ETVoid<ul><li>通常用于ET中的网络交互的框架，因为基本不可能存在await服务器消息的情况（如果服务器崩了那客户端也会直接卡死），具体可以看C/S中的一些处理网络信息的handler</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> Unity </tag>
            
            <tag> 框架 </tag>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 492 构造矩形</title>
      <link href="/2021/10/23/Leetcode-492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/"/>
      <url>/2021/10/23/Leetcode-492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="492-构造矩形"><a href="#492-构造矩形" class="headerlink" title="492. 构造矩形"></a><a href="https://leetcode-cn.com/problems/construct-the-rectangle/">492. 构造矩形</a></h2><p><img src="/2021/10/23/Leetcode-492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/image-20211023102717777.png" alt="image-20211023102717777"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    一道非常简单的题目，直接将面积开平方向上取整以后从下往上判断是否符合要求，符合则break即可。</p><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">constructRectangle</span><span class="params">(<span class="keyword">int</span> area)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从sqrt(area)开始计算</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(area));</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;=area;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(area%i==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(area/i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 229.求众数 II</title>
      <link href="/2021/10/22/Leetcode-229-%E6%B1%82%E4%BC%97%E6%95%B0-II/"/>
      <url>/2021/10/22/Leetcode-229-%E6%B1%82%E4%BC%97%E6%95%B0-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="229-求众数-II"><a href="#229-求众数-II" class="headerlink" title="229. 求众数 II"></a><a href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a></h2><p><img src="/2021/10/22/Leetcode-229-%E6%B1%82%E4%BC%97%E6%95%B0-II/image-20211022094507477.png" alt="image-20211022094507477"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ul><li>遍历计数法<ul><li>先遍历vector，用unordered_map记录下每个数出现的次数</li><li>逐个判断出现次数是否&gt;nums.size()/3，符合则加入ans中</li><li>时间复杂度为O(n),空间复杂度为O(n)</li></ul></li><li>摩尔投票法<ul><li>根据出现超过⌊ n/3 ⌋次的元素可以得出最多可能有2个这样的元素</li><li>让互不相同的三个元素互相抵消，最终会得到两个可能符合的元素</li><li>遍历计数，判断两个元素是否符合，符合则将其加入到ans中</li><li>时间复杂度为O(n),空间复杂度为O(1)</li></ul></li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//MARKER:摩尔投票法</span></span><br><span class="line">        <span class="keyword">int</span> vote1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> vote2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出可能的两个num</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vote1&gt;<span class="number">0</span> &amp;&amp; num1==num)&#123;</span><br><span class="line">                vote1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (vote2&gt;<span class="number">0</span> &amp;&amp; num2==num)&#123;</span><br><span class="line">                vote2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (vote1==<span class="number">0</span>)&#123;</span><br><span class="line">                num1=num;</span><br><span class="line">                vote1=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (vote2==<span class="number">0</span>)&#123;</span><br><span class="line">                num2=num;</span><br><span class="line">                vote2=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                vote1--;</span><br><span class="line">                vote2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==num1) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num==num2) count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (count1&gt;nums.<span class="built_in">size</span>()/<span class="number">3</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count2&gt;nums.<span class="built_in">size</span>()/<span class="number">3</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ET6.0的对战游戏demo</title>
      <link href="/2021/10/21/%E5%9F%BA%E4%BA%8EET6-0%E7%9A%84%E5%AF%B9%E6%88%98%E6%B8%B8%E6%88%8Fdemo/"/>
      <url>/2021/10/21/%E5%9F%BA%E4%BA%8EET6-0%E7%9A%84%E5%AF%B9%E6%88%98%E6%B8%B8%E6%88%8Fdemo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    先开个坑，关系到毕业设计的实现。</p><h2 id="暂定的网络同步思路"><a href="#暂定的网络同步思路" class="headerlink" title="暂定的网络同步思路"></a>暂定的网络同步思路</h2><ul><li>状态同步方式<ul><li>位置方面：客户端Unit每隔一段时间将自身的位置、朝向、速度发送给服务器，服务器计算出最终结果后进行广播操作，所有Units对位置结果进行插值处理</li><li>状态方面（技能、动画等）：利用一个状态包来进行转发广播操作，与位置包分开处理</li></ul></li></ul><h2 id="目前进度："><a href="#目前进度：" class="headerlink" title="目前进度："></a>目前进度：</h2><ul><li>对UI实现了一定的改进，加入了UI栈思路</li><li>采用ET框架实现A*寻路算法，将具体寻路功能拆分为在zoneScene中全局的A*地图GridComponent组件与移动控制组件ControlComponent</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 框架 </tag>
            
            <tag> ET </tag>
            
            <tag> demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 66.加一</title>
      <link href="/2021/10/21/Leetcode-66-%E5%8A%A0%E4%B8%80/"/>
      <url>/2021/10/21/Leetcode-66-%E5%8A%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a href="https://leetcode-cn.com/problems/plus-one/">66. 加一</a></h2><p><img src="/2021/10/21/Leetcode-66-%E5%8A%A0%E4%B8%80/image-20211021100630610.png" alt="image-20211021100630610"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​        方法1：直接从最后一位开始模拟整个加法的过程即可</p><p>​        方法2：逆序查找第一个不为9的数加1，其余都设为0即可<span style="color:red">(感觉更简单)</span></p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans=digits;</span><br><span class="line">        <span class="keyword">int</span> index=ans.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> add=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(add==<span class="number">1</span> &amp;&amp; index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            ans[index]+=add;</span><br><span class="line">            add=ans[index]/<span class="number">10</span>;</span><br><span class="line">            ans[index--]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑最终有进位情况</span></span><br><span class="line">        <span class="keyword">if</span> (add==<span class="number">1</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>(),<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 453: 最小操作次数使数组元素相等</title>
      <link href="/2021/10/20/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/"/>
      <url>/2021/10/20/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/10/20/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/image-20211020135000199.png" alt="image-20211020135000199"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>考虑到n-1个元素增加1，对于这n-1个元素来说差值的情况是不会变得，因此可以看做是<span style="color:red">这n-1个元素并没有变而是将最后1个元素减1的情况</span>，这时解题的代码就非常明确了。</p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将n-1个元素增加1相当于让1个元素减1</span></span><br><span class="line">        <span class="keyword">int</span> min=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> temp:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp&lt;min)&#123;</span><br><span class="line">                min=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> temp:nums)&#123;</span><br><span class="line">            ans+=temp-min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#:值类型和引用类型的具体类型和区别</title>
      <link href="/2021/10/19/C-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/10/19/C-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先放上一个图表示值类型和引用类型的所有数据类型：</p><p><img src="https://raw.githubusercontent.com/petertan123/cloudimg/master/img/2009020510331710.jpg" alt="img"></p><p>（1）最根本的一个区别：<span style="color:red"><strong>值类型的变量直接存储数据，将数据存储在栈中。而引用类型的变量持有的是数据的引用，数据存储在堆中（对其的实例引用存储在栈中）（面试碰到的话后续还可以引申栈和堆的一些区别，比如GC标记压缩的垃圾回收方法等等）。</strong></span></p><p>（2）<span style="color:red">同时对于struct（值类型）和class（引用类型）来说，struct和class都可以实现接口（函数），但是struct在赋值时（如struct s1=s2）会直接创建s2的副本并赋值给s1，而对于class赋值时（class c1=c2）时会将两个类指向同一个引用，后续操作会同时改变同一个堆中实例。</span></p><p>（3）<span style="color:red">所有的值类型都继承System.ValueType，引用类型继承自System.Object。（其实引用类型和值类型都继承自System.Object类，不同的是，几乎所有的引用类型都直接从System.Object继承，而值类型则继承其子类，即直接继承System.ValueType）</span></p><p><span style="color:blue">△ 如果一个值类型被声明在一个方法体外并且在一个引用类型中，那它就会在堆上进行分配。</span></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> C# </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode记录：211 添加与搜索单词-数据结构设计</title>
      <link href="/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h2><p><img src="/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20211019103409399.png" alt="image-20211019103409399"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    比较典型的一道前缀树的题目，注意在构建前缀树的过程中不要粗心大意即可，前缀树的定义可以参考<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/">208. 实现 Trie (前缀树) 的官方题解</a>。</p><p><span style="color:red">1.用一个is_end来记录是否到达结尾，2.结点向下的多叉树子结点用vector&lt;TrieNode *&gt;来记录</span></p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TrieNode *&gt; childs;</span><br><span class="line">    <span class="keyword">bool</span> is_end;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>(<span class="keyword">bool</span> _is_end=<span class="literal">false</span>)&#123;</span><br><span class="line">        childs=vector&lt;TrieNode *&gt;(<span class="number">26</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        is_end=_is_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        head_node=<span class="keyword">new</span> <span class="built_in">TrieNode</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于前缀树的word增加</span></span><br><span class="line">        <span class="keyword">int</span> length=word.<span class="built_in">length</span>();</span><br><span class="line">        TrieNode *temp=head_node;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch=word[i];</span><br><span class="line">            <span class="keyword">int</span> index=ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;childs[index]==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                temp-&gt;childs[index]=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp-&gt;childs[index];</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;is_end=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于前缀树的word搜索</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word,<span class="number">0</span>,head_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word,<span class="keyword">int</span> index,TrieNode* node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//循环跳出条件</span></span><br><span class="line">        <span class="keyword">if</span> (index==word.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;is_end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> ch=word[index];</span><br><span class="line">        <span class="keyword">if</span> (ch!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index_=ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            TrieNode* temp=node-&gt;childs[index_];</span><br><span class="line">            <span class="keyword">if</span>(temp!=<span class="literal">nullptr</span>&amp;&amp;<span class="built_in">search</span>(word,index+<span class="number">1</span>,temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                TrieNode* temp=node-&gt;childs[i];</span><br><span class="line">                <span class="keyword">if</span>(temp!=<span class="literal">nullptr</span>&amp;&amp;<span class="built_in">search</span>(word,index+<span class="number">1</span>,temp))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *head_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session和Cookie的区别、联系</title>
      <link href="/2021/10/18/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB/"/>
      <url>/2021/10/18/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考：https://www.cnblogs.com/ITCodeMonkey/p/7874343.html</span><br></pre></td></tr></table></figure><p>有时间回来补充一下</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity服务器--什么是RPC?</title>
      <link href="/2021/10/18/Unity%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%BB%80%E4%B9%88%E6%98%AFRPC/"/>
      <url>/2021/10/18/Unity%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%BB%80%E4%B9%88%E6%98%AFRPC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>在学习ET框架中Client与Server交互时的message信息中碰到的RpcId，之前没有太了解，固趁这个机会了解以下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">知乎参考：https://zhuanlan.zhihu.com/p/76727302</span><br></pre></td></tr></table></figure><p>此篇可能会慢慢更新。。。</p><h2 id="RPC-调用分类"><a href="#RPC-调用分类" class="headerlink" title="RPC 调用分类"></a>RPC 调用分类</h2><p>RPC调用分为以下两种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 同步调用  </span><br><span class="line">   客户方等待调用执行完成并返回结果。 </span><br><span class="line">2. 异步调用  --c2s_new,s2c_new,sreq_new</span><br><span class="line">   客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。 </span><br><span class="line">   若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 网络 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode记录: 476 数字的补数</title>
      <link href="/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/"/>
      <url>/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/image-20211018101215331.png" alt="image-20211018101215331"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题的解题思路其实比较清晰，就是求二进制然后取反重新计算新数，可以直接在求解二进制的过程中直接得出最终的结果。</p><p>​    以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先求出其二进制数</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123; <span class="comment">//这里因为题目要求其实num/2!=0也可以</span></span><br><span class="line">            <span class="keyword">int</span> temp=(num%<span class="number">2</span>+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">            result+=<span class="built_in">pow</span>(<span class="number">2</span>,count++)*temp;</span><br><span class="line">            num/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        <span style="color:red">单看这个可能问题已经解决了，但是题目中想让我们实现的位运算其实并没有做到，在看到一些大佬的题解后，其实还有更简单直接的方法。</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp = num, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            c =  (c &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num ^ c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        <span style="color:blue">这里的思路是：求出temp有多少位以后利用得出一个全1的c，再通过num^c（异或）就能得出最终结果，更符合题目的要求。</span></p><p>​    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++运算符优先级参考：https://www.sojson.com/operation/cxx.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET6.0框架初步</title>
      <link href="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/"/>
      <url>/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    因为学校毕设选题选择了Unity游戏开发相关的内容，并且ECS一直是我比较想去了解的方面，所以选择了ET作为毕设游戏所采用的框架。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考：1.&lt;&lt;ET6.0使用手册&gt;&gt; https://www.lfzxb.top/et6-manual/</span><br><span class="line"> 2.&lt;&lt;ET6.0学习笔记&gt;&gt; https://www.lfzxb.top/et6.0-study/</span><br></pre></td></tr></table></figure><h2 id="ECS相对于传统面向对象模式OOP"><a href="#ECS相对于传统面向对象模式OOP" class="headerlink" title="ECS相对于传统面向对象模式OOP"></a>ECS相对于传统面向对象模式OOP</h2><p>​    以前曾开发过ARPG的demo和2D横版过关的demo，所采用的都是传统的面向对象的思路和方法。采用类继承的方式，在前期的开发过程中还是比较轻松，但是在后期的基类逐渐冗余后，也能感觉到面向对象的一些的缺点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考：https://www.cnblogs.com/egametang/p/7511589.html</span><br></pre></td></tr></table></figure><p>​    在看了上面这篇文章以后，更是对一些面向对象的优缺点有了更深的体会，浓缩为以下两点。</p><h3 id="OOP数据结构耦合性强"><a href="#OOP数据结构耦合性强" class="headerlink" title="OOP数据结构耦合性强"></a>OOP数据结构耦合性强</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一旦父类中增加或删除某个字段，可能要影响到所有子类，影响到所有子类相关的逻辑。</span><br></pre></td></tr></table></figure><h3 id="OOP难以热插拔"><a href="#OOP难以热插拔" class="headerlink" title="OOP难以热插拔"></a>OOP难以热插拔</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">继承结构无法在运行时动态增加或删除字段，比如有时会需要取消player的某个功能，但这时只能进行禁用，而不能把功能完完全全的剥离出去。</span><br></pre></td></tr></table></figure><p>​    这点在lua中其实得到了很好的解决，在实习阶段我也是基本用的lua来进行minigame的开发，相对于C#来说，Lua语言其实可以选择抛弃传统的纯粹继承的方式，采用类似于<span style="color:red">单例类+require</span>的方式来进行逻辑开发，而实际上在除游戏实际角色、技能、状态机之外的情况下我也确实采用了这种方法来编写（登入，选服，匹配等等）。可以说这段经历对我来说是一段新的体验，也更加深了我想要去了解ECS组件式开发的兴趣。</p><p>​    <span style="color:blue">ET框架作为一个Unity的双端框架，采用了ECS的组件式概念来进行设计，其ECS的概念也曾经应用于热门的商业游戏守望先锋等，即实体(Entity)-组件(Component)-系统(system),其将Entity中所具有的Component抽象出来，遵循组合大于继承的原则，每位实体都通过一个或多个组件ID连接多个功能组件,避免了一些不必要的开销。</span></p><p>​    <span style="color:red"><strong>这篇文章仅用于记录下ECS学习过程中的一些心得体会，主要还是对烟雨大佬视频的一些自身收获。</strong></span></p><h2 id="环境配置和demo运行"><a href="#环境配置和demo运行" class="headerlink" title="环境配置和demo运行"></a>环境配置和demo运行</h2><p><span style="color:red"><strong>在ET/Book中已经有各种ET框架指南，本篇主要是记录一些具体过程。</strong></span></p><p>先放一下工程中整体的目录截图：</p><p>分为两个主要的sln，Unity和Server：</p><p>Unity：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017140008420.png" alt="image-20211017140008420"></p><p>Server：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017140040074.png" alt="image-20211017140040074"></p><p><strong>△Unity和Server中所有的project都要进行build的操作</strong></p><p>服务器：</p><p>​    需要安装MongoDB数据库（对于ET的初始demo来说不需要，因为其将数据库交互部分注释了）</p><p>​    需要安装Net Core 或Net Framework（我用的是Net5.0）</p><p>​    在build后启动Server.App即可开启服务器</p><p>客户端：</p><p>​    在UnityHub中打开对应项目工程后，首先在Assets/Scenes中找到启动的Init场景</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017143237959.png" alt="image-20211017143237959"></p><p>运行后即可输入账号密码进入游戏场景</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017143405871.png" alt="image-20211017143405871"></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017143434676.png" alt="image-20211017143434676"></p><h2 id="ET框架结构总览："><a href="#ET框架结构总览：" class="headerlink" title="ET框架结构总览："></a>ET框架结构总览：</h2><h3 id="Unity-sln项目结构："><a href="#Unity-sln项目结构：" class="headerlink" title="Unity.sln项目结构："></a>Unity.sln项目结构：</h3><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211107102409848.png" alt="image-20211107102409848"></p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211108135131078.png" alt="image-20211108135131078"></p><ul><li>Hotfix对应Model中Component的System实现，如demo中的XunLuoPathComponentSystem，为逻辑层方法</li><li>HotfixView对应ModelView中Component的具体实现，如demo中的各种UIComponentSystem，为表现层方法</li><li>Model为游戏中一些数据Component的存储目录，如demo中的MoveComponent，为逻辑层数据</li><li>ModelView为游戏中一些外部View展示Component的存储目录，如demo中的各种UI界面Component，也包括GameObject、Animator等，为表现层数据</li></ul><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/1600236623-436564-image.png" alt="img"></p><h2 id="导表部分"><a href="#导表部分" class="headerlink" title="导表部分"></a>导表部分</h2><p>先上一张导表方法图：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/ET%E5%AF%BC%E8%A1%A8%E6%96%B9%E6%B3%95.png" alt="ET导表方法"></p><p><span style="color:red">与烟雨大佬视频中的不同，现在的ET版本中导表工具已经由之前的Assets/Editor/ExcelExporterEditor/ExcelExporterEditor.cs迁移到Server/Model/ExcelExporter/ExcelExporter.cs，而在Unity中的Editor拓展也已经移除了。</span></p><h3 id="过程理解："><a href="#过程理解：" class="headerlink" title="过程理解："></a>过程理解：</h3><h4 id="导出JSON-暂存信息-："><a href="#导出JSON-暂存信息-：" class="headerlink" title="导出JSON(暂存信息)："></a>导出JSON(暂存信息)：</h4><p>让我们先打开这个ExcelExporter.cs，其在调用时已经被包含在<span style="color:red">ET/Bin/Server.dll</span>的动态链接库中，因此我们当前的目录其实就是Bin，接下来看下图中的Excel表，Json表等存放的路径就非常清晰了。</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017153220996.png" alt="image-20211017153220996"></p><p>对于Excel的读取采用了OfficeOpenXml中的ExcelPackage类来进行处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C#excelpackage读写Excel文件：https://www.cnblogs.com/sange0708/p/15005370.html</span><br></pre></td></tr></table></figure><p>先来看一下在demo中给出的AIConfig.xlsx的表格例子：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017162205295.png" alt="image-20211017162205295"></p><p>对应在ExcelPackage读取后的JSON导出代码：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017162408170.png" alt="image-20211017162408170"></p><p>可以得知对应Excel中<span style="color:blue">第二行为是否不导出为JSON，第三行的内容为变量描述、第四行为变量名、第五行为导出类型</span></p><p><span style="color:red">#作为中断读取的标志，有#的变量都不会导出为Json</span></p><p>之后是对具体变量内容的读取和写入：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017163109993.png" alt="image-20211017163109993"></p><p>根据之前读取到的头文件信息，从Excel表中的第六行开始进行读取，而后在StringBuffer中写入对应的json信息。</p><h4 id="导出类-用于反序列化-："><a href="#导出类-用于反序列化-：" class="headerlink" title="导出类(用于反序列化)："></a>导出类(用于反序列化)：</h4><p>其对<span style="color:red">headInfo</span>的读取与导出JSON是相同的，关键点在于对于class读取类的导出，用到了在Export中读取到的template.txt，它其实是一个类class的代码模板(继承自ProtoObject)，导出类做的主要工作就是将类名、域名等的信息套到这个模板代码中，并生成对应的cs文件。</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017164315689.png" alt="image-20211017164315689"></p><h4 id="根据生成的类，动态编译把JSON转译成protobuf："><a href="#根据生成的类，动态编译把JSON转译成protobuf：" class="headerlink" title="根据生成的类，动态编译把JSON转译成protobuf："></a>根据生成的类，动态编译把JSON转译成protobuf：</h4><p>比起之前版本的ET，新版本的ET是通过<strong>protobuf</strong>来作为序列化数据的。因此最关键的一步就是转译，具体的代码过程就不贴出来了。</p><h3 id="使用例子："><a href="#使用例子：" class="headerlink" title="使用例子："></a>使用例子：</h3><h4 id="导表："><a href="#导表：" class="headerlink" title="导表："></a>导表：</h4><p>​    在cmd中cd到对应的<strong>根目录/Bin</strong>文件夹中，而后执行dotnet Server.dll –AppType=ExcelExporter即可，导出的表格会分别存放在./Client/Json文件夹和./Server/Json文件夹中。</p><p>​    <img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017164636195.png" alt="image-20211017164636195"></p><h4 id="脚本使用："><a href="#脚本使用：" class="headerlink" title="脚本使用："></a>脚本使用：</h4><p>​    在具体CS脚本中的通过<span style="color:red">表格名+Category</span>的单例类就可以获取对应的表格信息（key值对应ID）。</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017170048269.png" alt="image-20211017170048269"></p><h2 id="Proto生成CS与拓展"><a href="#Proto生成CS与拓展" class="headerlink" title="Proto生成CS与拓展"></a>Proto生成CS与拓展</h2><p><span style="color:red">ET框架采用了分布式服务器的方式。</span></p><p>同样列出上方的一张图：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211018155809927.png" alt="image-20211018155809927"></p><p>我们先来找到ET/Model/Proto2CS/Program.cs文件，与导表的cs文件相同，其在具体使用的时候同样是被打成了dll放在了ET/Bin文件夹下，因此文件的根目录同样是Bin文件夹。</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211018160111894.png" alt="image-20211018160111894"></p><p>​        对于客户端和服务器的生成路径如上图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">之前在实习阶段也对proto的定义有了一些理解，但是在实际看到ET框架内的proto的时候还是和之前所认知的有一些差别，</span><br><span class="line">之前的框架是基于lua脚本因此对proto来说无需转换到CS，而如今ET框架的热更等是面向ILRuntime的。</span><br></pre></td></tr></table></figure><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211018163131915.png" alt="image-20211018163131915"></p><p>看到具体的Proto2CS的生成函数：</p><p>1.InnerMessage是服务器内部的协议生成，可能是用于分布式的多服务器沟通</p><p>2.OuterMessage则是针对于C2S和S2C之间的交互了</p><p><span style="color:red">ET客户端与服务端的交互总览：（取自烟雨大佬的视频）</span></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020153521006.png" alt="image-20211020153521006"></p><p>网关服：用于做消息转发，与Actor信息配套</p><p>验证服：账号的登入，注册</p><p>战斗服：寻路、战斗信息</p><p>1.<span style="color:red"><strong>Domain指这个entity属于哪个scene，一个进程可以容纳多个scene</strong></span></p><p>2.<span style="color:red">对于客户端和服务端来说，其最大的scene都为Game.scene，在客户端中，目前通过Game.scene来作为全局通用的Component的存储(比如UIComponent、UIEventComponent等)，而对于服务器来说一个功能对应ET中的一个scene,具体的配置方法在Excel/StartSceneConfig中。</span></p><p>3.<span style="color:red">每个客户端的Game.scene在服务端会在随机分配的gate中生成一个key，后续客户端可以通过这个key连接到服务端。</span></p><h3 id="使用例子：-1"><a href="#使用例子：-1" class="headerlink" title="使用例子："></a>使用例子：</h3><h4 id="脚本使用：-1"><a href="#脚本使用：-1" class="headerlink" title="脚本使用："></a>脚本使用：</h4><p><span style="color:red">客户端调用：</span></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211018171843943.png" alt="image-20211018171843943"></p><p><span style="color:red">服务器处理：</span></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211019135845225.png" alt="image-20211019135845225"></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211019141256527.png" alt="image-20211019141256527"></p><p>△可以看到在服务器的Handler中有分布式服务器之间的交互处理</p><h3 id="实际使用过程："><a href="#实际使用过程：" class="headerlink" title="实际使用过程："></a>实际使用过程：</h3><ul><li>定义proto文件</li><li>生成C#代码</li><li>编写双端收发逻辑代码</li></ul><h4 id="在OuterMessage-proto中添加新的协议"><a href="#在OuterMessage-proto中添加新的协议" class="headerlink" title="在OuterMessage.proto中添加新的协议"></a>在OuterMessage.proto中添加新的协议</h4><p>这里没有采用actor的方式，添加了三个协议</p><ul><li>C2R_TestSend</li><li>C2R_TestCall</li><li>R2C_TestResponse</li></ul><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020234524827.png" alt="image-20211020234524827"></p><h4 id="在客户端的LoginHelper的异步Login中添加相应session-Call和Send："><a href="#在客户端的LoginHelper的异步Login中添加相应session-Call和Send：" class="headerlink" title="在客户端的LoginHelper的异步Login中添加相应session.Call和Send："></a>在客户端的LoginHelper的异步Login中添加相应session.Call和Send：</h4><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020154921586.png" alt="image-20211020154921586"></p><h4 id="在服务器的Hotfix-Demo中加入对应的CallHandler和SendHandler"><a href="#在服务器的Hotfix-Demo中加入对应的CallHandler和SendHandler" class="headerlink" title="在服务器的Hotfix/Demo中加入对应的CallHandler和SendHandler"></a>在服务器的Hotfix/Demo中加入对应的CallHandler和SendHandler</h4><ul><li>C2R_TestCallHandler</li></ul><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020234051973.png" alt="image-20211020234051973"></p><ul><li>C2R_TestSendHandler</li></ul><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020234029225.png" alt="image-20211020234029225"></p><ul><li>注意点<ul><li>Request和Response的应实现AMRpcHandler接口，而用于处理Request的则实现AMHandler接口。</li><li>在写入新的协议handler以后要对重新build Hotfix</li><li>要在对应的Handler类上打上[MessageHandler]的标签</li><li>Log.Info进行了进一步封装，其结果存放在ET/Logs目录的日志文件中</li></ul></li></ul><p>现在服务器和客户端都能输出正确回应：</p><p>server:</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020234220037.png" alt="image-20211020234220037"></p><p>client:</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020232241622.png" alt="image-20211020232241622"></p><h2 id="Actor机制"><a href="#Actor机制" class="headerlink" title="Actor机制"></a>Actor机制</h2><p>同样先放上在烟雨大佬视频的思维导图：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211021101415991.png" alt="image-20211021101415991"></p><ul><li>关键点<ul><li>Entity InstanceID是唯一的，即对应的每个居住证是唯一的，仅代表了当前所在进程以及自身Entity</li><li>Entity上挂载的MailboxComponent组件就是一种Actor，只需要知道Entity的InstanceId就可以给这个Entity发送消息</li><li>Actor模型固然方便，但是在有时我们无法知道对方的InstanceId或者对方的InstanceId进行了改变，这时候就需要ActorLocation发挥作用，Actor对象在一个进程创建时或者迁移到一个新的进程时，都需要把自己的Id跟新的InstanceId注册到Location Server上去，<span style="color:red">ActorLocationSender提供两种方法，Send跟Call，Send一个信息也需要接受者返回一个消息，只有收到返回的消息才会发送下一个消息。</span></li><li>Actor模型是<span style="color:red">纯粹的服务器消息通信机制</span>，ET客户端使用这个Actor完全是因为Gate需要对客户端消息进行转发，我们可以正好利用服务端actor模型来进行转发，所以客户端有些消息也是继承了actor的接口。</li><li>Actor和ActorLocation的一个最大的区别在于ActorLocation需要先在Location服务器中获取到Entity的真实的InstanceId，<span style="color:blue">其在LocationProxyComponentSystem.cs中体现，通过key:UnitId对应value:InstanceId</span></li></ul></li></ul><h3 id="具体例子："><a href="#具体例子：" class="headerlink" title="具体例子："></a>具体例子：</h3><p>下面是一个在进入map服后创建战斗Unit的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[ActorMessageHandler]</span><br><span class="line">public class G2M_CreateUnitHandler : AMActorRpcHandler&lt;Scene, G2M_CreateUnit, M2G_CreateUnit&gt;</span><br><span class="line">&#123;</span><br><span class="line">protected override async ETTask Run(Scene scene, G2M_CreateUnit request, M2G_CreateUnit response, Action reply)</span><br><span class="line">&#123;</span><br><span class="line">UnitComponent unitComponent = scene.GetComponent&lt;UnitComponent&gt;();</span><br><span class="line">Unit unit = Entity.CreateWithId&lt;Unit, int&gt;(unitComponent, IdGenerater.Instance.GenerateId(), 1001);</span><br><span class="line">unit.AddComponent&lt;MoveComponent&gt;();</span><br><span class="line">unit.Position = new Vector3(-10, 0, -10);</span><br><span class="line"></span><br><span class="line">NumericComponent numericComponent = unit.AddComponent&lt;NumericComponent&gt;();</span><br><span class="line">numericComponent.Set(NumericType.Speed, 6f); // 速度是6米每秒</span><br><span class="line"></span><br><span class="line">unit.AddComponent&lt;MailBoxComponent&gt;();</span><br><span class="line">await unit.AddLocation();</span><br><span class="line">unit.AddComponent&lt;UnitGateComponent, long&gt;(request.GateSessionId);</span><br><span class="line">unitComponent.Add(unit);</span><br><span class="line">response.UnitId = unit.Id;</span><br><span class="line"></span><br><span class="line">// 把自己广播给周围的人</span><br><span class="line">M2C_CreateUnits createUnits = new M2C_CreateUnits();</span><br><span class="line">createUnits.Units.Add(UnitHelper.CreateUnitInfo(unit));</span><br><span class="line">MessageHelper.Broadcast(unit, createUnits);</span><br><span class="line"></span><br><span class="line">// 把周围的人通知给自己</span><br><span class="line">createUnits.Units.Clear();</span><br><span class="line">Unit[] units = scene.GetComponent&lt;UnitComponent&gt;().GetAll();</span><br><span class="line">foreach (Unit u in units)</span><br><span class="line">&#123;</span><br><span class="line">createUnits.Units.Add(UnitHelper.CreateUnitInfo(u));</span><br><span class="line">&#125;</span><br><span class="line">//△通过GateSessionActorId向对应的unit发送消息</span><br><span class="line">MessageHelper.SendActor(unit.GetComponent&lt;UnitGateComponent&gt;().GateSessionActorId, createUnits);</span><br><span class="line"></span><br><span class="line">reply();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">    其中的MessageHelper.SendActor已经很明了了，其通过对应Unit的网关InstanceId来向对应Unit发送信息，那么对于MessageHelper呢？</span></p><p>​    查看MessageHelper源码中的Broadcast发现，其同样使用了SendActor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void Broadcast(Unit unit, IActorMessage message)</span><br><span class="line">&#123;</span><br><span class="line">    //获取在相同Scene中的所有Units(也就是同处于战斗服)</span><br><span class="line">    var units = unit.Domain.GetComponent&lt;UnitComponent&gt;().GetAll();</span><br><span class="line"></span><br><span class="line">    if (units == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foreach (Unit u in units)</span><br><span class="line">    &#123;</span><br><span class="line">        UnitGateComponent unitGateComponent = u.GetComponent&lt;UnitGateComponent&gt;();</span><br><span class="line">        SendActor(unitGateComponent.GateSessionActorId, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ET-6-0-demo中的网络交互流程："><a href="#ET-6-0-demo中的网络交互流程：" class="headerlink" title="ET 6.0 demo中的网络交互流程："></a>ET 6.0 demo中的网络交互流程：</h2><ul><li>交互流程<ul><li>客户端发送C2R_Login协议(账号密码)到服务端，服务端在大区中随机分配一个gate，并且在服务器内部向gate请求一个key，客户端可以拿着这个key连接gate，服务器将Address，网关key，网关Id回传给客户端</li><li>客户端发送G2C_LoginGate(网关key和网关Id)到服务端，服务端通过网关key获取对应的账号，同时获取Game中的PlayerComponent，创建Player的Entity并加入其中，同时返回playerId</li><li>客户端发送G2C_EnterMap到服务器，服务器在zone中找到对应的map scene后在map上创建战斗Unit<span style="color:red">（同时会向客户端发送M2C_CreateUnits令其在Game中创建Unit）</span>，并且将UnitId赋值给player.UnitId，同时将其作为返回值回传给客户端，客户端收到后在Game的unitComponent获取对应Unit并赋值给MyUnit</li></ul></li></ul><h2 id="异步处理Async和Await"><a href="#异步处理Async和Await" class="headerlink" title="异步处理Async和Await"></a>异步处理Async和Await</h2><p><span style="color:red">这部分的内容比较多，放在了一篇新的文章中。</span></p><ul><li>链接：<a href="https://songofwing.site/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/">https://songofwing.site/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/</a></li></ul><h2 id="事件系统-EventSystem"><a href="#事件系统-EventSystem" class="headerlink" title="事件系统(EventSystem)"></a>事件系统(EventSystem)</h2><h3 id="使用过程："><a href="#使用过程：" class="headerlink" title="使用过程："></a>使用过程：</h3><p>ET中的事件系统相对比较简单，其定义方式分为三个步骤：</p><ul><li><p>在EventType中定义事件结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace EventType</span><br><span class="line">&#123;</span><br><span class="line">    public struct TestEvent</span><br><span class="line">    &#123;</span><br><span class="line">        public string message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个类用于处理指定时间，泛型类型订阅的事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestEvent_Action: AEvent&lt;EventType.TestEvent&gt;</span><br><span class="line">&#123;</span><br><span class="line"> protected override async ETTask Run(EventType.TestEvent args)</span><br><span class="line">    &#123;</span><br><span class="line">        Log.Info($&quot;TestEvent事件触发了 : &#123;args.Type&#125;&quot;);</span><br><span class="line">        //虽然这个函数是async的，但是我们内部没有异步操作，就可以这样调用，相当于直接return</span><br><span class="line">await ETTask.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抛出事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Game.EventSystem.Publish(new EventType.TestEvent()&#123;Message=&quot;测试&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a>代码解析：</h3><p>​    ![ET EventSystem](ET6.0框架初步/ET EventSystem.png)</p><ul><li>在EventSystem的Add(Assembly assembly)中在程序集内获取到所有打上了Attribute的class，并在从中挑选出打了[Event]标签的class(即实现了IEvent接口的AEvent&lt;A&gt;抽象类)，并将其订阅事件结构体类型Type对应List&lt;obj&gt;()存储在AllEvents字典中<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022105434483.png" alt="image-20211022105434483"></li><li>在Publish时将所有ETTask的Run()函数加入到ListComponent.Create()创建的list中，而后调用ETTaskHelper.WaitAll(list.List);执行<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022105925399.png" alt="image-20211022105925399"></li><li>注意在WaitAll中所有的事件是异步执行的，内部通过CoroutineBlocker来阻塞未执行完的所有Task，在count==0时继续之前所有阻塞的tcs<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022110531535.png" alt="image-20211022110531535"></li></ul><p>关键点：</p><ul><li><p>ETTask重写了传统Task，将自身作为Awaiter，并通过枚举的AwaiterStatus判断是否结束。<img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/dd0f615f0d5b6fef48bbbac88276c8d.jpg" alt="dd0f615f0d5b6fef48bbbac88276c8d"></p><p>上图是可等待模式的处理，对应ETTask分别为：</p><p><strong>GetAwaiter()：</strong></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022141746640.png" alt="image-20211022141746640"></p><p><strong>IsCompleted():</strong></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022141852539.png" alt="image-20211022141852539"></p><p>​    <span style="color:red">其中的AwaiterStatus可以在SetResult()中进行更改。</span></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022142017462.png" alt="image-20211022142017462"></p></li></ul><h2 id="UI系统"><a href="#UI系统" class="headerlink" title="UI系统"></a>UI系统</h2><p>还是很想吐槽一下ET的UI系统实在是有点过于简洁了，其UI生命周期中的事件只有OnCreate和OnRemove两种，后续还需要继续拓展。</p><ul><li>通过UIComponent组件类管理Scene上的UI<ul><li>通过.Create(this UIComponent self,string uiType)函数进行创建，同时在创建时会执行UIEvents字典中通过自定义标签导入进来的onCreate()函数，<span style="color:red">其外部通过UIHelper.Create(Scene scene,string uiType)在指定scene中创建</span></li><li>通过.Remove(this UIComponent self,string uiType)函数进行移除，同时在创建时会执行UIEvents字典中通过自定义标签导入进来的onRemove()函数，<span style="color:red">其外部通过UIHelper.Create(Scene scene,string uiType)在指定scene中移除</span></li></ul></li><li>通过ReferenceCollector可以获取UIPrefab上面的引用，可以直接在prefab里加入RC方便后续获取子物体<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022153257071.png" alt="image-20211022153257071"></li></ul><hr><p><span style="color:red">基于ET框架的新UI框架正在设计中。。。。，设计全部完成后会放上新流程图</span></p><ul><li>将原先的mid、hidden、low等变为普通GO，用代码设定sortingOrder</li><li>加入UICamera方便管理，代码设定UICamera</li><li>新增onShow(),onHide()</li></ul><p>10/24更新：</p><ul><li>新增UI栈</li><li>UIComponent、UIComponentSystem、UIHelper代码拓展</li></ul><p>10/25更新：</p><ul><li>引入新的UIStatesComponent组件，记录UIForm(UI类型)，isShow(是否展示中)等信息</li><li>处理UI栈与UI字典的关系</li></ul><p>10/26更新：</p><ul><li>加入UI栈中UI对应次数的字典，处理同一UI多次入栈的情况</li></ul><h2 id="场景管理"><a href="#场景管理" class="headerlink" title="场景管理"></a>场景管理</h2><p>ET场景切换整体思路和代码也不多，后续可能要结合Loading进度条拓展</p><p>先放上流程图：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/ET%EF%BC%9AScene.drawio.png" alt="ET：Scene.drawio"></p><p><span style="color:red">针对其加载回调做了一些拓展处理：</span></p><ul><li>在ChangeSceneAsync完成时会进行EventType.ChangeSceneFinish事件广播处理，广播内容为sceneName和zoneScene</li><li>在ChangeSceneFinish_SceneCallBack的事件处理函数中根据场景名进行组件添加处理<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211028001327798.png" alt="image-20211028001327798"></li></ul><h2 id="ECS组件系统"><a href="#ECS组件系统" class="headerlink" title="ECS组件系统"></a>ECS组件系统</h2><h3 id="demo介绍："><a href="#demo介绍：" class="headerlink" title="demo介绍："></a>demo介绍：</h3>]]></content>
      
      
      <categories>
          
          <category> Unity框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> Unity </tag>
            
            <tag> 框架 </tag>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-first-blog</title>
      <link href="/2021/10/16/my-first-blog/"/>
      <url>/2021/10/16/my-first-blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>测试—Test</p><p><span style="color:red">新的开始</span></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
