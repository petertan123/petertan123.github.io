<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode: 240 搜索二维矩阵 II</title>
      <link href="/2021/10/25/Leetcode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/"/>
      <url>/2021/10/25/Leetcode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><p><img src="/2021/10/25/Leetcode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/image-20211025100921484.png" alt="image-20211025100921484"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这道题的关键是找到右上角作为起始点，这样的话整个矩阵就能看做是一个二叉搜索树。</p><ul><li>以n,m为行列，判断情况如下：<ul><li>如果target&lt;matrix[n][m]，则取二叉搜索树中的左子树，即n–</li><li>如果target&gt;matrix[n][m]，则取二叉搜索树中的右子树，即m++</li><li>如果target==matrix[n][m]，则直接返回true</li></ul></li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从右上角开始二叉树搜索</span></span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>,row=matrix.<span class="built_in">size</span>(),m=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;row&amp;&amp;m&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;matrix[n][m])&#123;</span><br><span class="line">                m--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;matrix[n][m])&#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 638大礼包（记忆化DFS）</title>
      <link href="/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/"/>
      <url>/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638. 大礼包"></a><a href="https://leetcode-cn.com/problems/shopping-offers/">638. 大礼包</a></h2><p><img src="/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/image-20211024113701934.png" alt="image-20211024113701934"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><h4 id="基础代码："><a href="#基础代码：" class="headerlink" title="基础代码："></a>基础代码：</h4><p>​    近期花时间比较长的一道题，一开始以为是动态规划的题目，后面发现思路走不通换成DFS的思路。主要还是通过深搜+剪枝来获取所有可能的情况，而后通过min()来获取其最小值。</p><ul><li>用minPrice来作为最小值的记录，在最外层for循环结束（即当前层级的所有可能性结束后）返回</li><li>记录下lastPrice，其作为递归向下寻找可能性的依据，需要作为参数单独传入dfs函数中,<span style="color:red">一开始是把minPrice传进去，思路肯定是不对的（这样的话totalPrice就没办法保存下来了）。</span></li><li>记录下curPackagePrice，表示当前购买礼包所花费的价钱，根据其和needs计算后续的总价格totalPrice。</li><li>在每次循环过后要对needs和curPackagePrice进行还原</li><li><span style="color:red"><strong>注意：minPrice仅代表当前DFS层级上的最小价格。</strong></span></li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dfs递归</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter = <span class="built_in">RemovePackages</span>(price, special, needs);</span><br><span class="line">        <span class="keyword">int</span> lastPrice=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            lastPrice+=needs[i]*price[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, filter, needs,<span class="number">0</span>,lastPrice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">RemovePackages</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs) &#123;</span><br><span class="line">        <span class="comment">//排除掉收益不如单买的special</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; special.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; special[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                temp += price[j]*special[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; special[i].<span class="built_in">back</span>()) &#123;</span><br><span class="line">                filter.<span class="built_in">push_back</span>(special[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; filter, vector&lt;<span class="keyword">int</span>&gt;&amp; needs,<span class="keyword">int</span> curPackagePrice,<span class="keyword">int</span> lastPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalPrice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = lastPrice; <span class="comment">//在当前已有</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filter.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> succ = <span class="literal">true</span>;</span><br><span class="line">            totalPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (needs[j] &lt; filter[i][j]) &#123;</span><br><span class="line">                    succ = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!succ) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//加上礼包和剩余的单买</span></span><br><span class="line">                curPackagePrice += filter[i].<span class="built_in">back</span>();</span><br><span class="line">                totalPrice += curPackagePrice;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; needs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    needs[j] -= filter[i][j];</span><br><span class="line">                    totalPrice += needs[j] * price[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice,<span class="built_in">dfs</span>(price, filter, needs,curPackagePrice,totalPrice));</span><br><span class="line">            <span class="comment">//加回之前减去的package</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>()<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                needs[j] += filter[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            curPackagePrice -= filter[i].<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="优化过程："><a href="#优化过程：" class="headerlink" title="优化过程："></a>优化过程：</h4><p><span style="color:red">△发现还是有可优化的点，可以把curPackagePrice和lastPrice去掉</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dfs递归</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter = <span class="built_in">RemovePackages</span>(price, special, needs);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, filter, needs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">RemovePackages</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs) &#123;</span><br><span class="line">        <span class="comment">//排除掉收益不如单买的special</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; special.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; special[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                temp += price[j]*special[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; special[i].<span class="built_in">back</span>()) &#123;</span><br><span class="line">                filter.<span class="built_in">push_back</span>(special[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; filter, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minPrice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            minPrice+=needs[i]*price[i]; <span class="comment">//△全买情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filter.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> succ = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (needs[j] &lt; filter[i][j]) &#123;</span><br><span class="line">                    succ = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!succ) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; needs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    needs[j] -= filter[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice,<span class="built_in">dfs</span>(price, filter, needs)+filter[i].<span class="built_in">back</span>());</span><br><span class="line">            <span class="comment">//加回之前减去的package</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>()<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                needs[j] += filter[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>附带上官方题解的记忆化深搜</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;vector&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = price.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤不需要计算的大礼包，只保留需要计算的大礼包</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filterSpecial;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; sp : special) &#123;</span><br><span class="line">            <span class="keyword">int</span> totalCount = <span class="number">0</span>, totalPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                totalCount += sp[i];</span><br><span class="line">                totalPrice += sp[i] * price[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (totalCount &gt; <span class="number">0</span> &amp;&amp; totalPrice &gt; sp[n]) &#123;</span><br><span class="line">                filterSpecial.<span class="built_in">emplace_back</span>(sp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, special, needs, filterSpecial, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索计算满足购物清单所需花费的最低价格</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; price,<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp; special, vector&lt;<span class="keyword">int</span>&gt; curNeeds, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp; filterSpecial, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!memo.<span class="built_in">count</span>(curNeeds)) &#123;</span><br><span class="line">            <span class="keyword">int</span> minPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                minPrice += curNeeds[i] * price[i]; <span class="comment">// 不购买任何大礼包，原价购买购物清单中的所有物品</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; curSpecial : filterSpecial) &#123;</span><br><span class="line">                <span class="keyword">int</span> specialPrice = curSpecial[n];</span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; nxtNeeds;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (curSpecial[i] &gt; curNeeds[i]) &#123; <span class="comment">// 不能购买超出购物清单指定数量的物品</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nxtNeeds.<span class="built_in">emplace_back</span>(curNeeds[i] - curSpecial[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nxtNeeds.<span class="built_in">size</span>() == n) &#123; <span class="comment">// 大礼包可以购买</span></span><br><span class="line">                    minPrice = <span class="built_in">min</span>(minPrice, <span class="built_in">dfs</span>(price, special, nxtNeeds, filterSpecial, n) + specialPrice);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[curNeeds] = minPrice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[curNeeds];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><span style="color:red">△查看之后发现自己上面的那种方法还是会出现重复计算的情况，没有去应用到<strong>记忆化</strong>的目的，还是再跟着思路去敲一遍。</span></p><p>稍微简化了一下题解的记忆化深搜：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;vector&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; memo; <span class="comment">//记忆化数组，记录下对应购买情况下的价格，防止重复计算</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dfs记忆化递归</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter = <span class="built_in">RemovePackages</span>(price, special, needs);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, filter, needs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">RemovePackages</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs) &#123;</span><br><span class="line">        <span class="comment">//排除掉收益不如单买的special</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; special.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; special[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                temp += price[j]*special[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; special[i].<span class="built_in">back</span>()) &#123;</span><br><span class="line">                filter.<span class="built_in">push_back</span>(special[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; filter, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!memo.<span class="built_in">count</span>(needs))&#123;</span><br><span class="line">            <span class="keyword">int</span> minPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                minPrice+=needs[i]*price[i]; <span class="comment">//△全买情况</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filter.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">bool</span> succ = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (needs[j] &lt; filter[i][j]) &#123;</span><br><span class="line">                        succ = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!succ) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; needs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                        needs[j] -= filter[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                minPrice = <span class="built_in">min</span>(minPrice,<span class="built_in">dfs</span>(price, filter, needs)+filter[i].<span class="built_in">back</span>());</span><br><span class="line">                <span class="comment">//加回之前减去的package</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>()<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                    needs[j] += filter[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[needs]=minPrice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo.<span class="built_in">count</span>(needs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后也算优化到比较好的情况：</p><p><img src="/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/image-20211024123941326.png" alt="image-20211024123941326"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET框架：Async和await，ETVoid与ETTask</title>
      <link href="/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/"/>
      <url>/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    看ET框架时发现其广泛使用了ETVoid、ETTask的异步处理方式，同时也有段时间没复习await/async的有关内容了，所以也趁这个机会重新看一看。</p><ul><li>参考资料</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4.1ETTask:</span><br><span class="line">https://www.yuque.com/et-xd/docs/wyr682</span><br><span class="line">ET篇：ETVoid和void，ETTask和Task的区别与使用时机:</span><br><span class="line">https://www.lfzxb.top/et-ettask-etvoid/</span><br><span class="line">C# async 和 await 理解：</span><br><span class="line">https://blog.csdn.net/a462533587/article/details/82261468</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ET方面：<ul><li>ET框架是单线程逻辑，ETTask是一个轻量级单线程的Task，相比Task性能更强，本质上可以说是协程</li><li>ETTask就是把回调改成同步的写法，具体是单线程回调还是多线程回调都与ETTask无关</li><li>ETVoid是代替async void ，意思是新开一个<span style="color:red">协程</span></li><li>ETTask的Coroutine方法是为了无GC，ETTask必须await或者调用coroutine才能回收重用ETTaskCompletionSource</li></ul></li><li>await/task方面：<ul><li>Task本身与多线程无关，而Task.Run()等创建函数中则会将线程池中的线程分配给创建出来的Task</li><li>await本身与多线程无关，只是会在async函数中根据await切分为几段，做成一个状态机，将其中的每一段都用一个task来分割，在这个task.Complete被执行的时候将状态机.next()方法压入到同步上下文中，最后调用状态机.Next()执行await之后的流程。</li></ul></li></ul><h3 id="await和async"><a href="#await和async" class="headerlink" title="await和async"></a>await和async</h3><p>首先以一个代码例子来作为切入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace asyncTest</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Test();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static async void Test()</span><br><span class="line">        &#123;</span><br><span class="line">            //MARKER:这里创建了一个新的状态机来划分await</span><br><span class="line">            Console.WriteLine(&quot;main:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            await Method4(); //这里做了第一次分割，下一行会用新的task执行</span><br><span class="line">            Method1(); </span><br><span class="line">            //开启一个新的Task</span><br><span class="line">            Task.Run(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;new task:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            &#125;);</span><br><span class="line">            Method2();</span><br><span class="line">            await Method1(); //同理</span><br><span class="line">            Method3();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static async Task Method1()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;method 1:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            await Task.Run(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot; Method 1&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; 10; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;After-------&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static async Task Method4()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;method 4:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            await Task.Run(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot; Method 4&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public static void Method2()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Method2:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            for (int i = 0; i &lt; 30; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot; Method 2&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void Method3()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Method3:&quot; + AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            for (int i = 0; i &lt; 30; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot; Method 3&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到的结果为：</p><p><img src="/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/image-20211023143024534.png" alt="image-20211023143024534"></p><p><img src="/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/image-20211023143130372.png" alt="image-20211023143130372"></p><p>我们可以来捋一捋发生的情况：</p><ul><li>主线程的线程id为14452，而在等待第一次await结束前的Method4()函数也同时在主线程中执行</li><li>之后的Method1()、Method2()、await Method1() 则被划分到了新的Task内执行，因此三者的线程ID都为新的随机分配的ID，而Task.Run()作为Task创建函数则在创建时根据线程池给task分配了线程ID</li><li>最后的Method3()原因与第二点相同，其被划分到了新的Task内执行，因此其线程ID为新的随机分配的ID</li></ul><h2 id="ETVoid与ETTask"><a href="#ETVoid与ETTask" class="headerlink" title="ETVoid与ETTask"></a>ETVoid与ETTask</h2><p><span style="color:red">其实这点在烟雨大佬的博客中已经写得比较详细了，我主要是在基础上加上一些理解。</span></p><p>备用链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C# Task的GetAwaiter和ConfigureAwait：</span><br><span class="line">https://www.cnblogs.com/majiang/p/7908441.html</span><br></pre></td></tr></table></figure><h3 id="异同点："><a href="#异同点：" class="headerlink" title="异同点："></a>异同点：</h3><ul><li><p>共同点</p><ul><li>都具有async修饰符，即都代表了异步函数</li></ul></li><li><p>不同点</p><ul><li>ETTask可以有返回值(&lt;T&gt;作为泛型即可)；可以等待返回结果(具有getAwaiter以及实现awaiter对应接口)；可以通过.Coroutine()执行无需等待返回的异步，也可以通过await执行需要等待异步返回才能继续的情况</li><li>ETVoid不能有返回值，不可以等待返回结果(即不能用await)，也无法等待自身内部任务完成后再执行下面的语句</li></ul></li></ul><h3 id="使用情况："><a href="#使用情况：" class="headerlink" title="使用情况："></a>使用情况：</h3><ul><li>ETTask<ul><li>通常用于ET的EventSystem中的事件函数，同时也用于UI创建的异步函数(ETTask&lt;UI&gt;)，其本身可以通过返回值返回异步创建后的ui</li></ul></li><li>ETVoid<ul><li>通常用于ET中的网络交互的框架，因为基本不可能存在await服务器消息的情况（如果服务器崩了那客户端也会直接卡死），具体可以看C/S中的一些处理网络信息的handler</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> Unity </tag>
            
            <tag> 框架 </tag>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 492 构造矩形</title>
      <link href="/2021/10/23/Leetcode-492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/"/>
      <url>/2021/10/23/Leetcode-492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="492-构造矩形"><a href="#492-构造矩形" class="headerlink" title="492. 构造矩形"></a><a href="https://leetcode-cn.com/problems/construct-the-rectangle/">492. 构造矩形</a></h2><p><img src="/2021/10/23/Leetcode-492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/image-20211023102717777.png" alt="image-20211023102717777"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    一道非常简单的题目，直接将面积开平方向上取整以后从下往上判断是否符合要求，符合则break即可。</p><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">constructRectangle</span><span class="params">(<span class="keyword">int</span> area)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从sqrt(area)开始计算</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(area));</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;=area;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(area%i==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(area/i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 229.求众数 II</title>
      <link href="/2021/10/22/Leetcode-229-%E6%B1%82%E4%BC%97%E6%95%B0-II/"/>
      <url>/2021/10/22/Leetcode-229-%E6%B1%82%E4%BC%97%E6%95%B0-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="229-求众数-II"><a href="#229-求众数-II" class="headerlink" title="229. 求众数 II"></a><a href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a></h2><p><img src="/2021/10/22/Leetcode-229-%E6%B1%82%E4%BC%97%E6%95%B0-II/image-20211022094507477.png" alt="image-20211022094507477"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ul><li>遍历计数法<ul><li>先遍历vector，用unordered_map记录下每个数出现的次数</li><li>逐个判断出现次数是否&gt;nums.size()/3，符合则加入ans中</li><li>时间复杂度为O(n),空间复杂度为O(n)</li></ul></li><li>摩尔投票法<ul><li>根据出现超过⌊ n/3 ⌋次的元素可以得出最多可能有2个这样的元素</li><li>让互不相同的三个元素互相抵消，最终会得到两个可能符合的元素</li><li>遍历计数，判断两个元素是否符合，符合则将其加入到ans中</li><li>时间复杂度为O(n),空间复杂度为O(1)</li></ul></li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//MARKER:摩尔投票法</span></span><br><span class="line">        <span class="keyword">int</span> vote1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> vote2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出可能的两个num</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vote1&gt;<span class="number">0</span> &amp;&amp; num1==num)&#123;</span><br><span class="line">                vote1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (vote2&gt;<span class="number">0</span> &amp;&amp; num2==num)&#123;</span><br><span class="line">                vote2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (vote1==<span class="number">0</span>)&#123;</span><br><span class="line">                num1=num;</span><br><span class="line">                vote1=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (vote2==<span class="number">0</span>)&#123;</span><br><span class="line">                num2=num;</span><br><span class="line">                vote2=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                vote1--;</span><br><span class="line">                vote2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==num1) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num==num2) count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (count1&gt;nums.<span class="built_in">size</span>()/<span class="number">3</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count2&gt;nums.<span class="built_in">size</span>()/<span class="number">3</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ET6.0的对战游戏demo</title>
      <link href="/2021/10/21/%E5%9F%BA%E4%BA%8EET6-0%E7%9A%84%E5%AF%B9%E6%88%98%E6%B8%B8%E6%88%8Fdemo/"/>
      <url>/2021/10/21/%E5%9F%BA%E4%BA%8EET6-0%E7%9A%84%E5%AF%B9%E6%88%98%E6%B8%B8%E6%88%8Fdemo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    先开个坑，关系到毕业设计的实现。</p><h2 id="暂定的网络同步思路"><a href="#暂定的网络同步思路" class="headerlink" title="暂定的网络同步思路"></a>暂定的网络同步思路</h2><ul><li>状态同步方式<ul><li>位置方面：客户端Unit每隔一段时间将自身的位置、朝向、速度发送给服务器，服务器计算出最终结果后进行广播操作，所有Units对位置结果进行插值处理</li><li>状态方面（技能、动画等）：利用一个状态包来进行转发广播操作，与位置包分开处理</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 框架 </tag>
            
            <tag> ET </tag>
            
            <tag> demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 66.加一</title>
      <link href="/2021/10/21/Leetcode-66-%E5%8A%A0%E4%B8%80/"/>
      <url>/2021/10/21/Leetcode-66-%E5%8A%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a href="https://leetcode-cn.com/problems/plus-one/">66. 加一</a></h2><p><img src="/2021/10/21/Leetcode-66-%E5%8A%A0%E4%B8%80/image-20211021100630610.png" alt="image-20211021100630610"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​        方法1：直接从最后一位开始模拟整个加法的过程即可</p><p>​        方法2：逆序查找第一个不为9的数加1，其余都设为0即可<span style="color:red">(感觉更简单)</span></p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans=digits;</span><br><span class="line">        <span class="keyword">int</span> index=ans.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> add=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(add==<span class="number">1</span> &amp;&amp; index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            ans[index]+=add;</span><br><span class="line">            add=ans[index]/<span class="number">10</span>;</span><br><span class="line">            ans[index--]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑最终有进位情况</span></span><br><span class="line">        <span class="keyword">if</span> (add==<span class="number">1</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>(),<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 453: 最小操作次数使数组元素相等</title>
      <link href="/2021/10/20/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/"/>
      <url>/2021/10/20/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/10/20/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/image-20211020135000199.png" alt="image-20211020135000199"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>考虑到n-1个元素增加1，对于这n-1个元素来说差值的情况是不会变得，因此可以看做是<span style="color:red">这n-1个元素并没有变而是将最后1个元素减1的情况</span>，这时解题的代码就非常明确了。</p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将n-1个元素增加1相当于让1个元素减1</span></span><br><span class="line">        <span class="keyword">int</span> min=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> temp:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp&lt;min)&#123;</span><br><span class="line">                min=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> temp:nums)&#123;</span><br><span class="line">            ans+=temp-min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#:值类型和引用类型的具体类型和区别</title>
      <link href="/2021/10/19/C-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/10/19/C-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先放上一个图表示值类型和引用类型的所有数据类型：</p><p><img src="https://raw.githubusercontent.com/petertan123/cloudimg/master/img/2009020510331710.jpg" alt="img"></p><p>（1）最根本的一个区别：<span style="color:red"><strong>值类型的变量直接存储数据，将数据存储在栈中。而引用类型的变量持有的是数据的引用，数据存储在堆中（对其的实例引用存储在栈中）（面试碰到的话后续还可以引申栈和堆的一些区别，比如GC标记压缩的垃圾回收方法等等）。</strong></span></p><p>（2）<span style="color:red">同时对于struct（值类型）和class（引用类型）来说，struct和class都可以实现接口（函数），但是struct在赋值时（如struct s1=s2）会直接创建s2的副本并赋值给s1，而对于class赋值时（class c1=c2）时会将两个类指向同一个引用，后续操作会同时改变同一个堆中实例。</span></p><p>（3）<span style="color:red">所有的值类型都继承System.ValueType，引用类型继承自System.Object。（其实引用类型和值类型都继承自System.Object类，不同的是，几乎所有的引用类型都直接从System.Object继承，而值类型则继承其子类，即直接继承System.ValueType）</span></p><p><span style="color:blue">△ 如果一个值类型被声明在一个方法体外并且在一个引用类型中，那它就会在堆上进行分配。</span></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> C# </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode记录：211 添加与搜索单词-数据结构设计</title>
      <link href="/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h2><p><img src="/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20211019103409399.png" alt="image-20211019103409399"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    比较典型的一道前缀树的题目，注意在构建前缀树的过程中不要粗心大意即可，前缀树的定义可以参考<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/">208. 实现 Trie (前缀树) 的官方题解</a>。</p><p><span style="color:red">1.用一个is_end来记录是否到达结尾，2.结点向下的多叉树子结点用vector&lt;TrieNode *&gt;来记录</span></p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TrieNode *&gt; childs;</span><br><span class="line">    <span class="keyword">bool</span> is_end;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>(<span class="keyword">bool</span> _is_end=<span class="literal">false</span>)&#123;</span><br><span class="line">        childs=vector&lt;TrieNode *&gt;(<span class="number">26</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        is_end=_is_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        head_node=<span class="keyword">new</span> <span class="built_in">TrieNode</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于前缀树的word增加</span></span><br><span class="line">        <span class="keyword">int</span> length=word.<span class="built_in">length</span>();</span><br><span class="line">        TrieNode *temp=head_node;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch=word[i];</span><br><span class="line">            <span class="keyword">int</span> index=ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;childs[index]==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                temp-&gt;childs[index]=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp-&gt;childs[index];</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;is_end=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于前缀树的word搜索</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word,<span class="number">0</span>,head_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word,<span class="keyword">int</span> index,TrieNode* node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//循环跳出条件</span></span><br><span class="line">        <span class="keyword">if</span> (index==word.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;is_end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> ch=word[index];</span><br><span class="line">        <span class="keyword">if</span> (ch!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index_=ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            TrieNode* temp=node-&gt;childs[index_];</span><br><span class="line">            <span class="keyword">if</span>(temp!=<span class="literal">nullptr</span>&amp;&amp;<span class="built_in">search</span>(word,index+<span class="number">1</span>,temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                TrieNode* temp=node-&gt;childs[i];</span><br><span class="line">                <span class="keyword">if</span>(temp!=<span class="literal">nullptr</span>&amp;&amp;<span class="built_in">search</span>(word,index+<span class="number">1</span>,temp))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *head_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session和Cookie的区别、联系</title>
      <link href="/2021/10/18/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB/"/>
      <url>/2021/10/18/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考：https://www.cnblogs.com/ITCodeMonkey/p/7874343.html</span><br></pre></td></tr></table></figure><p>有时间回来补充一下</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity服务器--什么是RPC?</title>
      <link href="/2021/10/18/Unity%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%BB%80%E4%B9%88%E6%98%AFRPC/"/>
      <url>/2021/10/18/Unity%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%BB%80%E4%B9%88%E6%98%AFRPC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>在学习ET框架中Client与Server交互时的message信息中碰到的RpcId，之前没有太了解，固趁这个机会了解以下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">知乎参考：https://zhuanlan.zhihu.com/p/76727302</span><br></pre></td></tr></table></figure><p>此篇可能会慢慢更新。。。</p><h2 id="RPC-调用分类"><a href="#RPC-调用分类" class="headerlink" title="RPC 调用分类"></a>RPC 调用分类</h2><p>RPC调用分为以下两种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 同步调用  </span><br><span class="line">   客户方等待调用执行完成并返回结果。 </span><br><span class="line">2. 异步调用  --c2s_new,s2c_new,sreq_new</span><br><span class="line">   客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。 </span><br><span class="line">   若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 网络 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode记录: 476 数字的补数</title>
      <link href="/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/"/>
      <url>/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/image-20211018101215331.png" alt="image-20211018101215331"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题的解题思路其实比较清晰，就是求二进制然后取反重新计算新数，可以直接在求解二进制的过程中直接得出最终的结果。</p><p>​    以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先求出其二进制数</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123; <span class="comment">//这里因为题目要求其实num/2!=0也可以</span></span><br><span class="line">            <span class="keyword">int</span> temp=(num%<span class="number">2</span>+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">            result+=<span class="built_in">pow</span>(<span class="number">2</span>,count++)*temp;</span><br><span class="line">            num/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        <span style="color:red">单看这个可能问题已经解决了，但是题目中想让我们实现的位运算其实并没有做到，在看到一些大佬的题解后，其实还有更简单直接的方法。</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp = num, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            c =  (c &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num ^ c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        <span style="color:blue">这里的思路是：求出temp有多少位以后利用得出一个全1的c，再通过num^c（异或）就能得出最终结果，更符合题目的要求。</span></p><p>​    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++运算符优先级参考：https://www.sojson.com/operation/cxx.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET6.0框架初步</title>
      <link href="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/"/>
      <url>/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    因为学校毕设选题选择了Unity游戏开发相关的内容，并且ECS一直是我比较想去了解的方面，所以选择了ET作为毕设游戏所采用的框架。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考：1.&lt;&lt;ET6.0使用手册&gt;&gt; https://www.lfzxb.top/et6-manual/</span><br><span class="line"> 2.&lt;&lt;ET6.0学习笔记&gt;&gt; https://www.lfzxb.top/et6.0-study/</span><br></pre></td></tr></table></figure><h2 id="ECS相对于传统面向对象模式OOP"><a href="#ECS相对于传统面向对象模式OOP" class="headerlink" title="ECS相对于传统面向对象模式OOP"></a>ECS相对于传统面向对象模式OOP</h2><p>​    以前曾开发过ARPG的demo和2D横版过关的demo，所采用的都是传统的面向对象的思路和方法。采用类继承的方式，在前期的开发过程中还是比较轻松，但是在后期的基类逐渐冗余后，也能感觉到面向对象的一些的缺点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考：https://www.cnblogs.com/egametang/p/7511589.html</span><br></pre></td></tr></table></figure><p>​    在看了上面这篇文章以后，更是对一些面向对象的优缺点有了更深的体会，浓缩为以下两点。</p><h3 id="OOP数据结构耦合性强"><a href="#OOP数据结构耦合性强" class="headerlink" title="OOP数据结构耦合性强"></a>OOP数据结构耦合性强</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一旦父类中增加或删除某个字段，可能要影响到所有子类，影响到所有子类相关的逻辑。</span><br></pre></td></tr></table></figure><h3 id="OOP难以热插拔"><a href="#OOP难以热插拔" class="headerlink" title="OOP难以热插拔"></a>OOP难以热插拔</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">继承结构无法在运行时动态增加或删除字段，比如有时会需要取消player的某个功能，但这时只能进行禁用，而不能把功能完完全全的剥离出去。</span><br></pre></td></tr></table></figure><p>​    这点在lua中其实得到了很好的解决，在实习阶段我也是基本用的lua来进行minigame的开发，相对于C#来说，Lua语言其实可以选择抛弃传统的纯粹继承的方式，采用类似于<span style="color:red">单例类+require</span>的方式来进行逻辑开发，而实际上在除游戏实际角色、技能、状态机之外的情况下我也确实采用了这种方法来编写（登入，选服，匹配等等）。可以说这段经历对我来说是一段新的体验，也更加深了我想要去了解ECS组件式开发的兴趣。</p><p>​    <span style="color:blue">ET框架作为一个Unity的双端框架，采用了ECS的组件式概念来进行设计，其ECS的概念也曾经应用于热门的商业游戏守望先锋等，即实体(Entity)-组件(Component)-系统(system),其将Entity中所具有的Component抽象出来，遵循组合大于继承的原则，每位实体都通过一个或多个组件ID连接多个功能组件,避免了一些不必要的开销。</span></p><p>​    <span style="color:red"><strong>这篇文章仅用于记录下ECS学习过程中的一些心得体会，主要还是对烟雨大佬视频的一些自身收获。</strong></span></p><h2 id="环境配置和demo运行"><a href="#环境配置和demo运行" class="headerlink" title="环境配置和demo运行"></a>环境配置和demo运行</h2><p><span style="color:red"><strong>在ET/Book中已经有各种ET框架指南，本篇主要是记录一些具体过程。</strong></span></p><p>先放一下工程中整体的目录截图：</p><p>分为两个主要的sln，Unity和Server：</p><p>Unity：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017140008420.png" alt="image-20211017140008420"></p><p>Server：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017140040074.png" alt="image-20211017140040074"></p><p><strong>△Unity和Server中所有的project都要进行build的操作</strong></p><p>服务器：</p><p>​    需要安装MongoDB数据库（对于ET的初始demo来说不需要，因为其将数据库交互部分注释了）</p><p>​    需要安装Net Core 或Net Framework（我用的是Net5.0）</p><p>​    在build后启动Server.App即可开启服务器</p><p>客户端：</p><p>​    在UnityHub中打开对应项目工程后，首先在Assets/Scenes中找到启动的Init场景</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017143237959.png" alt="image-20211017143237959"></p><p>运行后即可输入账号密码进入游戏场景</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017143405871.png" alt="image-20211017143405871"></p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017143434676.png" alt="image-20211017143434676"></p><h2 id="导表部分"><a href="#导表部分" class="headerlink" title="导表部分"></a>导表部分</h2><p>先上一张导表方法图：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/ET%E5%AF%BC%E8%A1%A8%E6%96%B9%E6%B3%95.png" alt="ET导表方法"></p><p><span style="color:red">与烟雨大佬视频中的不同，现在的ET版本中导表工具已经由之前的Assets/Editor/ExcelExporterEditor/ExcelExporterEditor.cs迁移到Server/Model/ExcelExporter/ExcelExporter.cs，而在Unity中的Editor拓展也已经移除了。</span></p><h3 id="过程理解："><a href="#过程理解：" class="headerlink" title="过程理解："></a>过程理解：</h3><h4 id="导出JSON-暂存信息-："><a href="#导出JSON-暂存信息-：" class="headerlink" title="导出JSON(暂存信息)："></a>导出JSON(暂存信息)：</h4><p>让我们先打开这个ExcelExporter.cs，其在调用时已经被包含在<span style="color:red">ET/Bin/Server.dll</span>的动态链接库中，因此我们当前的目录其实就是Bin，接下来看下图中的Excel表，Json表等存放的路径就非常清晰了。</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017153220996.png" alt="image-20211017153220996"></p><p>对于Excel的读取采用了OfficeOpenXml中的ExcelPackage类来进行处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C#excelpackage读写Excel文件：https://www.cnblogs.com/sange0708/p/15005370.html</span><br></pre></td></tr></table></figure><p>先来看一下在demo中给出的AIConfig.xlsx的表格例子：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017162205295.png" alt="image-20211017162205295"></p><p>对应在ExcelPackage读取后的JSON导出代码：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017162408170.png" alt="image-20211017162408170"></p><p>可以得知对应Excel中<span style="color:blue">第二行为是否不导出为JSON，第三行的内容为变量描述、第四行为变量名、第五行为导出类型</span></p><p><span style="color:red">#作为中断读取的标志，有#的变量都不会导出为Json</span></p><p>之后是对具体变量内容的读取和写入：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017163109993.png" alt="image-20211017163109993"></p><p>根据之前读取到的头文件信息，从Excel表中的第六行开始进行读取，而后在StringBuffer中写入对应的json信息。</p><h4 id="导出类-用于反序列化-："><a href="#导出类-用于反序列化-：" class="headerlink" title="导出类(用于反序列化)："></a>导出类(用于反序列化)：</h4><p>其对<span style="color:red">headInfo</span>的读取与导出JSON是相同的，关键点在于对于class读取类的导出，用到了在Export中读取到的template.txt，它其实是一个类class的代码模板(继承自ProtoObject)，导出类做的主要工作就是将类名、域名等的信息套到这个模板代码中，并生成对应的cs文件。</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017164315689.png" alt="image-20211017164315689"></p><h4 id="根据生成的类，动态编译把JSON转译成protobuf："><a href="#根据生成的类，动态编译把JSON转译成protobuf：" class="headerlink" title="根据生成的类，动态编译把JSON转译成protobuf："></a>根据生成的类，动态编译把JSON转译成protobuf：</h4><p>比起之前版本的ET，新版本的ET是通过<strong>protobuf</strong>来作为序列化数据的。因此最关键的一步就是转译，具体的代码过程就不贴出来了。</p><h3 id="使用例子："><a href="#使用例子：" class="headerlink" title="使用例子："></a>使用例子：</h3><h4 id="导表："><a href="#导表：" class="headerlink" title="导表："></a>导表：</h4><p>​    在cmd中cd到对应的<strong>根目录/Bin</strong>文件夹中，而后执行dotnet Server.dll –AppType=ExcelExporter即可，导出的表格会分别存放在./Client/Json文件夹和./Server/Json文件夹中。</p><p>​    <img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017164636195.png" alt="image-20211017164636195"></p><h4 id="脚本使用："><a href="#脚本使用：" class="headerlink" title="脚本使用："></a>脚本使用：</h4><p>​    在具体CS脚本中的通过<span style="color:red">表格名+Category</span>的单例类就可以获取对应的表格信息（key值对应ID）。</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211017170048269.png" alt="image-20211017170048269"></p><h2 id="Proto生成CS与拓展"><a href="#Proto生成CS与拓展" class="headerlink" title="Proto生成CS与拓展"></a>Proto生成CS与拓展</h2><p><span style="color:red">ET框架采用了分布式服务器的方式。</span></p><p>同样列出上方的一张图：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211018155809927.png" alt="image-20211018155809927"></p><p>我们先来找到ET/Model/Proto2CS/Program.cs文件，与导表的cs文件相同，其在具体使用的时候同样是被打成了dll放在了ET/Bin文件夹下，因此文件的根目录同样是Bin文件夹。</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211018160111894.png" alt="image-20211018160111894"></p><p>​        对于客户端和服务器的生成路径如上图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">之前在实习阶段也对proto的定义有了一些理解，但是在实际看到ET框架内的proto的时候还是和之前所认知的有一些差别，</span><br><span class="line">之前的框架是基于lua脚本因此对proto来说无需转换到CS，而如今ET框架的热更等是面向ILRuntime的。</span><br></pre></td></tr></table></figure><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211018163131915.png" alt="image-20211018163131915"></p><p>看到具体的Proto2CS的生成函数：</p><p>1.InnerMessage是服务器内部的协议生成，可能是用于分布式的多服务器沟通</p><p>2.OuterMessage则是针对于C2S和S2C之间的交互了</p><p><span style="color:red">ET客户端与服务端的交互总览：（取自烟雨大佬的视频）</span></p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211020153521006.png" alt="image-20211020153521006"></p><p>网关服：用于做消息转发，与Actor信息配套</p><p>验证服：账号的登入，注册</p><p>战斗服：寻路、战斗信息</p><p><span style="color:red"><strong>Domain指这个entity属于哪个scene，一个进程可以容纳多个scene</strong></span></p><h3 id="使用例子：-1"><a href="#使用例子：-1" class="headerlink" title="使用例子："></a>使用例子：</h3><h4 id="脚本使用：-1"><a href="#脚本使用：-1" class="headerlink" title="脚本使用："></a>脚本使用：</h4><p><span style="color:red">客户端调用：</span></p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211018171843943.png" alt="image-20211018171843943"></p><p><span style="color:red">服务器处理：</span></p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211019135845225.png" alt="image-20211019135845225"></p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211019141256527.png" alt="image-20211019141256527"></p><p>△可以看到在服务器的Handler中有分布式服务器之间的交互处理</p><h3 id="实际使用过程："><a href="#实际使用过程：" class="headerlink" title="实际使用过程："></a>实际使用过程：</h3><ul><li>定义proto文件</li><li>生成C#代码</li><li>编写双端收发逻辑代码</li></ul><h4 id="在OuterMessage-proto中添加新的协议"><a href="#在OuterMessage-proto中添加新的协议" class="headerlink" title="在OuterMessage.proto中添加新的协议"></a>在OuterMessage.proto中添加新的协议</h4><p>这里没有采用actor的方式，添加了三个协议</p><ul><li>C2R_TestSend</li><li>C2R_TestCall</li><li>R2C_TestResponse</li></ul><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211020234524827.png" alt="image-20211020234524827"></p><h4 id="在客户端的LoginHelper的异步Login中添加相应session-Call和Send："><a href="#在客户端的LoginHelper的异步Login中添加相应session-Call和Send：" class="headerlink" title="在客户端的LoginHelper的异步Login中添加相应session.Call和Send："></a>在客户端的LoginHelper的异步Login中添加相应session.Call和Send：</h4><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211020154921586.png" alt="image-20211020154921586"></p><h4 id="在服务器的Hotfix-Demo中加入对应的CallHandler和SendHandler"><a href="#在服务器的Hotfix-Demo中加入对应的CallHandler和SendHandler" class="headerlink" title="在服务器的Hotfix/Demo中加入对应的CallHandler和SendHandler"></a>在服务器的Hotfix/Demo中加入对应的CallHandler和SendHandler</h4><ul><li>C2R_TestCallHandler</li></ul><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211020234051973.png" alt="image-20211020234051973"></p><ul><li>C2R_TestSendHandler</li></ul><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211020234029225.png" alt="image-20211020234029225"></p><ul><li>注意点<ul><li>Request和Response的应实现AMRpcHandler接口，而用于处理Request的则实现AMHandler接口。</li><li>在写入新的协议handler以后要对重新build Hotfix</li><li>要在对应的Handler类上打上[MessageHandler]的标签</li><li>Log.Info进行了进一步封装，其结果存放在ET/Logs目录的日志文件中</li></ul></li></ul><p>现在服务器和客户端都能输出正确回应：</p><p>server:</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211020234220037.png" alt="image-20211020234220037"></p><p>client:</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211020232241622.png" alt="image-20211020232241622"></p><h2 id="Actor机制"><a href="#Actor机制" class="headerlink" title="Actor机制"></a>Actor机制</h2><p>同样先放上在烟雨大佬视频的思维导图：</p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211021101415991.png" alt="image-20211021101415991"></p><ul><li>关键点<ul><li>Entity InstanceID是唯一的，即对应的每个居住证是唯一的，仅代表了当前所在进程以及自身Entity</li><li>Entity上挂载的MailboxComponent组件就是一种Actor，只需要知道Entity的InstanceId就可以给这个Entity发送消息</li><li>Actor模型固然方便，但是在有时我们无法知道对方的InstanceId或者对方的InstanceId进行了改变，这时候就需要ActorLocation发挥作用，Actor对象在一个进程创建时或者迁移到一个新的进程时，都需要把自己的Id跟新的InstanceId注册到Location Server上去，<span style="color:red">ActorLocationSender提供两种方法，Send跟Call，Send一个信息也需要接受者返回一个消息，只有收到返回的消息才会发送下一个消息。</span></li><li>Actor模型是<span style="color:red">纯粹的服务器消息通信机制</span>，ET客户端使用这个Actor完全是因为Gate需要对客户端消息进行转发，我们可以正好利用服务端actor模型来进行转发，所以客户端有些消息也是继承了actor的接口。</li><li>Actor和ActorLocation的一个最大的区别在于ActorLocation需要先在Location服务器中获取到Entity的真实的InstanceId，<span style="color:blue">其在LocationProxyComponentSystem.cs中体现，通过key:UnitId对应value:InstanceId</span></li></ul></li></ul><h3 id="具体例子："><a href="#具体例子：" class="headerlink" title="具体例子："></a>具体例子：</h3><p>下面是一个在进入map服后创建战斗Unit的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[ActorMessageHandler]</span><br><span class="line">public class G2M_CreateUnitHandler : AMActorRpcHandler&lt;Scene, G2M_CreateUnit, M2G_CreateUnit&gt;</span><br><span class="line">&#123;</span><br><span class="line">protected override async ETTask Run(Scene scene, G2M_CreateUnit request, M2G_CreateUnit response, Action reply)</span><br><span class="line">&#123;</span><br><span class="line">UnitComponent unitComponent = scene.GetComponent&lt;UnitComponent&gt;();</span><br><span class="line">Unit unit = Entity.CreateWithId&lt;Unit, int&gt;(unitComponent, IdGenerater.Instance.GenerateId(), 1001);</span><br><span class="line">unit.AddComponent&lt;MoveComponent&gt;();</span><br><span class="line">unit.Position = new Vector3(-10, 0, -10);</span><br><span class="line"></span><br><span class="line">NumericComponent numericComponent = unit.AddComponent&lt;NumericComponent&gt;();</span><br><span class="line">numericComponent.Set(NumericType.Speed, 6f); // 速度是6米每秒</span><br><span class="line"></span><br><span class="line">unit.AddComponent&lt;MailBoxComponent&gt;();</span><br><span class="line">await unit.AddLocation();</span><br><span class="line">unit.AddComponent&lt;UnitGateComponent, long&gt;(request.GateSessionId);</span><br><span class="line">unitComponent.Add(unit);</span><br><span class="line">response.UnitId = unit.Id;</span><br><span class="line"></span><br><span class="line">// 把自己广播给周围的人</span><br><span class="line">M2C_CreateUnits createUnits = new M2C_CreateUnits();</span><br><span class="line">createUnits.Units.Add(UnitHelper.CreateUnitInfo(unit));</span><br><span class="line">MessageHelper.Broadcast(unit, createUnits);</span><br><span class="line"></span><br><span class="line">// 把周围的人通知给自己</span><br><span class="line">createUnits.Units.Clear();</span><br><span class="line">Unit[] units = scene.GetComponent&lt;UnitComponent&gt;().GetAll();</span><br><span class="line">foreach (Unit u in units)</span><br><span class="line">&#123;</span><br><span class="line">createUnits.Units.Add(UnitHelper.CreateUnitInfo(u));</span><br><span class="line">&#125;</span><br><span class="line">//△通过GateSessionActorId向对应的unit发送消息</span><br><span class="line">MessageHelper.SendActor(unit.GetComponent&lt;UnitGateComponent&gt;().GateSessionActorId, createUnits);</span><br><span class="line"></span><br><span class="line">reply();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">    其中的MessageHelper.SendActor已经很明了了，其通过对应Unit的网关InstanceId来向对应Unit发送信息，那么对于MessageHelper呢？</span></p><p>​    查看MessageHelper源码中的Broadcast发现，其同样使用了SendActor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void Broadcast(Unit unit, IActorMessage message)</span><br><span class="line">&#123;</span><br><span class="line">    //获取在相同Scene中的所有Units(也就是同处于战斗服)</span><br><span class="line">    var units = unit.Domain.GetComponent&lt;UnitComponent&gt;().GetAll();</span><br><span class="line"></span><br><span class="line">    if (units == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foreach (Unit u in units)</span><br><span class="line">    &#123;</span><br><span class="line">        UnitGateComponent unitGateComponent = u.GetComponent&lt;UnitGateComponent&gt;();</span><br><span class="line">        SendActor(unitGateComponent.GateSessionActorId, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ET-6-0-demo中的网络交互流程："><a href="#ET-6-0-demo中的网络交互流程：" class="headerlink" title="ET 6.0 demo中的网络交互流程："></a>ET 6.0 demo中的网络交互流程：</h2><ul><li>交互流程<ul><li>客户端发送C2R_Login协议(账号密码)到服务端，服务端在大区中随机分配一个gate，并且在服务器内部向gate请求一个key，客户端可以拿着这个key连接gate，服务器将Address，网关key，网关Id回传给客户端</li><li>客户端发送G2C_LoginGate(网关key和网关Id)到服务端，服务端通过网关key获取对应的账号，同时获取Game中的PlayerComponent，创建Player的Entity并加入其中，同时返回playerId</li><li>客户端发送G2C_EnterMap到服务器，服务器在zone中找到对应的map scene后在map上创建战斗Unit<span style="color:red">（同时会向客户端发送M2C_CreateUnits令其在Game中创建Unit）</span>，并且将UnitId赋值给player.UnitId，同时将其作为返回值回传给客户端，客户端收到后在Game的unitComponent获取对应Unit并赋值给MyUnit</li></ul></li></ul><h2 id="事件系统-EventSystem"><a href="#事件系统-EventSystem" class="headerlink" title="事件系统(EventSystem)"></a>事件系统(EventSystem)</h2><h3 id="使用过程："><a href="#使用过程：" class="headerlink" title="使用过程："></a>使用过程：</h3><p>ET中的事件系统相对比较简单，其定义方式分为三个步骤：</p><ul><li><p>在EventType中定义事件结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace EventType</span><br><span class="line">&#123;</span><br><span class="line">    public struct TestEvent</span><br><span class="line">    &#123;</span><br><span class="line">        public string message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个类用于处理指定时间，泛型类型订阅的事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestEvent_Action: AEvent&lt;EventType.TestEvent&gt;</span><br><span class="line">&#123;</span><br><span class="line"> protected override async ETTask Run(EventType.TestEvent args)</span><br><span class="line">    &#123;</span><br><span class="line">        Log.Info($&quot;TestEvent事件触发了 : &#123;args.Type&#125;&quot;);</span><br><span class="line">        //虽然这个函数是async的，但是我们内部没有异步操作，就可以这样调用，相当于直接return</span><br><span class="line">await ETTask.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抛出事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Game.EventSystem.Publish(new EventType.TestEvent()&#123;Message=&quot;测试&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a>代码解析：</h3><p>​    ![ET EventSystem](ET6.0框架初步/ET EventSystem.png)</p><ul><li>在EventSystem的Add(Assembly assembly)中在程序集内获取到所有打上了Attribute的class，并在从中挑选出打了[Event]标签的class(即实现了IEvent接口的AEvent&lt;A&gt;抽象类)，并将其订阅事件结构体类型Type对应List&lt;obj&gt;()存储在AllEvents字典中<br><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211022105434483.png" alt="image-20211022105434483"></li><li>在Publish时将所有ETTask的Run()函数加入到ListComponent.Create()创建的list中，而后调用ETTaskHelper.WaitAll(list.List);执行<br><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211022105925399.png" alt="image-20211022105925399"></li><li>注意在WaitAll中所有的事件是异步执行的，内部通过CoroutineBlocker来阻塞未执行完的所有Task，在count==0时继续之前所有阻塞的tcs<br><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211022110531535.png" alt="image-20211022110531535"></li></ul><p>关键点：</p><ul><li><p>ETTask重写了传统Task，将自身作为Awaiter，并通过枚举的AwaiterStatus判断是否结束。<img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/dd0f615f0d5b6fef48bbbac88276c8d.jpg" alt="dd0f615f0d5b6fef48bbbac88276c8d"></p><p>上图是可等待模式的处理，对应ETTask分别为：</p><p><strong>GetAwaiter()：</strong></p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211022141746640.png" alt="image-20211022141746640"></p><p><strong>IsCompleted():</strong></p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211022141852539.png" alt="image-20211022141852539"></p><p>​    <span style="color:red">其中的AwaiterStatus可以在SetResult()中进行更改。</span></p><p><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211022142017462.png" alt="image-20211022142017462"></p></li></ul><h2 id="UI系统"><a href="#UI系统" class="headerlink" title="UI系统"></a>UI系统</h2><p>还是很想吐槽一下ET的UI系统实在是有点过于简洁了，其UI生命周期中的事件只有OnCreate和OnRemove两种，后续还需要继续拓展。</p><ul><li>通过UIComponent组件类管理Scene上的UI<ul><li>通过.Create(this UIComponent self,string uiType)函数进行创建，同时在创建时会执行UIEvents字典中通过自定义标签导入进来的onCreate()函数，<span style="color:red">其外部通过UIHelper.Create(Scene scene,string uiType)在指定scene中创建</span></li><li>通过.Remove(this UIComponent self,string uiType)函数进行移除，同时在创建时会执行UIEvents字典中通过自定义标签导入进来的onRemove()函数，<span style="color:red">其外部通过UIHelper.Create(Scene scene,string uiType)在指定scene中移除</span></li></ul></li><li>通过ReferenceCollector可以获取UIPrefab上面的引用，可以直接在prefab里加入RC方便后续获取子物体<br><img src="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/image-20211022153257071.png" alt="image-20211022153257071"></li></ul><hr><p><span style="color:red">基于ET框架的新UI框架正在设计中。。。。（正在考虑UIEvent要不要进一步分离还是维持ET框架原状）</span></p><ul><li>将原先的mid、hidden、low等变为普通GO，用代码设定sortingOrder</li><li>加入UICamera方便管理，代码设定UICamera</li><li>新增onShow(),onHide()</li></ul><p>10/24更新：</p><ul><li>新增UI栈</li><li>UIComponent、UIComponentSystem、UIHelper代码拓展</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> Unity </tag>
            
            <tag> 框架 </tag>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-first-blog</title>
      <link href="/2021/10/16/my-first-blog/"/>
      <url>/2021/10/16/my-first-blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>测试—Test</p><p><span style="color:red">新的开始</span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/16/hello-world/"/>
      <url>/2021/10/16/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
