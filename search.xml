<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于ET的回合制战棋-场景切换部分</title>
      <link href="/2022/03/02/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E5%9B%9E%E5%90%88%E5%88%B6%E6%88%98%E6%A3%8B-%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E9%83%A8%E5%88%86/"/>
      <url>/2022/03/02/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E5%9B%9E%E5%90%88%E5%88%B6%E6%88%98%E6%A3%8B-%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        先吐槽一下ET自带的场景切换组件实在是太简陋了。。因此自己根据项目需要对整个流程进行了重构，不得不说ETTask单线程异步任务是真的好用，免去了命令模式的编写。</p><h2 id="场景切换流程"><a href="#场景切换流程" class="headerlink" title="场景切换流程"></a>场景切换流程</h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E9%83%A8%E5%88%86.drawio.png" alt="场景切换部分.drawio"></p><ul><li><p>通过SceneChangeData实现数据流在场景转换流程中的传递<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302173956097.png" alt="image-20220302173956097"></p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302174040596.png" alt="image-20220302174040596"></p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302175922416.png" alt="image-20220302175922416"></p></li></ul><h3 id="具体函数"><a href="#具体函数" class="headerlink" title="具体函数"></a>具体函数</h3><ul><li><p>InitLoadingUI：<br>实现LoadingUI淡入效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static async ETTask InitLoadingUI(this SceneChangeComponent self, SceneChangeData data)</span><br><span class="line">&#123;</span><br><span class="line">    //LoadingUI淡入</span><br><span class="line">    UIComponent.Instance.ShowWindow(WindowID.WindowID_Loading);</span><br><span class="line">    DlgLoading dlgLoading=UIComponent.Instance.GetDlgLogic&lt;DlgLoading&gt;();</span><br><span class="line">    if (dlgLoading != null)</span><br><span class="line">    &#123;</span><br><span class="line">        data.dlgLoading = dlgLoading; //存入数据流中</span><br><span class="line">        dlgLoading.SetLoadingProgress(0f); //使得进度条为0</span><br><span class="line">        CanvasGroup canvasGroup = dlgLoading.View.uiTransform.GetComponent&lt;CanvasGroup&gt;();</span><br><span class="line">        canvasGroup.alpha = 0f;</span><br><span class="line">        await UIEffectHelper.FadeIn(canvasGroup, 1f, 1f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HandleExitSceneFunc：<br>根据退出的场景类型实现函数分发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static async ETTask HandleExitSceneFunc(this SceneChangeComponent self, SceneChangeData data,Scene zoneScene, float progress)</span><br><span class="line">&#123;</span><br><span class="line">    string lastSceneName = data.lastSceneName;</span><br><span class="line">    if (SceneConst.sceneName2Type.ContainsKey(lastSceneName))</span><br><span class="line">    &#123;</span><br><span class="line">        GameSceneType sceneType = SceneConst.sceneName2Type[lastSceneName];</span><br><span class="line">        if (self.allEvents.TryGetValue(sceneType, out ASceneChangeEvent sceneEvent))</span><br><span class="line">        &#123;</span><br><span class="line">            await sceneEvent.OnExitScene(zoneScene);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    await self.HandleProgress(data, progress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同场景的具体类型在Sceneconst中进行定义：<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302174621970.png" alt="image-20220302174621970"><br>ASceneChangeEvent抽象类：<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302174733356.png" alt="image-20220302174733356">+</p></li><li><p>HandleUnloadFunc:<br>处理场景资源卸载，采用计数方式，因为ETTask的本质为单线程，所以无需考虑多线程加锁。当所有资源卸载完毕后进入下一阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static async ETTask HandleUnloadFunc(this SceneChangeComponent self, SceneChangeData data, float progress)</span><br><span class="line">        &#123;</span><br><span class="line">            string lastSceneName = data.lastSceneName;</span><br><span class="line">            if (SceneConst.sceneName2Type.ContainsKey(lastSceneName))</span><br><span class="line">            &#123;</span><br><span class="line">                GameSceneType sceneType = SceneConst.sceneName2Type[lastSceneName];</span><br><span class="line">                if (self.allEvents.TryGetValue(sceneType, out ASceneChangeEvent sceneEvent))</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;string&gt; unloadNames = sceneEvent.GetUnloadResource();</span><br><span class="line">                    int count = unloadNames?.Count??0;</span><br><span class="line">                    int unloadedCount = 0;</span><br><span class="line">                    for (int i = 0; i &lt; count; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        string assetBundleName = $&quot;&#123;unloadNames[i]&#125;.unity3d&quot;;</span><br><span class="line">                        self.UnloadResources(assetBundleName, () =&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            ++unloadedCount;</span><br><span class="line">                        &#125;).Coroutine();</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    while (unloadedCount &lt; count)</span><br><span class="line">                    &#123;</span><br><span class="line">                        await TimerComponent.Instance.WaitFrameAsync();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //广播场景卸载消息</span><br><span class="line">            EventMessageComponent.Instance.SendMessage(Message.Create(MessageEventNames.UNLOAD_SCENE_MSG, self, data.lastSceneName));</span><br><span class="line">            await self.HandleProgress(data, progress);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>HandlePreloadFunc:<br>场景资源预加载，同样采用计数方式，获取对应场景类型中需要预加载的AB资源列表，分别进行异步加载，全部加载后进入下一阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static async ETTask HandlePreloadFunc(this SceneChangeComponent self, SceneChangeData data, float progress)</span><br><span class="line">        &#123;</span><br><span class="line">            string nextSceneName = data.nextSceneName;</span><br><span class="line">            if (SceneConst.sceneName2Type.ContainsKey(nextSceneName))</span><br><span class="line">            &#123;</span><br><span class="line">                GameSceneType sceneType = SceneConst.sceneName2Type[nextSceneName];</span><br><span class="line">                if (self.allEvents.TryGetValue(sceneType, out ASceneChangeEvent sceneEvent))</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;string&gt; preloadNames = sceneEvent.GetPreloadResource();</span><br><span class="line">                    int count = preloadNames?.Count ?? 0;</span><br><span class="line">                    int loadedCount = 0;</span><br><span class="line">                    for (int i = 0; i &lt; count; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        string assetbundleName = $&quot;&#123;preloadNames[i]&#125;.unity3d&quot;;</span><br><span class="line">                        self.PreloadResources(assetbundleName, () =&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            ++loadedCount; //本质还是单线程协程，不需要加锁</span><br><span class="line">                        &#125;).Coroutine();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    while (loadedCount &lt; count)</span><br><span class="line">                    &#123;</span><br><span class="line">                        await TimerComponent.Instance.WaitFrameAsync();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            EventMessageComponent.Instance.SendMessage(Message.Create(MessageEventNames.LOAD_SCENE_MSG,self,data.nextSceneName));</span><br><span class="line">            await self.HandleProgress(data, progress);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>LoadingMap：<br>这一阶段加载对应场景AB包后通过SceneManager.LoadSceneAsync进行场景的异步加载，加载完成后会发布ChangeSceneFinish事件，可以通过分发执行不同具体场景名的具体函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static async ETTask LoadingMap(this SceneChangeComponent self, SceneChangeData data,float progress,Scene zoneScene)</span><br><span class="line">       &#123;</span><br><span class="line">           self.tcs = ETTask.Create(true);</span><br><span class="line">           // 加载对应的场景AB包</span><br><span class="line">           await ResourcesComponent.Instance.LoadBundleAsync($&quot;&#123;data.nextSceneName&#125;.unity3d&quot;); //加载对应场景AB包</span><br><span class="line">           // 加载map</span><br><span class="line">           self.loadMapOperation = SceneManager.LoadSceneAsync(data.nextSceneName);</span><br><span class="line">           self.loadMapOperation.allowSceneActivation = false;</span><br><span class="line">           while (self.loadMapOperation.progress&lt;0.9f)</span><br><span class="line">           &#123;</span><br><span class="line">               await TimerComponent.Instance.WaitFrameAsync();</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           await self.HandleProgress(data, progress);</span><br><span class="line">           self.loadMapOperation.allowSceneActivation = true;</span><br><span class="line">           </span><br><span class="line">           await self.tcs; //在update中进行SetResult</span><br><span class="line">           await ResourcesComponent.Instance.UnloadBundleAsync($&quot;&#123;data.nextSceneName&#125;.unity3d&quot;,false); //卸载对应场景AB包</span><br><span class="line">           //广播场景加载消息</span><br><span class="line">           Game.EventSystem.Publish(new EventType.ChangeSceneFinish()&#123;sceneName = data.nextSceneName,zoneScene = zoneScene&#125;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>根据具体函数名的函数分发：<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302175628741.png" alt="image-20220302175628741"></p></li><li><p>HandleEnterSceneFunc<br>与HandleExitSceneFunc同理，处理对应场景类型的Enter函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static async ETTask HandleEnterSceneFunc(this SceneChangeComponent self, SceneChangeData data,Scene zoneScene,float progress)</span><br><span class="line">        &#123;</span><br><span class="line">            string nextSceneName = data.nextSceneName;</span><br><span class="line">            if (SceneConst.sceneName2Type.ContainsKey(nextSceneName))</span><br><span class="line">            &#123;</span><br><span class="line">                GameSceneType sceneType = SceneConst.sceneName2Type[nextSceneName];</span><br><span class="line">                //找到对应分发函数</span><br><span class="line">                if (self.allEvents.TryGetValue(sceneType, out ASceneChangeEvent sceneEvent))</span><br><span class="line">                &#123;</span><br><span class="line">                    await sceneEvent.OnEnterScene(zoneScene);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            await self.HandleProgress(data, progress);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>DisposeLoadingUI<br>销毁对应的loadingUI界面，场景转换流程结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static async ETTask DisposeLoadingUI(this SceneChangeComponent self, SceneChangeData data)</span><br><span class="line">        &#123;</span><br><span class="line">            if (data.dlgLoading != null)</span><br><span class="line">            &#123;</span><br><span class="line">                //LoadingUI淡出</span><br><span class="line">                data.dlgLoading.SetLoadingProgress(1f); //使得进度条充满</span><br><span class="line">                CanvasGroup canvasGroup = data.dlgLoading.View.uiTransform.GetComponent&lt;CanvasGroup&gt;();</span><br><span class="line">                canvasGroup.alpha = 1f;</span><br><span class="line">                await UIEffectHelper.FadeOut(canvasGroup, 0f, 1f, null, () =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    UIComponent.Instance.CloseWindow&lt;DlgLoading&gt;();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="场景Additive加载流程"><a href="#场景Additive加载流程" class="headerlink" title="场景Additive加载流程"></a>场景Additive加载流程</h2><ul><li>采取AB包方式进行加载，先进行场景AB包的异步加载，随后执行SceneManager.LoadSceneAsync的场景异步加载</li><li>在场景加载完毕后异步卸载场景AB包</li></ul><h3 id="具体函数-1"><a href="#具体函数-1" class="headerlink" title="具体函数"></a>具体函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//MARKER:场景Addtive异步加载</span><br><span class="line">        public static async ETTask LoadSceneAddtive(this SceneChangeComponent self, string sceneName,Scene zoneScene)</span><br><span class="line">        &#123;</span><br><span class="line">            await ResourcesComponent.Instance.LoadBundleAsync($&quot;&#123;sceneName&#125;.unity3d&quot;);</span><br><span class="line"></span><br><span class="line">            self.tcs = ETTask.Create(true);</span><br><span class="line">            self.loadMapOperation = SceneManager.LoadSceneAsync(sceneName, LoadSceneMode.Additive);</span><br><span class="line">            self.loadMapOperation.allowSceneActivation = true;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            await self.tcs;</span><br><span class="line">            </span><br><span class="line">            await ResourcesComponent.Instance.UnloadBundleAsync($&quot;&#123;sceneName&#125;.unity3d&quot;,false); </span><br><span class="line">            //加载光照信息数据</span><br><span class="line">            ResourcesComponent resourcesComponent=Game.Scene.GetComponent&lt;ResourcesComponent&gt;();</span><br><span class="line">            await resourcesComponent.LoadBundleAsync(&quot;scenedata.unity3d&quot;);</span><br><span class="line">            LightMapPrefab prefab=resourcesComponent.GetAsset(&quot;scenedata.unity3d&quot;, $&quot;&#123;sceneName&#125;_Data&quot;) as LightMapPrefab;</span><br><span class="line">            if (prefab != null) </span><br><span class="line">            &#123;</span><br><span class="line">                prefab.LoadLightMap();</span><br><span class="line">            &#125;</span><br><span class="line">            await resourcesComponent.UnloadBundleAsync(&quot;scenedata.unity3d&quot;,false);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            Game.EventSystem.Publish(new EventType.AddtiveSceneFinish() &#123; sceneName = sceneName, zoneScene = zoneScene &#125;);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="碰到问题以及解决办法"><a href="#碰到问题以及解决办法" class="headerlink" title="碰到问题以及解决办法"></a>碰到问题以及解决办法</h3><p>碰到的问题主要在于用additive加载的场景并没有保留其对应的全局光照信息以及光照贴图，因此我对Unity的Editor进行了拓展，用LightMapPrefab的ScriptableObject存储全局光照信息，并在Scene/Save LightMapData中进行了选项拓展，在Additive加载完成后进行全局光照等信息的恢复。</p><ul><li><p>LightMapPrefab类：<br>主要是对光照信息、天空盒、全局光照颜色/模式等进行存储</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public class LightMapPrefab:ScriptableObject</span><br><span class="line">    &#123;</span><br><span class="line">        [SerializeField]</span><br><span class="line">        public LightmapsMode mode;</span><br><span class="line">        [SerializeField]</span><br><span class="line">        public Texture2D[] lightmapColor, lightmapDir;</span><br><span class="line"></span><br><span class="line">        [SerializeField]</span><br><span class="line">        public Material skyBoxMat;</span><br><span class="line"></span><br><span class="line">        [SerializeField]</span><br><span class="line">        public Color ambientColor;</span><br><span class="line"></span><br><span class="line">        [SerializeField]</span><br><span class="line">        public AmbientMode ambientMode;</span><br><span class="line">        </span><br><span class="line">        public LightMapPrefab()</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public void SaveLightMap()</span><br><span class="line">        &#123;</span><br><span class="line">            this.mode = LightmapSettings.lightmapsMode;</span><br><span class="line">            this.lightmapColor = null;</span><br><span class="line">            this.lightmapDir = null;</span><br><span class="line"></span><br><span class="line">            if (LightmapSettings.lightmaps != null &amp;&amp; LightmapSettings.lightmaps.Length &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                int l = LightmapSettings.lightmaps.Length;</span><br><span class="line">                this.lightmapColor = new Texture2D[l];</span><br><span class="line">                this.lightmapDir = new Texture2D[l];</span><br><span class="line">                for (int i = 0; i &lt; l; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    this.lightmapColor[i] = LightmapSettings.lightmaps[i].lightmapColor;</span><br><span class="line">                    this.lightmapDir[i] = LightmapSettings.lightmaps[i].lightmapDir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.skyBoxMat = RenderSettings.skybox;</span><br><span class="line">            this.ambientColor = RenderSettings.ambientLight;</span><br><span class="line">            this.ambientMode = RenderSettings.ambientMode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void LoadLightMap()</span><br><span class="line">        &#123;</span><br><span class="line">            LightmapSettings.lightmapsMode = this.mode;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            int l1 = (this.lightmapDir == null)? 0 : this.lightmapDir.Length;</span><br><span class="line">            int l2 = (this.lightmapColor == null)? 0 : this.lightmapColor.Length;</span><br><span class="line">            </span><br><span class="line">            int l = Mathf.Max(l1, l2);</span><br><span class="line">            LightmapData[] lightmaps = new LightmapData[l];</span><br><span class="line">            for (int i = 0; i &lt; l; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                lightmaps[i] = new LightmapData();</span><br><span class="line">                if (i &lt; l1)</span><br><span class="line">                &#123;</span><br><span class="line">                    lightmaps[i].lightmapDir = this.lightmapDir[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (i &lt; l2)</span><br><span class="line">                &#123;</span><br><span class="line">                    lightmaps[i].lightmapColor = this.lightmapColor[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            LightmapSettings.lightmaps = lightmaps;</span><br><span class="line"></span><br><span class="line">            RenderSettings.skybox = this.skyBoxMat;</span><br><span class="line">            RenderSettings.ambientMode = this.ambientMode;</span><br><span class="line">            RenderSettings.ambientLight = this.ambientColor;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Scene/Save LightMapData 拓展</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static class SceneEditorExpand</span><br><span class="line">    &#123;</span><br><span class="line">        public static string mapDataSavePath = &quot;Assets/Bundles/SceneData&quot;;</span><br><span class="line">        public static string assetBundleName = &quot;scenedata.unity3d&quot;;</span><br><span class="line">        </span><br><span class="line">        [MenuItem(&quot;Scene/Save LightMapData&quot;)]</span><br><span class="line">        static public void SaveSceneMapData()</span><br><span class="line">        &#123;</span><br><span class="line">            LightMapPrefab lightMapPrefab = ScriptableObject.CreateInstance&lt;LightMapPrefab&gt;();</span><br><span class="line">            lightMapPrefab.SaveLightMap();</span><br><span class="line">            </span><br><span class="line">            string path=mapDataSavePath+$&quot;/&#123;SceneManager.GetActiveScene().name&#125;_Data.asset&quot;;</span><br><span class="line">            AssetDatabase.CreateAsset(lightMapPrefab,path);</span><br><span class="line">            AssetDatabase.SaveAssets();</span><br><span class="line"></span><br><span class="line">            AssetImporter importer = AssetImporter.GetAtPath(path);</span><br><span class="line">            importer.assetBundleName = assetBundleName;</span><br><span class="line"></span><br><span class="line">            AssetDatabase.Refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="具体调用方式"><a href="#具体调用方式" class="headerlink" title="具体调用方式"></a>具体调用方式</h2><p>​        动态在zoneScene中加入SceneChangeComponent组件异步执行场景转换流程，结束后销毁组件</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302180142669.png" alt="image-20220302180142669"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> ET </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ET的回合制战棋-技能部分</title>
      <link href="/2022/03/02/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E5%9B%9E%E5%90%88%E5%88%B6%E6%88%98%E6%A3%8B-%E6%8A%80%E8%83%BD%E9%83%A8%E5%88%86/"/>
      <url>/2022/03/02/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E5%9B%9E%E5%90%88%E5%88%B6%E6%88%98%E6%A3%8B-%E6%8A%80%E8%83%BD%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        目前技能设计大类分为普通技能和终结技，且技能物件都基于BaseSkillItem，两种的思路都会在之后进行介绍，同时也会介绍技能的具体生命周期与针对服务器/客户端双端使用的函数分发处理。</p><h2 id="终结技"><a href="#终结技" class="headerlink" title="终结技"></a>终结技</h2><p>​        因为考虑到终结技需要营造出的效果，需要配合相机Animation、受击方Animation、音效、UI显示、特效生成的情况。这时就想到了timeline这种方式，而将具体的伤害数值处理延后到Timeline播放之后。</p><h3 id="Timeline轨道拓展"><a href="#Timeline轨道拓展" class="headerlink" title="Timeline轨道拓展"></a>Timeline轨道拓展</h3><p>​        根据具体的使用情况，我拓展了四类轨道，AnimationValueTrack、EffectTrack、TransformTrack、UITrack</p><ul><li>Timeline的本质是通过TrackAsset创建出对应的PlayableGraph（内含多种Playable），而后进行通过PlayableDirector进行播放</li><li>对Timeline中Track的拓展需要进行TrackAsset（轨道文件）、PlayableAsset（轨道内文件）、PlayableBehaviour（轨道内文件在PlayableGraph播放时的具体回调，具有OnGraphStart，OnBehaviourPlay、OnBehaviourPause等多种生命周期函数）</li></ul><h4 id="AnimationValueTrack"><a href="#AnimationValueTrack" class="headerlink" title="AnimationValueTrack"></a>AnimationValueTrack</h4><ul><li><p>主要是可以对多个Animator的Parameter同时进行设置，采用AnimatorValues的ScriptableObject对需要操作的Animators进行存储，并且可以将trackAsset中绑定的AnimatorValues传递给在这个track中的所有PlayableAsset。</p></li><li><p>具体的Behaviour关键周期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public override void OnBehaviourPlay(Playable playable, FrameData info)</span><br><span class="line">&#123;</span><br><span class="line">    if (!this.isAlreadyPlay)</span><br><span class="line">    &#123;</span><br><span class="line">        this.SetAnimatorsParams(this.animatorValues,this.beginAnimatorParam);</span><br><span class="line">        this.isAlreadyPlay = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override void OnBehaviourPause(Playable playable, FrameData info)</span><br><span class="line">&#123;</span><br><span class="line">    if (this.isAlreadyPlay)</span><br><span class="line">    &#123;</span><br><span class="line">        this.SetAnimatorsParams(this.animatorValues,this.endAnimatorParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可在Timeline的PlayableAsset中设置其触发的Parameter<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302185233638.png" alt="image-20220302185233638"></p></li></ul><h4 id="EffectTrack"><a href="#EffectTrack" class="headerlink" title="EffectTrack"></a>EffectTrack</h4><ul><li><p>用于动态加载特效AB包并生成特效，在对应PlayableAsset结束时会进行特效的回收和销毁</p></li><li><p>支持对象池生成</p></li><li><p>可获取同Timline中其他轨道的binding GameObject，并获取其子对象作为生成位置参照</p></li><li><p>Track文件展示<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302191132624.png" alt="image-20220302191132624"></p></li><li><p>PlayableAsset展示<br>分为三种生成模式，对应位置/绑定为子物体/参照物偏移</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302191206323.png" alt="image-20220302191206323"></p></li></ul><h4 id="TransformTrack"><a href="#TransformTrack" class="headerlink" title="TransformTrack"></a>TransformTrack</h4><ul><li>作为Transform的暂存轨道，可以动态设置Binding GameObject的transform位置</li><li>主要是为了记录技能释放目标点</li></ul><h4 id="UITrack"><a href="#UITrack" class="headerlink" title="UITrack"></a>UITrack</h4><ul><li><p>作为UI消息分发轨道，通知DlgShowDmg的UI界面进行终结技伤害的更新显示</p></li><li><p>轨道内的PlayableAsset通过其对应的APlayableAssetBuilder进行构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[PlayableAssetBuilderAttribute(typeof(UIDamageAsset))]</span><br><span class="line">    public class UIDamageBuilder:APlayableAssetBuilder</span><br><span class="line">    &#123;</span><br><span class="line">        public override void BuildData(TimelineComponent timelineCompoent, PlayableAsset playableAsset, params object[] _params)</span><br><span class="line">        &#123;</span><br><span class="line">            UIDamageAsset asset = playableAsset as UIDamageAsset;</span><br><span class="line">            asset._DamageAction += () =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                EventMessageComponent.Instance.SendMessage(MessageEventNames.UPDATE_DAMAGE_MSG, timelineCompoent, (float)_params[0]); //发布UI信息更新通知</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Timeline的builder构造模式"><a href="#Timeline的builder构造模式" class="headerlink" title="Timeline的builder构造模式"></a>Timeline的builder构造模式</h3><p>​        上面的许多Timeline都需要在调用的时候动态设置其binding GameObject 与相关回调函数，因此对于timeline的构造我采用了builder的方式</p><ul><li><p>在TimelineComponent组件的awake过程中会收集所有打上TrackAssetBuilderAttribute和PlayableAssetBuilderAttribute的分发抽象类，在需要对对应的asset进行处理时分发</p><p>Builder加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void LoadBuilder(this TimelineComponent self)</span><br><span class="line">        &#123;</span><br><span class="line">            var builders = Game.EventSystem.GetTypes(typeof (TrackAssetBuilderAttribute));</span><br><span class="line">            foreach (var type in builders)</span><br><span class="line">            &#123;</span><br><span class="line">                object[] attrs = type.GetCustomAttributes(typeof (TrackAssetBuilderAttribute), false);</span><br><span class="line">                if (attrs.Length == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                TrackAssetBuilderAttribute builderAttribute = attrs[0] as TrackAssetBuilderAttribute;</span><br><span class="line">                ATrackAssetBuilder builder = Activator.CreateInstance(type) as ATrackAssetBuilder;</span><br><span class="line">                self.type2TrackAssetBuilder.Add(builderAttribute.trackBehaviourType,builder);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            builders = Game.EventSystem.GetTypes(typeof (PlayableAssetBuilderAttribute));</span><br><span class="line">            foreach (var type in builders)</span><br><span class="line">            &#123;</span><br><span class="line">                object[] attrs = type.GetCustomAttributes(typeof (PlayableAssetBuilderAttribute), false);</span><br><span class="line">                if (attrs.Length == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                PlayableAssetBuilderAttribute builderAttribute = attrs[0] as PlayableAssetBuilderAttribute;</span><br><span class="line">                APlayableAssetBuilder builder = Activator.CreateInstance(type) as APlayableAssetBuilder;</span><br><span class="line">                self.type2PlayableAssetBuilder.Add(builderAttribute.trackBehaviourType,builder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>以某Timeline中的UITrack作为例子，在对TrackAsset调用BuildTrackAsset并传入对应参数时会自动分发对应的builder函数对其进行构造操作</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302192424642.png" alt="image-20220302192424642"></p><p>UITrack对应的TrackAssetBuilder:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[TrackAssetBuilderAttribute(typeof(UITrack))]</span><br><span class="line">public class UITrackBuilder:ATrackAssetBuilder</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 构造数据</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;timelineComponent&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;behaviour&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;_params&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public override void BuildData(TimelineComponent timelineComponent, TrackAsset trackAsset, params object[] _params)</span><br><span class="line">    &#123;</span><br><span class="line">        UITrack uiTrack = trackAsset as UITrack;</span><br><span class="line">        //获取所有clips</span><br><span class="line">        List&lt;TimelineClip&gt; list= new List&lt;TimelineClip&gt;(uiTrack.GetClips());</span><br><span class="line">        int count = 0;</span><br><span class="line">        float[] damages = _params[0] as float[];</span><br><span class="line">        foreach (var clip in list)</span><br><span class="line">        &#123;</span><br><span class="line">            if (clip.asset is UIDamageAsset asset)</span><br><span class="line">            &#123;</span><br><span class="line">                timelineComponent.BuildPlayableAsset(asset,damages[count++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h2><p>​        对技能的设计考虑到了client/Server的双端代码共用，因此采取了将技能拆封为Effect和Action两部分函数周期的方式。</p><ul><li>离线模式下，client同时执行技能的Effect和Action生命周期</li><li>在线模式下，client仅执行Effect生命周期，关键的Action生命周期交由server进行处理，保证服务器的权威性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> ET </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ET的回合制战棋-网络部分</title>
      <link href="/2022/03/02/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E5%9B%9E%E5%90%88%E5%88%B6%E6%88%98%E6%A3%8B-%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/"/>
      <url>/2022/03/02/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E5%9B%9E%E5%90%88%E5%88%B6%E6%88%98%E6%A3%8B-%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        过年时间因为个人的某些原因所以毕设搁置了一下，现在也慢慢重新完善后续功能。网络部分依旧借助了ET框架的网络部分，采取了双端的设计方案，尽可能将Client和Server端的相同部分通过Link方式关联起来，实现了部分的双端互通。</p><p>​        </p><h2 id="网络部分流程介绍"><a href="#网络部分流程介绍" class="headerlink" title="网络部分流程介绍"></a>网络部分流程介绍</h2><p>​        总的流程基本可以分为四个部分，分别为<span style="color:red">登入流程、地图服进入流程、匹配流程、游戏流程</span>，下面对其分别进行介绍。</p><h3 id="登入流程："><a href="#登入流程：" class="headerlink" title="登入流程："></a>登入流程：</h3><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%E7%99%BB%E5%85%A5%E6%B5%81%E7%A8%8B.drawio.png" alt="网络部分登入流程.drawio"></p><h4 id="关键部分代码："><a href="#关键部分代码：" class="headerlink" title="关键部分代码："></a>关键部分代码：</h4><p>​        主要体现在登入流程实际上是客户端与服务器中两个分布式服务器的分别交互，先通过C2R_Login在<span style="color:red">验证服</span>中获取到分配的网关登入Key后再通过实际的C2G_LoginGate在<span style="color:red">网关服</span>实现登入操作。</p><ul><li><p>验证服网关分配和具体Key获取，验证服在接收到C2R_Login协议后其实也在内部进行的服务器通讯操作，在内网向配到到的网关服传递C2R_GetLoginKey协议进行Key申请</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected override async ETTask Run(Session session, C2R_Login request, R2C_Login response, Action reply)</span><br><span class="line">&#123;</span><br><span class="line">// 随机分配一个Gate</span><br><span class="line">StartSceneConfig config = RealmGateAddressHelper.GetGate(session.DomainZone());</span><br><span class="line">Log.Debug($&quot;gate address: &#123;MongoHelper.ToJson(config)&#125;&quot;);</span><br><span class="line"></span><br><span class="line">// 向gate请求一个key,客户端可以拿着这个key连接gate</span><br><span class="line">G2R_GetLoginKey g2RGetLoginKey = (G2R_GetLoginKey) await ActorMessageSenderComponent.Instance.Call(</span><br><span class="line">config.InstanceId, new R2G_GetLoginKey() &#123;Account = request.Account&#125;);</span><br><span class="line"></span><br><span class="line">response.Address = config.OuterIPPort.ToString();</span><br><span class="line">response.Key = g2RGetLoginKey.Key;</span><br><span class="line">response.GateId = g2RGetLoginKey.GateId;</span><br><span class="line">reply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>网关服的Key校验以及登入，在每个网关服scene中具有<span style="color:blue">GateSessionKeyComponent</span>组件存储对应的分配Key对应的account，通过客户端C2G_LoginGate中传入的key在组件中进行验证搜索获取到对应的account后在<span style="color:red">PlayerComponent</span>组件中加入Player组件作为已登入角色信息的存储组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected override async ETTask Run(Session session, C2G_LoginGate request, G2C_LoginGate response, Action reply)</span><br><span class="line">&#123;</span><br><span class="line">Scene scene = session.DomainScene();</span><br><span class="line">string account = scene.GetComponent&lt;GateSessionKeyComponent&gt;().Get(request.Key);</span><br><span class="line">if (account == null)</span><br><span class="line">&#123;</span><br><span class="line">response.Error = ErrorCore.ERR_ConnectGateKeyError;</span><br><span class="line">response.Message = &quot;Gate key验证失败!&quot;;</span><br><span class="line">reply();</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session.RemoveComponent&lt;SessionAcceptTimeoutComponent&gt;();</span><br><span class="line"></span><br><span class="line">PlayerComponent playerComponent = scene.GetComponent&lt;PlayerComponent&gt;();</span><br><span class="line">Player player = playerComponent.AddChild&lt;Player, string&gt;(account);</span><br><span class="line">playerComponent.Add(player);</span><br><span class="line">session.AddComponent&lt;SessionPlayerComponent&gt;().PlayerId = player.Id;</span><br><span class="line">session.AddComponent&lt;MailBoxComponent, MailboxType&gt;(MailboxType.GateSession);</span><br><span class="line"></span><br><span class="line">response.PlayerId = player.Id;</span><br><span class="line">reply();</span><br><span class="line">await ETTask.CompletedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="地图服进入流程："><a href="#地图服进入流程：" class="headerlink" title="地图服进入流程："></a>地图服进入流程：</h3><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%E5%9C%B0%E5%9B%BE%E6%9C%8D%E8%BF%9B%E5%85%A5%E6%B5%81%E7%A8%8B_.drawio.png" alt="网络部分地图服进入流程_.drawio"></p><h4 id="关键部分代码：-1"><a href="#关键部分代码：-1" class="headerlink" title="关键部分代码："></a>关键部分代码：</h4><p>​        主要是服务器对C2G_EnterMap协议的处理以及客户端的SceneChangeComponent实现具体场景切换流程</p><ul><li><p>服务器部分在ET6.0的正式版更新中实现了<span style="color:red">登入和地图传送的统一</span>，将登陆作为在一个动态创建的mapScene中向真正的MapScene传送的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected override async ETTask Run(Session session, C2G_EnterMap request, G2C_EnterMap response, Action reply)</span><br><span class="line">&#123;</span><br><span class="line">Player player = session.GetComponent&lt;SessionPlayerComponent&gt;().GetMyPlayer();</span><br><span class="line"></span><br><span class="line">// 在Gate上动态创建一个Map Scene，把Unit从DB中加载放进来，然后传送到真正的Map中，这样登陆跟传送的逻辑就完全一样了</span><br><span class="line">GateMapComponent gateMapComponent = player.AddComponent&lt;GateMapComponent&gt;();</span><br><span class="line">gateMapComponent.Scene = await SceneFactory.Create(gateMapComponent, &quot;GateMap&quot;, SceneType.Map);</span><br><span class="line"></span><br><span class="line">Scene scene = gateMapComponent.Scene;</span><br><span class="line"></span><br><span class="line">// 这里可以从DB中加载Unit</span><br><span class="line">Unit unit = UnitFactory.Create(scene, player.Id, GameUnitType.Player);</span><br><span class="line">unit.AddComponent&lt;UnitGateComponent, long&gt;(session.InstanceId);</span><br><span class="line"></span><br><span class="line">StartSceneConfig startSceneConfig = StartSceneConfigCategory.Instance.GetBySceneName(session.DomainZone(), &quot;Main&quot;);</span><br><span class="line">response.MyId = player.Id;</span><br><span class="line">reply();</span><br><span class="line"></span><br><span class="line">// 开始传送</span><br><span class="line">await TransferHelper.Transfer(unit, startSceneConfig.InstanceId, startSceneConfig.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SceneChangeComponent中的具体场景切换流程<br>这个会单独再开一篇来介绍对ET自带的SceneChangeComponent的改进<br>链接：<a href="https://songofwing.site/2022/03/02/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E5%9B%9E%E5%90%88%E5%88%B6%E6%88%98%E6%A3%8B-%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E9%83%A8%E5%88%86/">基于ET的回合制战棋–场景切换部分</a></p></li></ul><h3 id="匹配流程："><a href="#匹配流程：" class="headerlink" title="匹配流程："></a>匹配流程：</h3><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D%E6%B5%81%E7%A8%8B.drawio.png" alt="网络部分匹配流程.drawio"></p><h4 id="关键部分代码：-2"><a href="#关键部分代码：-2" class="headerlink" title="关键部分代码："></a>关键部分代码：</h4><p>主要是对房间满人的判断以及进行资源预加载信息的处理</p><ul><li><p>因为对于对局来说，终结技的特效资源AB包加载是实时的，如果全都在释放时动态加载会进行卡顿，因此我的处理方式是在server中对所有场上角色进行Id整理，在匹配成功时发送给所有房间内客户端，，这样就能在战斗场景切换时进行部分资源的预加载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> //房间满人</span><br><span class="line">if (room!=null&amp;&amp;!room.IsFree())</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;NetUnitInfo&gt; netUnitInfos = new List&lt;NetUnitInfo&gt;();</span><br><span class="line">    foreach (var _unit in room.roomPlayerUnits)</span><br><span class="line">    &#123;</span><br><span class="line">        NetUnitInfo unitInfo = new NetUnitInfo();</span><br><span class="line">        unitInfo.UnitId = _unit.Id;</span><br><span class="line">        netUnitInfos.Add(unitInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //MARKER：进行资源预加载信息</span><br><span class="line">    M2C_PreloadResource m2CPreload = new M2C_PreloadResource();</span><br><span class="line">    HashSet&lt;int&gt; characterSet = new HashSet&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">    foreach (var _unit in room.roomPlayerUnits)</span><br><span class="line">    &#123;</span><br><span class="line">        DataComponent data = _unit.GetComponent&lt;DataComponent&gt;();</span><br><span class="line">        foreach (var characterId in data.selectCharacters)</span><br><span class="line">        &#123;</span><br><span class="line">            characterSet.Add(characterId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m2CPreload.characterId = characterSet.ToList();</span><br><span class="line">    MessageHelper.RoomBroadcast(room.DomainScene(),room.roomId,m2CPreload);</span><br><span class="line"></span><br><span class="line">    //MARKER:广播匹配成功消息</span><br><span class="line">    int index = -1;</span><br><span class="line">    foreach (var _unit in room.roomPlayerUnits)</span><br><span class="line">    &#123;</span><br><span class="line">        //单播</span><br><span class="line">        M2C_MatchSuccess m2CMatchSuccess = new M2C_MatchSuccess();</span><br><span class="line">        m2CMatchSuccess.RoomId = room.roomId;</span><br><span class="line">        m2CMatchSuccess.UnitIndex = ++index;</span><br><span class="line">        m2CMatchSuccess.UnitInfo = netUnitInfos;</span><br><span class="line">        MessageHelper.SendToClient(_unit,m2CMatchSuccess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="游戏流程："><a href="#游戏流程：" class="headerlink" title="游戏流程："></a>游戏流程：</h3><p>场景加载/预备/回合流程：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B.drawio.png" alt="网络部分游戏流程.drawio"></p><p>移动过程：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%E7%A7%BB%E5%8A%A8%E6%B5%81%E7%A8%8B.drawio.png" alt="网络部分移动流程.drawio"></p><p>技能过程：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%E6%8A%80%E8%83%BD%E6%B5%81%E7%A8%8B.drawio.png" alt="网络部分技能流程.drawio"></p><h4 id="关键部分代码：-3"><a href="#关键部分代码：-3" class="headerlink" title="关键部分代码："></a>关键部分代码：</h4><ul><li><p>回合加载流程实现了网络同步，在所有人未加载完成时不会进入战斗场景</p></li><li><p>动态插入移除InputComponent实现不同情况下的网络同步和网络输入，对于同步方只需要插入NetInputComponent即可，对于输入方则需要PersonInputComponent</p><p>同时对于NetInputComponent进行队列的暂存和转发，保证在网络延迟情况下按照消息接收顺序进行操作处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void Update(this NetInputComponent self)</span><br><span class="line">&#123;</span><br><span class="line">    if (self.NetOperateList.Count &gt; 0&amp;&amp;RoundMgrComponent.Instance.roundState == RoundState.Wait)</span><br><span class="line">    &#123;</span><br><span class="line">        NetInputMessage message = self.NetOperateList.Peek();</span><br><span class="line">        self.HandleNetEvent(message);</span><br><span class="line">        self.NetOperateList.Dequeue();</span><br><span class="line">        message.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于技能方面实现了双端代码共用，在客户端中网络仅需要进行特效展示，固我将每个技能分为了Action和Effect两种事件</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302161920107.png" alt="image-20220302161920107"></p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302162018891.png" alt="image-20220302162018891"></p></li></ul><p>  ​        <img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220302162044654.png" alt="image-20220302162044654"></p><ul><li><p>在离线状态下客户端同时处理Action和Effect两种特效类型</p></li><li><p>在网络状态下客户端仅需处理Effect类型，而Action类型交由服务器进行处理</p></li><li><p><span style="color:red">PS：技能部分后续会再开一篇来说明</span></p></li></ul><h4 id="效果展示："><a href="#效果展示：" class="headerlink" title="效果展示："></a>效果展示：</h4><p>移动同步：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E7%A7%BB%E5%8A%A8.gif" alt="移动"></p><p>技能同步：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E6%99%AE%E9%80%9A%E6%8A%80%E8%83%BD.gif" alt="普通技能"></p><p>终结技同步：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E7%BB%88%E7%BB%93%E6%8A%802.gif" alt="终结技2"></p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> ET </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EGUI详解-LoopScrollRect解析</title>
      <link href="/2021/12/22/EGUI%E8%AF%A6%E8%A7%A3-LoopScrollRect%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/12/22/EGUI%E8%AF%A6%E8%A7%A3-LoopScrollRect%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    在毕设demo中想要实现一个角色选择界面，其中是需要用到类似背包的GridLayoutGroup组件的，同时之前的EGUI文章中也没对其中的LoopHorizontalScrollRect和LoopVerticalScrollRect进行解析，所以也趁这个机会看一下源码，且其对于背包系统的优化来说对很多类型的游戏都是通用的。</p><h1 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h1><p>​    对于抽象类LoopScrollRect来说，其基于Unity官方的ScrollView进行了一定的拓展。由LoopScrollRect继承出两种滚动类型，分别为HorizontalScrollRect和VerticalScrollRect。</p><p>​    <span style="color:red">本文主要针对于其的拓展与采取的优化手段进行解析：</span></p><p>​    拓展部分的UML图（包括Item的数据存储）：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/EGUI_LoopScrollRect1.drawio.png" alt="EGUI_LoopScrollRect1.drawio"></p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>对于数据的存储主要是通过<span style="color:red">LoopScrollPrefabSource</span>和<span style="color:red">LoopScrollDataSource</span>，前者主要是对UIPrefab源，后者是对其具体存储数据源</p><h3 id="LoopScrollPrefabSource"><a href="#LoopScrollPrefabSource" class="headerlink" title="LoopScrollPrefabSource"></a>LoopScrollPrefabSource</h3><ul><li>内部存储了对应UIPrefab的prefabName，通过AB包的方式加载，并生成对应的对象池Pool，其Pool的GameObject存放在Global/PoolRoot中。</li><li>具体封装了GetObject()和ReturnObject(Transform go,bool isDestroy = false)</li></ul><h3 id="LoopScrollDataSource"><a href="#LoopScrollDataSource" class="headerlink" title="LoopScrollDataSource"></a>LoopScrollDataSource</h3><ul><li>scrollMoveEvent存储滑动时对应Index的Item及其Transform的Action，在LoopScrollRect的GetFromTempPool(int itemIdx)中会对池子获取到的nextItem进行data注入（即执行dataSource.ProvideData(nextItem,itemIdx)）</li><li>具有LoopScrollSendIndexSource和LoopScrollArraySource&lt;T&gt;两种继承类，两者都在ProvideData接口重写中调用scrollMoveEvent，而后者在初始化的构造函数中需要传入objectToFill作为传入参数（可供后期在ProvideData执行时拓展对objectsToFill的统一操作）。</li></ul><h2 id="滚动优化"><a href="#滚动优化" class="headerlink" title="滚动优化"></a>滚动优化</h2><h3 id="UpdateItems"><a href="#UpdateItems" class="headerlink" title="UpdateItems"></a>UpdateItems</h3><ul><li><p>对于Content来说，其内部的Item是动态进行对象池的获取和回收的。</p></li><li><p>UpdateItems在其父类LoopScrollRect中的UpdateBounds(bool updateItems = false)中调用<br>而UpdateBounds在<span style="color:red">updateItems=true</span>下的具体调用则分为以下几种情况：</p><ul><li>SetContentAnchoredPosition(Vector2 position),即设定Content窗口的AnchoredPosition，其具体在OnScroll(PointerEventData data)、OnDrag(PointerEventData data)、LateUpdate()中进行调用</li><li>SetNormalizedPosition(float value,int axis),即设定Content窗口的规格化NormalizedPosition，其具体在SetHorizontalNormalizedPosition(float value)、SetVerticalNormalizedPosition(float value)中进行调用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ============LoopScrollRect============</span></span><br><span class="line"><span class="comment">// Don&#x27;t do this in Rebuild</span></span><br><span class="line"><span class="keyword">if</span> (Application.isPlaying &amp;&amp; updateItems &amp;&amp; UpdateItems(m_ViewBounds,m_ContentBounds))</span><br><span class="line">&#123;</span><br><span class="line">    Canvas.ForceUpdateCanvases();</span><br><span class="line">    m_ContentBounds = GetBounds();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ============LoopScrollRect============</span></span><br></pre></td></tr></table></figure></li><li><p>UpdateItems具体的实现主要分为五种情况（以LoopVerticalScrollRect为例子，Horizontal类似）</p><ul><li><p>在一帧内滑动超过一页，判断条件为（viewBounds.min.y &gt; contentBounds.max.y &amp;&amp; itemTypeEnd &gt; itemTypeStart）</p><p>对应源码为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (viewBounds.min.y &gt; contentBounds.max.y &amp;&amp; itemTypeEnd &gt; itemTypeStart)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">float</span> currentSize = contentBounds.size.y;</span><br><span class="line">                <span class="built_in">float</span> elementSize = (currentSize - contentSpacing * (CurrentLines - <span class="number">1</span>)) / CurrentLines;</span><br><span class="line">                ReturnToTempPool(<span class="literal">false</span>, itemTypeEnd - itemTypeStart);</span><br><span class="line">                itemTypeEnd = itemTypeStart;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> offsetCount = Mathf.FloorToInt((viewBounds.min.y - contentBounds.max.y) / (elementSize + contentSpacing));</span><br><span class="line">                <span class="keyword">if</span> (totalCount &gt;= <span class="number">0</span> &amp;&amp; itemTypeStart - offsetCount * contentConstraintCount &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    offsetCount = Mathf.FloorToInt((<span class="built_in">float</span>)(itemTypeStart) / contentConstraintCount);</span><br><span class="line">                &#125;</span><br><span class="line">                itemTypeStart -= offsetCount * contentConstraintCount;</span><br><span class="line">                <span class="keyword">if</span> (totalCount &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    itemTypeStart = Mathf.Max(itemTypeStart, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                itemTypeEnd = itemTypeStart;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">float</span> offset = offsetCount * (elementSize + contentSpacing);</span><br><span class="line">                content.anchoredPosition += <span class="keyword">new</span> Vector2(<span class="number">0</span>, offset + (reverseDirection ? currentSize : <span class="number">0</span>));</span><br><span class="line">                contentBounds.center += <span class="keyword">new</span> Vector3(<span class="number">0</span>, offset + currentSize / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">                contentBounds.size = Vector3.zero;</span><br><span class="line"></span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>计算出elementSize，即每一行Item的size.y大小</li><li>将当前的所有Item都放进待删除的脏池子中（翻页情况）</li><li>计算出offsetCount，即滑动偏移的行数，并与实际最多可偏移行数比较得出最终offsetCount</li><li>计算出最终需要偏移的offset，同时将content的anchoredPosition向上方移动<span style="color:red">offset</span>，设置其包围盒的中心点与anchoredPosition重合，并重置包围盒大小</li></ul></li><li><p>显示包围盒的y的最小值大于内容包围盒的y的最小值+Item判定大小，判断条件为(viewBounds.min.y&gt;contentBounds.min.y+threshold)，<span style="color:red">threshold为item的boundSize的1.5倍，</span>用一张图来方便观察。<br>红色为view，蓝色为content</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211225183335276.png" alt="image-20211225183335276"><br>进行代码分析：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (viewBounds.min.y &gt; contentBounds.min.y + threshold)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> size = DeleteItemAtEnd(), totalSize = size;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span> &amp;&amp; viewBounds.min.y &gt; contentBounds.min.y + threshold + totalSize)</span><br><span class="line">    &#123;</span><br><span class="line">        size = DeleteItemAtEnd();</span><br><span class="line">        totalSize += size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totalSize &gt; <span class="number">0</span>)</span><br><span class="line">        changed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除末尾的Item并计算得出删除的size，对totalSize进行赋值</li><li>判断删除后边界大小是否满足viewBounds.min.y+threshold+totalSize&gt;viewBounds.min.y情况，若不满足则继续删除末尾Item并累计删除的size</li><li>如果删除的totalSize&gt;0，则将changed设为true，在函数的末尾进行脏数据的删除和清空</li></ul></li><li><p>显示包围盒的y最大值小于内容包围盒的y最大值-Item判定大小，判断条件为(viewBounds.max.y &lt; contentBounds.max.y - threshold)<br>红色为viewBounds，蓝色为contentBounds<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211225185359966.png" alt="image-20211225185359966"></p><p>进行代码分析：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (viewBounds.max.y &lt; contentBounds.max.y - threshold)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">float</span> size = DeleteItemAtStart(), totalSize = size;</span><br><span class="line">               <span class="keyword">while</span> (size &gt; <span class="number">0</span> &amp;&amp; viewBounds.max.y &lt; contentBounds.max.y - threshold - totalSize)</span><br><span class="line">               &#123;</span><br><span class="line">                   size = DeleteItemAtStart();</span><br><span class="line">                   totalSize += size;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (totalSize &gt; <span class="number">0</span>)</span><br><span class="line">                   changed = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><ul><li>删除开头的Item并得出删除Item的size，用totalSize进行存储</li><li>判断是否符合viewBounds.max.y&gt;contentBounds.max.y-threshold-totalSize,若不满足则继续删除开头的Item</li><li>如果删除的totalSize&gt;0，则将changed设为true，在函数的末尾进行脏数据的删除和清空</li></ul></li><li><p>显示包围盒的y最小值小于内容包围盒的y最小值，判断条件为(viewBounds.min.y&lt;contentBounds.min.y)<br>红色为viewBounds，蓝色为contentBounds<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211225190814660.png" alt="image-20211225190814660"><br>代码分析：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (viewBounds.min.y &lt; contentBounds.min.y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">float</span> size = NewItemAtEnd(), totalSize = size;</span><br><span class="line">                <span class="keyword">while</span> (size &gt; <span class="number">0</span> &amp;&amp; viewBounds.min.y &lt; contentBounds.min.y - totalSize)</span><br><span class="line">                &#123;</span><br><span class="line">                    size = NewItemAtEnd();</span><br><span class="line">                    totalSize += size;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (totalSize &gt; <span class="number">0</span>)</span><br><span class="line">                    changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>在末尾添加Item并记录下添加的Item大小，用totalSize进行存储</li><li>判断是否符合viewBounds.min.y&gt;contentBounds.min.y-totalSize，若不满足则继续在末尾增加Item</li><li>如果删除的totalSize&gt;0，则将changed设为true，在函数的末尾进行脏数据的删除和清空</li></ul></li><li><p>显示包围盒的y最大值大于内容包围盒的y最大值，判断条件为(viewBounds.max.y&gt;contentBounds.max.y)<br>红色为viewBounds，蓝色为contentBounds<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211225192304044.png" alt="image-20211225192304044"></p><p>代码分析：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (viewBounds.max.y &gt; contentBounds.max.y)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">float</span> size = NewItemAtStart(), totalSize = size;</span><br><span class="line">               <span class="keyword">while</span> (size &gt; <span class="number">0</span> &amp;&amp; viewBounds.max.y &gt; contentBounds.max.y + totalSize)</span><br><span class="line">               &#123;</span><br><span class="line">                   size = NewItemAtStart();</span><br><span class="line">                   totalSize += size;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (totalSize &gt; <span class="number">0</span>)</span><br><span class="line">                   changed = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><ul><li>在开头添加Item并记录下添加的Item大小，用totalSize进行存储</li><li>判断是否符合viewBounds.max.y&lt;contentBounds.max.y+totalSize，若不满足则继续在开头增加Item</li><li>如果删除的totalSize&gt;0，则将changed设为true，在函数的末尾进行脏数据的删除和清空</li></ul></li></ul></li></ul><h3 id="New-Delete-ItemAt-Start-End"><a href="#New-Delete-ItemAt-Start-End" class="headerlink" title="New/Delete ItemAt Start/End"></a>New/Delete ItemAt Start/End</h3><p>​    上述的UpdateItems中，在对Item进行首尾的增删时用到了标题中的函数，我们以NewItemAtStart()与DeleteItemAtStart()为例子对函数的源码进行分析：</p><h4 id="NewItemAtStart"><a href="#NewItemAtStart" class="headerlink" title="NewItemAtStart()"></a>NewItemAtStart()</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">NewItemAtStart</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (totalCount &gt;= <span class="number">0</span> &amp;&amp; itemTypeStart - contentConstraintCount &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">float</span> size = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//逐行/列添加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; contentConstraintCount; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                itemTypeStart--;</span><br><span class="line">                RectTransform newItem = GetFromTempPool(itemTypeStart);</span><br><span class="line">                newItem.SetSiblingIndex(deletedItemTypeStart); <span class="comment">//放在待删除的ItemTypeStart，防止被ClearTempPool删除</span></span><br><span class="line">                size = Mathf.Max(GetSize(newItem), size);</span><br><span class="line">            &#125;</span><br><span class="line">            threshold = Mathf.Max(threshold, size * <span class="number">1.5f</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!reverseDirection)</span><br><span class="line">            &#123;</span><br><span class="line">                Vector2 offset = GetVector(size);</span><br><span class="line">                content.anchoredPosition += offset;</span><br><span class="line">                m_PrevPosition += offset;</span><br><span class="line">                m_ContentStartPosition += offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>对于itemTypeStart的增删是逐行/列进行的，每次增加会减少itemTypeStart(首部的Itemindex记录，用于获取信息)</li><li>实际添加的位置会根据deletedItemTypeStart调整（待删除Item的起始点，其前面所有Item都会在该帧ClearTempPool()时被删除）</li><li>在首部增加Item时需要对content的anchoredPosition进行上移，在后续GetBounds()时获取到新的包围盒</li></ul><h4 id="DeleteItemAtStart"><a href="#DeleteItemAtStart" class="headerlink" title="DeleteItemAtStart()"></a>DeleteItemAtStart()</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">float</span> <span class="title">DeleteItemAtStart</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// special case: when moving or dragging, we cannot simply delete start when we&#x27;ve reached the end</span></span><br><span class="line">            <span class="keyword">if</span> ((m_Dragging || m_Velocity != Vector2.zero) &amp;&amp; totalCount &gt;= <span class="number">0</span> &amp;&amp; itemTypeEnd &gt;= totalCount - contentConstraintCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> availableChilds = content.childCount - deletedItemTypeStart - deletedItemTypeEnd;</span><br><span class="line">            Debug.Assert(availableChilds &gt;= <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (availableChilds == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> size = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//逐行/列删除</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; contentConstraintCount; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                RectTransform oldItem = content.GetChild(deletedItemTypeStart) <span class="keyword">as</span> RectTransform;</span><br><span class="line">                size = Mathf.Max(GetSize(oldItem), size);</span><br><span class="line">                ReturnToTempPool(<span class="literal">true</span>);</span><br><span class="line">                availableChilds--;</span><br><span class="line">                itemTypeStart++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (availableChilds == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!reverseDirection)</span><br><span class="line">            &#123;</span><br><span class="line">                Vector2 offset = GetVector(size);</span><br><span class="line">                content.anchoredPosition -= offset;</span><br><span class="line">                m_PrevPosition -= offset;</span><br><span class="line">                m_ContentStartPosition -= offset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>在ReturnToTempPool(true)内部会执行deletedItemTypeStart+=1，即将待删除结点的起点向后移一位</li><li>在首部删除Item时需要对content的anchoredPosition进行下移，在后续GetBounds()时获取到新的包围盒</li></ul><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211228153308241.png" alt="image-20211228153308241"></p><h1 id="滑动效果展示"><a href="#滑动效果展示" class="headerlink" title="滑动效果展示"></a>滑动效果展示</h1><p>主要是增删Item对Content的动态anchoredPosition修改展示：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/ScrollRect.gif" alt="ScrollRect"></p>]]></content>
      
      
      <categories>
          
          <category> ET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> ET </tag>
            
            <tag> Unity框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ET的四叉树场景管理组件</title>
      <link href="/2021/12/19/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E5%9B%9B%E5%8F%89%E6%A0%91%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6/"/>
      <url>/2021/12/19/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E5%9B%9B%E5%8F%89%E6%A0%91%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    四叉树/八叉树的场景管理广泛应用于RPG类型游戏，其优点在于缩小了判断检测所需的范围，只需要通过简单的矩形的碰撞检测找到对应相交的四叉树/八叉树节点，再对节点内的Entity进行相交判断即可，而无需遍历场景内所有的物体进行碰撞检测。极大的优化了类似于MMORPG这种多人游戏的技能释放判定检测。</p><p>​    <span style="color:blue">感谢Yogi大佬提供的思路，自身在已有思路下进行了动态增加/移除四叉树中管理物体的接口拓展。</span></p><h1 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h1><ul><li>确定划分颗粒度（代表一个节点内的物体数量,一旦超过这个数量就要进行下一层的划分），最小划分范围（代表一个节点x的最小范围，小于这个范围则不再划分）</li><li>将场景中需要管理的GameObject与其Render中的Bounds通过ObjectBase类进行整合，同时因为一个Bounds可能会与四叉树的多个节点，即存储在多个QuadTreeNode种，可以用ActiveCount记录下当前判定范围下（如摄像机视椎体）与其所在QuadTreeNode碰撞的个数</li><li>将ObjectBase统一加入到AllItems的字典中，每个Objectbase对应一个ItemIndex，方便进行移除</li><li>通过split()进行划分<ul><li>对于根结点<ul><li>获取当前cubes下所有Item的MinX，MaxX，MinY，MaxY，构建出总的Bounds</li><li>将根结点划分为左上、左下、右上、右下四个区域，设定新的Bounds</li><li>遍历cubes中所有item，将item.bounds与某区域（即QuadTreeNode）Bounds交叉的Item加入到对应区域itemData中，若ItemData中的count&gt;划分颗粒度，则进行下一层递归划分</li></ul></li><li>对于子节点<ul><li>将根结点划分为左上、左下、右上、右下四个区域，设定新的Bounds</li><li>遍历cubes中所有item，将item.bounds与某区域（即QuadTreeNode）Bounds交叉的Item加入到对应区域itemData中，若ItemData中的count&gt;划分颗粒度，则进行下一层递归划分</li></ul></li></ul></li></ul><p>附上部分关键代码：</p><h2 id="节点划分："><a href="#节点划分：" class="headerlink" title="节点划分："></a>节点划分：</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 四叉树节点划分</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Split</span>(<span class="params"><span class="keyword">this</span> SceneTreeModule self</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          self.Split(self.AllItems.Values.ToList(),<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 划分递归函数</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cubes&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;parent&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Split</span>(<span class="params"><span class="keyword">this</span> SceneTreeModule self,List&lt;ObjectBase&gt; cubes, QuadTreeNode parent</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//1.求中心点位置</span></span><br><span class="line">          <span class="comment">//2.求四个子结点位置</span></span><br><span class="line">          <span class="comment">//3.求各个节点的bounds大小</span></span><br><span class="line">          QuadTreeNode Root, LT, RT, LB, RB;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 二分之一</span></span><br><span class="line">          <span class="built_in">float</span> halfX, halfZ, halfY;</span><br><span class="line">          <span class="comment">// 四分之一</span></span><br><span class="line">          <span class="built_in">float</span> quarterX, quarterZ, quarterY;</span><br><span class="line"></span><br><span class="line">          Vector3 center;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//初始生成的情况下</span></span><br><span class="line">          <span class="keyword">if</span> (parent == <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">float</span> minX = <span class="built_in">float</span>.MaxValue,</span><br><span class="line">                  minZ = <span class="built_in">float</span>.MaxValue,</span><br><span class="line">                  minY = <span class="built_in">float</span>.MaxValue,</span><br><span class="line">                  maxX = <span class="built_in">float</span>.MinValue,</span><br><span class="line">                  maxZ = <span class="built_in">float</span>.MinValue,</span><br><span class="line">                  maxY = <span class="built_in">float</span>.MinValue;</span><br><span class="line">              </span><br><span class="line">              <span class="comment">//根据当前的Tree内的Cube确定初始的Root包围盒</span></span><br><span class="line">              <span class="keyword">foreach</span> (<span class="keyword">var</span> cube <span class="keyword">in</span> cubes)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">var</span> cubeBound = cube.bounds;</span><br><span class="line">                  Vector3 boundsMin, boundsMax;</span><br><span class="line">                  boundsMin = cube.bounds.min;</span><br><span class="line">                  boundsMax = cube.bounds.max;</span><br><span class="line"></span><br><span class="line">                  minX = Mathf.Min(boundsMin.x, minX);</span><br><span class="line">                  minY = Mathf.Min(boundsMin.y, minY);</span><br><span class="line">                  minZ = Mathf.Min(boundsMin.z, minZ);</span><br><span class="line"></span><br><span class="line">                  maxX = Mathf.Max(boundsMax.x, maxX);</span><br><span class="line">                  maxY = Mathf.Max(boundsMax.y, maxY);</span><br><span class="line">                  maxZ = Mathf.Max(boundsMax.z, maxZ);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              halfX = (maxX - minX) / <span class="number">2</span>;</span><br><span class="line">              halfY = (maxY - minY) / <span class="number">2</span>;</span><br><span class="line">              halfZ = (maxZ - minZ) / <span class="number">2</span>;</span><br><span class="line">              quarterX = halfX / <span class="number">2</span>;</span><br><span class="line">              quarterY = halfY / <span class="number">2</span>;</span><br><span class="line">              quarterZ = halfZ / <span class="number">2</span>;</span><br><span class="line">              center = <span class="keyword">new</span> Vector3(minX + halfX, minY + halfY, minZ + halfZ);</span><br><span class="line"></span><br><span class="line">              self.Root = Root = self.AddChild&lt;QuadTreeNode&gt;();</span><br><span class="line">              <span class="comment">//生成包围盒</span></span><br><span class="line">              Root.Bounds = <span class="keyword">new</span> Bounds(center, <span class="keyword">new</span> Vector3(halfX, halfY, halfZ) * <span class="number">2</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//递归生成的情况下</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">var</span> halfParentSize = parent.Bounds.size / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">              halfX = halfParentSize.x;</span><br><span class="line">              halfY = halfParentSize.y ;</span><br><span class="line">              halfZ = halfParentSize.z;</span><br><span class="line">              <span class="comment">//因为是四叉树Y是不变的</span></span><br><span class="line">              quarterX = halfX / <span class="number">2</span>;</span><br><span class="line">              quarterZ = halfZ / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">              Root = parent;</span><br><span class="line">              center = parent.Bounds.center;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> ltPos = center + <span class="keyword">new</span> Vector3(-quarterX, <span class="number">0</span>, +quarterZ);</span><br><span class="line">          <span class="keyword">var</span> rtPos = center + <span class="keyword">new</span> Vector3(+quarterX, <span class="number">0</span>, +quarterZ);</span><br><span class="line">          <span class="keyword">var</span> lbPos = center + <span class="keyword">new</span> Vector3(-quarterX, <span class="number">0</span>, -quarterZ);</span><br><span class="line">          <span class="keyword">var</span> rbPos = center + <span class="keyword">new</span> Vector3(+quarterX, <span class="number">0</span>, -quarterZ);</span><br><span class="line">          </span><br><span class="line">          LT = Root.AddChild&lt;QuadTreeNode&gt;();</span><br><span class="line">          LT.Bounds = <span class="keyword">new</span> Bounds(ltPos, <span class="keyword">new</span> Vector3(halfX, halfY*<span class="number">2</span>,halfZ));</span><br><span class="line"></span><br><span class="line">          RT = Root.AddChild&lt;QuadTreeNode&gt;();</span><br><span class="line">          RT.Bounds = <span class="keyword">new</span> Bounds(rtPos, <span class="keyword">new</span> Vector3(halfX, halfY*<span class="number">2</span>, halfZ));</span><br><span class="line"></span><br><span class="line">          LB = Root.AddChild&lt;QuadTreeNode&gt;();</span><br><span class="line">          LB.Bounds = <span class="keyword">new</span> Bounds(lbPos, <span class="keyword">new</span> Vector3(halfX, halfY*<span class="number">2</span>, halfZ));</span><br><span class="line"></span><br><span class="line">          RB = Root.AddChild&lt;QuadTreeNode&gt;();</span><br><span class="line">          RB.Bounds = <span class="keyword">new</span> Bounds(rbPos, <span class="keyword">new</span> Vector3(halfX, halfY*<span class="number">2</span>, halfZ));</span><br><span class="line">          </span><br><span class="line">          Root.AddChildNode(LT);</span><br><span class="line">          Root.AddChildNode(RT);</span><br><span class="line">          Root.AddChildNode(LB);</span><br><span class="line">          Root.AddChildNode(RB);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">foreach</span> (<span class="keyword">var</span> cube <span class="keyword">in</span> cubes)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">var</span> cubeBound = cube.bounds;</span><br><span class="line">              QuadTreeNode node = <span class="literal">null</span>;</span><br><span class="line">              <span class="comment">//MARKER：判断相交后添加到对应的四叉树节点中</span></span><br><span class="line">              <span class="keyword">foreach</span> (<span class="keyword">var</span> child <span class="keyword">in</span> Root.child)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (child.Bounds.Intersects(cubeBound))</span><br><span class="line">                  &#123;</span><br><span class="line">                      child.AddItem(cube);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 递归所有子节点（如果子节点中包含多个Child）</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; Root.child.Count; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">var</span> x = Root.child[i];</span><br><span class="line">              <span class="comment">//MARKER:移除没有剔除物体的节点</span></span><br><span class="line">              <span class="keyword">if</span> (x.ItemData.Count == <span class="number">0</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  Root.child.RemoveAt(i);</span><br><span class="line">                  i--;</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">              <span class="comment">//判断是否需要进一步划分</span></span><br><span class="line">              <span class="keyword">if</span> (x.ItemData.Count &gt; self.MaxCellCount &amp;&amp; x.Bounds.size.x &gt; self.MinCellRange)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">var</span> needSplitData = <span class="keyword">new</span> List&lt;ObjectBase&gt;();</span><br><span class="line">                  needSplitData.AddRange(x.ItemData);</span><br><span class="line">                  x.ClearObj(); </span><br><span class="line">                  self.Split(needSplitData,x);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="动态增加-删除管理物体对象："><a href="#动态增加-删除管理物体对象：" class="headerlink" title="动态增加/删除管理物体对象："></a>动态增加/删除管理物体对象：</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 后续加入新的Item并更新四叉树（需要先init同时满足物品在init时Root的bounds中）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;self&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;go&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;bounds&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddItemAndUpdateTree</span>(<span class="params"><span class="keyword">this</span> SceneTreeModule self, GameObject go, Bounds bounds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span> (!self.IsInitOver)</span><br><span class="line">     &#123;</span><br><span class="line">         Debug.LogWarning(<span class="string">&quot;You must init Tree first&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">var</span> item = <span class="keyword">new</span> ObjectItem(go, bounds);</span><br><span class="line">     self.AllItems.Add(self.GetItemIndex(),item);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//找到对应的相交的QuadTreeNode集合</span></span><br><span class="line">     List&lt;QuadTreeNode&gt; nodes = <span class="keyword">new</span> List&lt;QuadTreeNode&gt;();</span><br><span class="line">     FindTreeNodesByBounds(self.Root,bounds,nodes);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">foreach</span> (<span class="keyword">var</span> node <span class="keyword">in</span> nodes)</span><br><span class="line">     &#123;</span><br><span class="line">         node.AddItem(item);</span><br><span class="line">         <span class="comment">//判断是否需要再分</span></span><br><span class="line">         <span class="keyword">if</span> (node.ItemData.Count &gt; self.MaxCellCount &amp;&amp; node.Bounds.size.x &gt; self.MinCellRange)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">var</span> needSplitData = <span class="keyword">new</span> List&lt;ObjectBase&gt;();</span><br><span class="line">             needSplitData.AddRange(node.ItemData);</span><br><span class="line">             node.ClearObj();</span><br><span class="line">             self.Split(needSplitData,node);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在四叉树场景树管理组件中移除Item</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;self&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;itemIndex&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveItemAndUpdateTree</span>(<span class="params"><span class="keyword">this</span> SceneTreeModule self, <span class="built_in">int</span> itemIndex</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (self.AllItems.ContainsKey(itemIndex))</span><br><span class="line">        &#123;</span><br><span class="line">            ObjectBase item = self.AllItems[itemIndex];</span><br><span class="line">            self.AllItems.Remove(itemIndex);</span><br><span class="line">            RemoveItemInTree(self.Root,item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> DFS在场景树中移除Item</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;self&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;objectBase&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveItemInTree</span>(<span class="params">QuadTreeNode node, ObjectBase item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.ItemData.Contains(item))</span><br><span class="line">        &#123;</span><br><span class="line">            node.ItemData.Remove(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; node.child.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> child = node.child[i];</span><br><span class="line">            RemoveItemInTree(child,item);</span><br><span class="line">            <span class="keyword">if</span> (child.ItemData.Count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node.child.RemoveAt(i);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 找到对应最小的QuadTreeNode集合</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;self&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FindTreeNodesByBounds</span>(<span class="params">QuadTreeNode root, Bounds bound,List&lt;QuadTreeNode&gt; nodes</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">foreach</span> (<span class="keyword">var</span> child <span class="keyword">in</span> root.child)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (child.Bounds.Intersects(bound))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//不可再分</span></span><br><span class="line">             <span class="keyword">if</span> (root.child == <span class="literal">null</span> || root.child.Count == <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 nodes.Add(child);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 FindTreeNodesByBounds(child,bound,nodes);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="判断点在视椎体-多平面-内-外："><a href="#判断点在视椎体-多平面-内-外：" class="headerlink" title="判断点在视椎体(多平面)内/外："></a>判断点在视椎体(多平面)内/外：</h2><p><span style="color:red">△主要在于Vector4对平面plane的定义和表示，用平面法线的x、y、z作为前三个变量，用-Vector3.Dot(normal,point) 表示最后一个向量，理解起来的话是用原点向平面内某点建立射线，并使其与单位法线向量点乘计算出偏移量（投影），配合法线确定平面位置。</span></p><p>同时也是一般式的一种体现：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720211219193304.png" alt="QQ图片20211219193304"></p><p><span style="color:blue">最终判定点在平面内外其实也是判定原点到该点的射线对于单位法线的偏移量与平面内点的偏移量进行对比，若大于则表示在平面外。</span></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 平面内一点和法线确定平面</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 取自公式(p-p‘)*N=0 （即平面内任意线段垂直于法线）</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;normal&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;point&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector4 <span class="title">GetPlane</span>(<span class="params">Vector3 normal, Vector3 point</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Vector4(normal.x, normal.y, normal.z, -Vector3.Dot(normal, point));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 三点确定一个平面</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> MARKER:Unity为左手坐标系，所以叉乘方向遵循左手定则</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;a&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;b&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector4 <span class="title">GetPlane</span>(<span class="params">Vector3 a, Vector3 b, Vector3 c</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       Vector3 normal = Vector3.Normalize(Vector3.Cross(b - a, c - a));<span class="comment">//单位法线向量</span></span><br><span class="line">       <span class="keyword">return</span> GetPlane(normal, a);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 获取相机裁剪远平面的所有顶点</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;camera&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3[] <span class="title">GetCameraFarClipPlanePoint</span>(<span class="params">Camera camera</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       Vector3[] points = <span class="keyword">new</span> Vector3[<span class="number">4</span>];</span><br><span class="line">       Transform transform = camera.transform;</span><br><span class="line">       <span class="built_in">float</span> distance = camera.farClipPlane;<span class="comment">//远裁剪平面的距离</span></span><br><span class="line">       <span class="built_in">float</span> halfFovRad = Mathf.Deg2Rad * camera.fieldOfView * <span class="number">0.5f</span>;</span><br><span class="line">       <span class="built_in">float</span> halfUpLen = distance * Mathf.Tan(halfFovRad); <span class="comment">//MARKER：这里事先选择的Fov Axis是Vertical,所以计算出来的是视锥体的半高度</span></span><br><span class="line">       <span class="built_in">float</span> halfRightLen = halfUpLen * camera.aspect;</span><br><span class="line">       Vector3 farCenterPoint = transform.position + distance * transform.forward;</span><br><span class="line">       Vector3 halfUp = halfUpLen * transform.up;</span><br><span class="line">       Vector3 halfRight = halfRightLen * transform.right;</span><br><span class="line">       points[<span class="number">0</span>] = farCenterPoint - halfRight + halfUp;<span class="comment">//Left-Top</span></span><br><span class="line">       points[<span class="number">1</span>] = farCenterPoint + halfRight + halfUp;<span class="comment">//Right-Top</span></span><br><span class="line">       points[<span class="number">2</span>] = farCenterPoint - halfRight - halfUp;<span class="comment">//Left-Bottom</span></span><br><span class="line">       points[<span class="number">3</span>] = farCenterPoint + halfRight - halfUp;<span class="comment">//Right-Bottom</span></span><br><span class="line">       <span class="keyword">return</span> points;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 获取视锥体的六个平面</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;camera&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector4[] <span class="title">GetFrustumPlane</span>(<span class="params">Camera camera</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//模拟的是透视投影</span></span><br><span class="line">       Vector4[] planes = <span class="keyword">new</span> Vector4[<span class="number">6</span>];</span><br><span class="line">       Transform transform = camera.transform;</span><br><span class="line">       Vector3 cameraPosition = transform.position;</span><br><span class="line">       Vector3[] points = GetCameraFarClipPlanePoint(camera);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//顺时针(右手定则)</span></span><br><span class="line">       planes[<span class="number">0</span>] = GetPlane(cameraPosition, points[<span class="number">0</span>], points[<span class="number">1</span>]);</span><br><span class="line">       planes[<span class="number">1</span>] = GetPlane(cameraPosition, points[<span class="number">1</span>], points[<span class="number">3</span>]);</span><br><span class="line">       planes[<span class="number">2</span>] = GetPlane(cameraPosition, points[<span class="number">3</span>], points[<span class="number">2</span>]);</span><br><span class="line">       planes[<span class="number">3</span>] = GetPlane(cameraPosition, points[<span class="number">2</span>], points[<span class="number">0</span>]);</span><br><span class="line">       planes[<span class="number">4</span>] = GetPlane(-transform.forward, transform.position + transform.forward * camera.nearClipPlane);<span class="comment">//通过法线和法线外一点求近平面</span></span><br><span class="line">       planes[<span class="number">5</span>] = GetPlane(transform.forward, transform.position + transform.forward * camera.farClipPlane);<span class="comment">//通过法线和法线外一点求远平面</span></span><br><span class="line">       <span class="keyword">return</span> planes;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 判断点是否在平面外</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;plane&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;pointPosition&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">isOutSideThePlane</span>(<span class="params">Vector4 plane, Vector3 pointPosition</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (Vector3.Dot(plane, pointPosition) + plane.w &gt; <span class="number">0</span>)<span class="comment">//对于处在这个平面上所有点来说，其点乘法线的值都为0，只要现在判断点与平面内一点的连线与法线夹角小于90°则表示其在平面外</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得、Unity框架、ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ET的模块化管理及其声音模块</title>
      <link href="/2021/12/18/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%A1%E7%90%86%E5%8F%8A%E5%85%B6%E5%A3%B0%E9%9F%B3%E6%A8%A1%E5%9D%97/"/>
      <url>/2021/12/18/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%A1%E7%90%86%E5%8F%8A%E5%85%B6%E5%A3%B0%E9%9F%B3%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    毕设中的demo需要用到声音模块，但是对于一些个人小项目来说Wwise的接入显然是不现实的。因此也根据了另外一个成熟框架-GameFramework中的声音框架进行了对ET的部分适配，对于GF中部分的OOP思路进行了ECS化（组件代替继承，分发代替虚函数），其中底层仍用到了Unity自带的AudioClip、AudioSource等组件。</p><p>​    <span style="color:red">本文参考了花花的<a href="https://www.drflower.top/posts/10eaa088/">GameFramework解析：声音</a>，并进行了一定的修改。</span></p><h1 id="模块化管理组件（VisibleModuleComponent）"><a href="#模块化管理组件（VisibleModuleComponent）" class="headerlink" title="模块化管理组件（VisibleModuleComponent）"></a>模块化管理组件（VisibleModuleComponent）</h1><p>​        在以前制作demo的过程中我们通常会把不同的全局模块采用统一的单例类管理，方便进行模块的插入、删除、使用、交互，而在ET中我同样采取了这样的思路，并且把这个单例管理类作为Entity插入到Game.Scene内名为”Game”的zoneScene中，其在客户端中仅存在一个，而在服务器中可以管理多个，同时我将一些传统的显示模块，如<span style="color:red">CameraModule(相机模块)、EffectModule(特效模块)、SceneTreeModule(场景四叉树管理模块)、SoundModule(声音模块)等</span>都加入到这个模块中，方便进行模块的增加、删除、调用。</p><p>​        以下是VisibleModuleComponent的UML图：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/EGUI%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97_.drawio.png" alt="EGUI可视化管理模块_.drawio"></p><ul><li>添加新模块时实现AModuleEventHandler接口并打上ModuleAttribute(Type type)属性，OnLoad(BaseModule module)中对module添加相应的模块Entity，同时在OnRelease(BaseModule module)中移除相应的模块Entity。之后通过在VisibleModuleComponent中调用Register()通过具体类型分发对应的AModuleEventHandler接口实现注入，本质上还是通过接口函数分发的方式来实现多态。</li><li>在moduleDic中存储已生成模块的Type对应BaseModule，在Get()中通过具体泛型或类型Type获取BaseModule后通过GetComponent&lt;&gt;()的方式获取到对应的实际模块Entity（如CameraModule等）</li><li>对于BaseModule中具有相应状态枚举来管理当前模块状态，同时在不需要时可以直接移除对应Entity，实现热插拔</li></ul><p>模块管理设计方面相对简单，因为模块基本都是同步载入且为热插拔的方式，所以在RegisterMode中没有过多的状态区分。</p><h1 id="声音管理模块"><a href="#声音管理模块" class="headerlink" title="声音管理模块"></a>声音管理模块</h1><h3 id="主体逻辑部分："><a href="#主体逻辑部分：" class="headerlink" title="主体逻辑部分："></a>主体逻辑部分：</h3><p>​    声音管理模块的设计参考了GF中的SoundComponent，通过SoundAgent实现最终的声音播放，同时在SoundModule中将不同的SoundAgent划分在不同的SoundGroup中进行统一管理（如所有背景音乐、效果音乐可以划分在不同SoundGroup中进行分别管理），与此同时，通过代理模式SoundHelper、SoundAgentHelper、SoundGroupHelper实现了对Unity中AudioSource、AudioMixer等的调用解耦，<span style="color:red">SoundAgent无需得知与Unity音频组件的交互手段，而将其托付给对应Helper实现。</span></p><p>​    先放上设计过后的UML图：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/EGUI%E5%A3%B0%E9%9F%B3%E6%A8%A1%E5%9D%97__.drawio.png" alt="EGUI声音模块__.drawio"></p><ul><li>对于SoundGroup、SoundAgent、SoundModule来说实现了Entity和System的分离，同时通过ISoundGroup和ISoundAgent对Entity类的属性接口进行封装</li><li><span style="color:red">在SoundModule中存储SoundGroup以及在SoundGroup中存储SoundAgent时，都通过AddChild&lt;&gt;的方式先将被存储的Entity以child的形式添加到存储Entity中，随后进行赋值，方便管理同时可在父类Entity调用Dispose时即将其存储的所有child Dispose掉并返回Entity引用池中</span></li><li>通过<span style="color:red">PlaySoundParams</span>中具体参数可以在播放时调节播放的时间、位置、绑定的GameObject、声调等</li><li>SoundAgent、SoundGroup具体与Audio组件的交互通过其对应的<span style="color:red">Helper</span>进行</li></ul><h3 id="具体实现部分："><a href="#具体实现部分：" class="headerlink" title="具体实现部分："></a>具体实现部分：</h3><p>上面封装好了一套规范化的音频调用流程后，我们就需要对SoundGroup、SoundAgent、SoundModule写好对应的Helper，其对应的功能如下：</p><ul><li>ISoundAgentHelper:获取当前是否正在播放、获取声音长度、获取或设置播放位置、静音等，其对应的是<span style="color:red">AudioSource</span>的调用,实现这个接口的类本质上是一个挂在<span style="color:red">AudioSource</span>组件的<span style="color:red">Mono类</span>。</li><li>ISoundGroupHelper:获取当前的音频混合组，对应的是<span style="color:red">AudioMixerGroup</span>的调用</li><li>ISoundHelper:管理音频资源，进行动态同步、异步加载和释放，其对应的是不同加载情况下的<span style="color:red">AudioClip</span>的资源管理</li></ul><p>具体的UML图如下：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E5%A3%B0%E9%9F%B3%E6%A8%A1%E5%9D%97Helper_.drawio.png" alt="基于ET的声音模块Helper_.drawio"></p><ul><li>将ISoundAgentHelper和ISoundGroupHelper放在Mono层，作为与Unity组件的交互Helper</li><li>将ISoundHelper放在ET层，内部调用ResourceComponent与Resource类分别实现对AB包音频以及Resource目录下音频的动态加载与释放，其在SoundModule中采用<span style="color:red">函数分发的方式</span>调用</li></ul><h3 id="具体使用："><a href="#具体使用：" class="headerlink" title="具体使用："></a>具体使用：</h3><ol><li><p>我们在切换战斗场景结束的回调中测试战斗背景音乐的播放，先设置好对应的场景音乐的参数后调用<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211219141711343.png" alt="image-20211219141711343"></p></li><li><p>设置好预设的AudioMixer，方便通过AudioMixer对所有的处在同一Group的AudioSource进行调节<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211219142050637.png" alt="image-20211219142050637"></p></li><li><p>Play运行，可以看到已经自动放入了对应的AudioMixer的Group中<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211219142219552.png" alt="image-20211219142219552"></p><p>且在Hierarchy窗口中进行了分层管理：<img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211219142328302.png" alt="image-20211219142328302"></p></li></ol><h3 id="一些小Tips："><a href="#一些小Tips：" class="headerlink" title="一些小Tips："></a>一些小Tips：</h3><ol><li>在GF框架内部的SoundGroup对其内部所有SoundAgent的管理实际用到AudioMixer的其实基本没有，包括Mute、Volume的设置，都是通过代码内遍历soundAgent对其单独调节实现的，而并非借助AudioMixer暴露接口的方式调节，降低了与AudioMixer间的耦合性。猜测应该是想将AudioMixer的调节尽量放在运行前调节而非运行时。</li></ol>]]></content>
      
      
      <categories>
          
          <category> ET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得、Unity框架、ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:851 喧闹与富有</title>
      <link href="/2021/12/15/Leetcode-851-%E5%96%A7%E9%97%B9%E4%B8%8E%E5%AF%8C%E6%9C%89/"/>
      <url>/2021/12/15/Leetcode-851-%E5%96%A7%E9%97%B9%E4%B8%8E%E5%AF%8C%E6%9C%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="851-喧闹和富有"><a href="#851-喧闹和富有" class="headerlink" title="851. 喧闹和富有"></a><a href="https://leetcode-cn.com/problems/loud-and-rich/">851. 喧闹和富有</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211215102759427.png" alt="image-20211215102759427"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题主要是对拓扑排序的考察，因为题目要求的是拥有钱不少于person x，所以我们可以根据richer建立有向无环图deg,同时用vis存储对应入度数，即<span style="color:red">对于richer中每个关系rich来说，建立rich[0]到rich[1]的有向边，因此拓扑排序得到的结果就会是由富有-&gt;贫穷,</span>而根据拓扑排序的结果，我们可以用当前遍历到的元素x的answer更新其相邻节点的answer，即<span style="color:red">若满足quiet[answer[x]]&lt;quiet[answer[y]],则answer[y]=answer[x]。</span></p><p>​    以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">loudAndRich</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, vector&lt;<span class="keyword">int</span>&gt;&amp; quiet)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//拓扑排序例子：</span></span><br><span class="line">        <span class="comment">//拓扑排序使得每一条u-&gt;v,u都在v之前出现</span></span><br><span class="line">        <span class="keyword">int</span> n = quiet.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">deg</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录下当前的richer情况，绘制有向图</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;&amp; rich : richer) &#123;</span><br><span class="line">            deg[rich[<span class="number">0</span>]].<span class="built_in">push_back</span>(rich[<span class="number">1</span>]); <span class="comment">//绘制有向边</span></span><br><span class="line">            vis[rich[<span class="number">1</span>]]++; <span class="comment">//入度+1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">iota</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="number">0</span>);<span class="comment">//以自身为默认值，因为自己拥有的钱一定不少于自身</span></span><br><span class="line">        <span class="comment">//记录下当前入度为0的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行拓扑排序</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//更新当前x对应的answer</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y : deg[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (quiet[ans[x]] &lt; quiet[ans[y]]) &#123;</span><br><span class="line">                    ans[y] = ans[x];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新入度</span></span><br><span class="line">                <span class="keyword">if</span> (--vis[y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学:判断两个矩形是否相交</title>
      <link href="/2021/12/09/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/"/>
      <url>/2021/12/09/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考资料：</span><br><span class="line">https://www.jianshu.com/p/754ac621e6e3</span><br></pre></td></tr></table></figure><p>回想起以前和同事讨论的一道面试题，判断两个矩形是否相交，当时一开始只想到了最简单的根据某个矩形的中心点建立坐标系分情况讨论的方法。如今也算是重新补充一下</p><p>我们直接截取到Unity的Rect中Overlap方法来作为实现：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211209121516044.png" alt="image-20211209121516044"></p><p><span style="color:red">整体的思路是通过两个矩形的xMin,yMin,xMax,yMax进行比较，需要符合<strong>x1Min&lt;x2Max&amp;&amp;x1Max&gt;x2Min&amp;&amp;y1Min&lt;y2Max&amp;&amp;y1Max&gt;y2Min</strong>，我们粗略地画出符合这个要求的图。</span></p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211209122009114.png" alt="image-20211209122009114"></p><p>可能单靠这个图不是很明确，我们再把x，y分别拉成一维的直线</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211209123531646.png" alt="image-20211209123531646"></p><p><span style="color:red">最后：△同样的思路可以拓展至三维</span></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shader:透明度混合，平面下的外/内轮廓，立体下的外轮廓，菲涅尔现象，内发光现象总和</title>
      <link href="/2021/12/08/Shader-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88%EF%BC%8C%E5%B9%B3%E9%9D%A2%E4%B8%8B%E7%9A%84%E5%A4%96-%E5%86%85%E8%BD%AE%E5%BB%93%EF%BC%8C%E7%AB%8B%E4%BD%93%E4%B8%8B%E7%9A%84%E5%A4%96%E8%BD%AE%E5%BB%93%EF%BC%8C%E8%8F%B2%E6%B6%85%E5%B0%94%E7%8E%B0%E8%B1%A1%EF%BC%8C%E5%86%85%E5%8F%91%E5%85%89%E7%8E%B0%E8%B1%A1%E6%80%BB%E5%92%8C/"/>
      <url>/2021/12/08/Shader-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88%EF%BC%8C%E5%B9%B3%E9%9D%A2%E4%B8%8B%E7%9A%84%E5%A4%96-%E5%86%85%E8%BD%AE%E5%BB%93%EF%BC%8C%E7%AB%8B%E4%BD%93%E4%B8%8B%E7%9A%84%E5%A4%96%E8%BD%AE%E5%BB%93%EF%BC%8C%E8%8F%B2%E6%B6%85%E5%B0%94%E7%8E%B0%E8%B1%A1%EF%BC%8C%E5%86%85%E5%8F%91%E5%85%89%E7%8E%B0%E8%B1%A1%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    在设计毕设的战棋游戏时，因为想要让每个格子（Quad）显示其外轮廓/内轮廓线，而standard并不支持，因此参考了一些思路实现了背面法线外扩，但是对于平面来说，以矩形举例，其四周的法线存在多条，并且在剔除正面的情况下不存在背面的Vert，所以这种思路显然是不行的。所以对于平面来说，最好的方法是<span style="color:red">多使用一个Pass，在pass的vert中进行顶点缩放，绘制出比当前顶点大/小的平面，且对z轴进行细微调整防止zfighting，这样其与实际内层Pass套在一起就能营造出外轮廓的感觉。</span></p><p>​    其次就是菲涅尔现象，用到了Schilick菲涅尔近似等式，即F(v,n)=F0+(1-F0)(1-dot(v,n))^5，其中v是视角方向，n是表面法线。</p><p>​    最后是内发光现象，其思路其实与菲尼尔类似，通过1-dot(v,n)的结果与_RimColor（即外发光颜色）进行乘积后获取，<span style="color:red">拓展到外发光，其实就是外轮廓（cull front后外延）+内发光中frag的处理。</span></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Effect.shader:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line">//MARKER：当模型本身有复杂的遮挡关系或者是包含了复杂的非凸网格的时候，纯粹依靠transparent队列来进行排序的方法有可能会因为排序错误产生错误的结果</span><br><span class="line">//MARKER:因此我们可以采用开启深度写入的半透明效果的方法来实现</span><br><span class="line">Shader&quot;Map/Alpha Blending ZWrite&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Color(&quot;Main Tint&quot;,Color)=(1,1,1,1)</span><br><span class="line">    _InColor(&quot;In Color&quot;,Color)=(1,1,1,1)</span><br><span class="line">        _MainTex(&quot;Main Tex&quot;,2D)=&quot;white&quot;&#123;&#125;</span><br><span class="line">        _OutAlphaScale(&quot;Out Alpha Scale&quot;,Range(0,1))=1</span><br><span class="line">    _InAlphaScale(&quot;In Alpha Scale&quot;,Range(0,1))=1</span><br><span class="line">    _Scale(&quot;Scale&quot;,Range(1,2))=1 //缩放</span><br><span class="line">        //_Outline(&quot;Outline&quot;,Range(0,1))=0.1 //轮廓线宽度</span><br><span class="line">    //_OutlineColor(&quot;Outline Color&quot;,Color)=(0,0,0,1)  //轮廓线颜色</span><br><span class="line">    //_RimColor(&quot;Rim Color&quot;,Color)=(1,1,1,1) //边缘颜色</span><br><span class="line">    //_RimPower(&quot;Rim Power&quot;,range(0,10))=2 //边缘强度</span><br><span class="line">    </span><br><span class="line">    //_FresnelColor(&quot;FresnelColor&quot;,Color)=(1,1,1,1) </span><br><span class="line">    //_FresnelAmount(&quot;FresnelAmount&quot;,Range(0,1))=1</span><br><span class="line">    //_FresnelPower(&quot;FresnelPower&quot;,Range(0,5))=5</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    //MARKER:SubShader中多PASS的注意点：pass的执行顺序是依据pass在shader中定义的先后顺序来确定的</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        //MARKER:关键在于先通过pass把该模型的深度值写入深度缓冲中；第二个Pass进行正常的透明度混合</span><br><span class="line">        //MARKER：由于上一个的pass已经得到了逐像素的正确的深度信息，该pass就可以按照像素级别的深度排序结果进行透明渲染</span><br><span class="line">        //Extra   pass that renders to depth buffer only</span><br><span class="line">        Pass&#123;</span><br><span class="line">            ZWrite On</span><br><span class="line">            ColorMask 0</span><br><span class="line">            //MARKER:ColorMask用于设置颜色通道的写掩码（write mask），当ColorMask为0时，意味着该Pass不写入任何颜色通道，即不会输出任何颜色。</span><br><span class="line">            //MARKER:这能够保证该Pass只需写入深度缓存即可 </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    Pass&#123;</span><br><span class="line">    </span><br><span class="line">    //需要开启透明度混合，调节最后的颜色缓冲输出</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">    #pragma vertex vert</span><br><span class="line">    #pragma fragment frag</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        fixed3 _InColor;</span><br><span class="line">fixed _Scale;</span><br><span class="line">//fixed3 _OutlineColor;</span><br><span class="line">    fixed _OutAlphaScale;</span><br><span class="line"></span><br><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line">float4 vertex:POSITION;</span><br><span class="line">float4 normal:NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">float4 pos:SV_POSITION;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">float4x4 Scale(float scale)</span><br><span class="line">&#123;</span><br><span class="line">return float4x4(scale,0,0,0,</span><br><span class="line">0,scale,0,0,</span><br><span class="line">0,0,0,0,</span><br><span class="line">0,0,0,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v2f vert(appdata v)&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">v.vertex=mul(Scale(_Scale),v.vertex);</span><br><span class="line"></span><br><span class="line">//SINGAL：这里直接通过乘算来缩放也可以</span><br><span class="line">//v.vertex*=_Scale;</span><br><span class="line"></span><br><span class="line">    o.pos=UnityObjectToClipPos(v.vertex);</span><br><span class="line">o.pos.z-=0.0001; //防止zfighting</span><br><span class="line">    return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    fixed4 frag(v2f i):SV_Target&#123;</span><br><span class="line">return fixed4(_InColor,_OutAlphaScale);</span><br><span class="line">    &#125;</span><br><span class="line">ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">//    Pass&#123;</span><br><span class="line">//    NAME &quot;OUTLINE&quot;</span><br><span class="line">//    Cull Front //剔除正面</span><br><span class="line">//</span><br><span class="line">//    CGPROGRAM</span><br><span class="line">//</span><br><span class="line">//    #pragma vertex vert</span><br><span class="line">//    #pragma fragment frag</span><br><span class="line">//</span><br><span class="line">//    float _Outline;</span><br><span class="line">//    fixed3 _OutlineColor;</span><br><span class="line">//    fixed _AlphaScale;</span><br><span class="line">//</span><br><span class="line">//    struct appdata</span><br><span class="line">//    &#123;</span><br><span class="line">//    float4 vertex:POSITION;</span><br><span class="line">//    float4 normal:NORMAL;</span><br><span class="line">//    &#125;;</span><br><span class="line">//</span><br><span class="line">//    struct v2f</span><br><span class="line">//    &#123;</span><br><span class="line">//    float4 pos:SV_POSITION;</span><br><span class="line">//    &#125;;</span><br><span class="line">//    </span><br><span class="line">//    v2f vert(appdata v)&#123;</span><br><span class="line">//    //顶点和法线变换到视角空间，达到最好效果</span><br><span class="line">//    v2f o;</span><br><span class="line">//    float4 viewPos=mul(UNITY_MATRIX_MV,v.vertex);</span><br><span class="line">//    float4 viewNormal=mul(UNITY_MATRIX_IT_MV,v.normal);</span><br><span class="line">//    viewNormal.z=-0.5;//对法线z分量进行处理，扁平化</span><br><span class="line">//    viewPos=viewPos+normalize(viewNormal)*_Outline;</span><br><span class="line">//    o.pos=mul(UNITY_MATRIX_P,viewPos); //转换到投影空间</span><br><span class="line">//</span><br><span class="line">//    return o;</span><br><span class="line">//            &#125;</span><br><span class="line">//</span><br><span class="line">//    fixed4 frag(v2f i):SV_Target&#123;</span><br><span class="line">//return fixed4(_OutlineColor,_AlphaScale);</span><br><span class="line">//    &#125;</span><br><span class="line">//    ENDCG</span><br><span class="line">//        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass&#123;</span><br><span class="line">        </span><br><span class="line">//和8.4节同样的代码</span><br><span class="line">            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">        //不开启深度写入，同时通过混合的方式来写入颜色缓冲</span><br><span class="line">            ZWrite Off</span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">CGPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #include&quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            //与定义的Properties进行关联</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line">fixed _InAlphaScale;</span><br><span class="line">        //fixed4 _FresnelColor;</span><br><span class="line">        //fixed _FresnelAmount;</span><br><span class="line">        //fixed _FresnelPower;</span><br><span class="line">        //fixed3 _RimColor;</span><br><span class="line">        //fixed _RimPower;</span><br><span class="line"></span><br><span class="line">            //定义顶点着色器</span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex:POSITION;</span><br><span class="line">                float3 normal:NORMAL;</span><br><span class="line">                float4 texcoord:TEXCOORD0; //用第一套纹理坐标来初始化texcoord(自身理解的话像是每一个顶点的映射，然后在像素着色阶段时可以是每一个像素的映射)</span><br><span class="line">                </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos:SV_POSITION;</span><br><span class="line">                float3 worldNormal:TEXCOORD0;</span><br><span class="line">                float3 worldPos:TEXCOORD1;</span><br><span class="line">                float2 uv:TEXCOORD2; //记录下透明纹理对应的uv坐标</span><br><span class="line">            float3 worldViewDir:TEXCOORD3;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">            //顶点和法线变换到观察空间，达到最好效果</span><br><span class="line">                o.pos=UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.worldNormal=UnityObjectToWorldNormal(v.normal);</span><br><span class="line"></span><br><span class="line">            //MARKER：一定一定注意区分好pos和worldPos的区别，一个是转换到齐次裁剪坐标，一个是采用纹理来记录下顶点世界坐标的位置</span><br><span class="line">                o.worldPos=mul(unity_ObjectToWorld,v.vertex); </span><br><span class="line"></span><br><span class="line">                o.uv=TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">            o.worldViewDir=UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir));</span><br><span class="line"></span><br><span class="line">            //△ 菲涅尔处理</span><br><span class="line">            //float fresnel=_FresnelAmount+(1-_FresnelAmount)*pow((1-max(0,dot(i.worldViewDir,i.worldNormal))),_FresnelPower);</span><br><span class="line">            //fixed3 color=lerp(ambient+diffuse,_FresnelColor,max(0,fresnel));</span><br><span class="line"></span><br><span class="line">            //△ 外发光处理</span><br><span class="line">            //fixed3 rim=_RimColor*pow(1-saturate(dot(i.worldViewDir,i.worldNormal)),_RimPower);</span><br><span class="line">return fixed4(ambient+diffuse, texColor.a * _InAlphaScale); </span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:506.相对名次</title>
      <link href="/2021/12/02/Leetcode-506-%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/"/>
      <url>/2021/12/02/Leetcode-506-%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="506-相对名次"><a href="#506-相对名次" class="headerlink" title="506. 相对名次"></a><a href="https://leetcode-cn.com/problems/relative-ranks/">506. 相对名次</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211202120224197.png" alt="image-20211202120224197"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    主要思路是通过vector&lt;int&gt; 存储每个运动员的得分[0]和初始位置[1]，而后通过sort()对vector&lt;vector&lt;int&gt;&gt; arr根据[0]从大到小进行排序，得到顺序后对result(vector&lt;string&gt;)进行赋值操作，具体为result[arr[i][1]]=to_string(i+1) 和result[arr[i][1]]=t[i]。</p><p>​    <span style="color:red">△可以将arr优化为vector&lt;int&gt;，记录下原始位置，排序的lambda函数变为[&amp;](int i,int j){return score[i]&gt;score[j];}</span></p><p>​    以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string t[<span class="number">3</span>]=&#123;<span class="string">&quot;Gold Medal&quot;</span>,<span class="string">&quot;Silver Medal&quot;</span>,<span class="string">&quot;Bronze Medal&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> len=score.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            temp[<span class="number">0</span>]=score[i]; <span class="comment">//记录下分数</span></span><br><span class="line">            temp[<span class="number">1</span>]=i;  <span class="comment">//记录下原始位置</span></span><br><span class="line">            vec.<span class="built_in">push_back</span>(temp); <span class="comment">//添加入待排序的vec中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](vector&lt;<span class="keyword">int</span>&gt;&amp; i,vector&lt;<span class="keyword">int</span>&gt;&amp; j) &#123;<span class="keyword">return</span> i[<span class="number">0</span>] &gt; j[<span class="number">0</span>]; &#125;); <span class="comment">//如果返回true则不进行交换</span></span><br><span class="line"></span><br><span class="line">       <span class="function">vector&lt;string&gt; <span class="title">result</span><span class="params">(len, <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                result[vec[i][<span class="number">1</span>]] = t[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            result[vec[i][<span class="number">1</span>]] = t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; len; i++) &#123;</span><br><span class="line">            result[vec[i][<span class="number">1</span>]] = <span class="built_in">to_string</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET:引用第三方插件</title>
      <link href="/2021/11/29/ET-%E5%BC%95%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6/"/>
      <url>/2021/11/29/ET-%E5%BC%95%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    ET 6.0正式版发布后，将Model、ModelView、Hotfix、HotfixView进一步移出了Unity/Assets部分，因此第三方导入只能通过修改csproj的方法添加。</p><h1 id="添加方法："><a href="#添加方法：" class="headerlink" title="添加方法："></a>添加方法：</h1><h2 id="Model、ModelView、Hotfix、Hotfix部分："><a href="#Model、ModelView、Hotfix、Hotfix部分：" class="headerlink" title="Model、ModelView、Hotfix、Hotfix部分："></a>Model、ModelView、Hotfix、Hotfix部分：</h2><ul><li><p>Rider:直接对Project右键选择Add/Add Reference，添加对应的dll即可<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211129203129372.png" alt="image-20211129203129372"></p></li><li><p>直接打开对应project的csproj，在其中加入下列代码，以Mountains.Feedback为例子</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;MoreMountains.Feedbacks, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">HintPath</span>&gt;</span>Library\ScriptAssemblies\MoreMountains.Feedbacks.dll<span class="tag">&lt;/<span class="name">HintPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Reference</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span style="color:red">第三方插件编译后的dll存放在Library/ScriptAssemblies中。</span></p></li></ul><p>​        </p><h2 id="Mono部分："><a href="#Mono部分：" class="headerlink" title="Mono部分："></a>Mono部分：</h2><ul><li>在Unity中找到对应目录下的asmdef，之后在Assembly Definition References中添加对应的引用dll</li></ul><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220221142724587.png" alt="image-20220221142724587"></p>]]></content>
      
      
      <categories>
          
          <category> Unity框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shader剔除模拟Slider效果</title>
      <link href="/2021/11/29/Shader%E5%89%94%E9%99%A4%E6%A8%A1%E6%8B%9FSlider%E6%95%88%E6%9E%9C/"/>
      <url>/2021/11/29/Shader%E5%89%94%E9%99%A4%E6%A8%A1%E6%8B%9FSlider%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    想在战棋demo中增加UI的血条效果，原本用的是之前所用的直接slider制作或直接修改UI中sizedelta.x的方法来实现，但是却发现会不可避免的造成Image中的sprite拉伸的情况，后来自己尝试的同时问了下同事得到了两种方案。</p><h1 id="方案1：slider-Rect-Mask蒙版"><a href="#方案1：slider-Rect-Mask蒙版" class="headerlink" title="方案1：slider+Rect Mask蒙版"></a>方案1：slider+Rect Mask蒙版</h1><h2 id="制作思路："><a href="#制作思路：" class="headerlink" title="制作思路："></a>制作思路：</h2><p>直接对UGUI中的slider结构进行一个小修改，新加入前景色和后景色作为血条颜色和背景色，同时在原Slider中的Fill加入了Rect Mask，对前景色进行蒙版处理，用于解决UGUI中Slider中Fill在修改value时会rect Transform定死为Stretch Left的情况，前景色和后景色的RectTransform都设置为 Middle Left。</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211129135359031.png" alt="image-20211129135359031"></p><h2 id="实际效果："><a href="#实际效果：" class="headerlink" title="实际效果："></a>实际效果：</h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211129135815544.png" alt="image-20211129135815544"></p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211129135841193.png" alt="image-20211129135841193"></p><h1 id="方案2：通过shader进行蒙版剔除"><a href="#方案2：通过shader进行蒙版剔除" class="headerlink" title="方案2：通过shader进行蒙版剔除"></a>方案2：通过shader进行蒙版剔除</h1><h2 id="制作思路：-1"><a href="#制作思路：-1" class="headerlink" title="制作思路："></a>制作思路：</h2><p>​    通过UI Shader中的uv.x与参数_Clip做一个剔除，<span style="color:red">即Clip(i.uv.x-_Clip)</span>,来达到类似于slider的效果，感谢同事的思路，感觉挺方便的。</p><p>​    在明确了思路的情况下，直接找到builtin中UI-Default.shader并对其进行一些修改：</p><p>​    UIClip.shader:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)</span><br><span class="line"></span><br><span class="line">Shader &quot;UI/UIClip&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line"></span><br><span class="line">        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8</span><br><span class="line">        _Stencil (&quot;Stencil ID&quot;, Float) = 0</span><br><span class="line">        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0</span><br><span class="line">        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255</span><br><span class="line">        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255</span><br><span class="line">        </span><br><span class="line">        //MARKER:用于处理UI的剔除效果的参数</span><br><span class="line">        _Clip(&quot;Clip Mask&quot;,Range(0,1))=1</span><br><span class="line"></span><br><span class="line">        _ColorMask (&quot;Color Mask&quot;, Float) = 15</span><br><span class="line"></span><br><span class="line">        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;IgnoreProjector&quot;=&quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class="line">            &quot;PreviewType&quot;=&quot;Plane&quot;</span><br><span class="line">            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stencil</span><br><span class="line">        &#123;</span><br><span class="line">            Ref [_Stencil]</span><br><span class="line">            Comp [_StencilComp]</span><br><span class="line">            Pass [_StencilOp]</span><br><span class="line">            ReadMask [_StencilReadMask]</span><br><span class="line">            WriteMask [_StencilWriteMask]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cull Off</span><br><span class="line">        Lighting Off</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest [unity_GUIZTestMode]</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">        ColorMask [_ColorMask]</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name &quot;Default&quot;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #pragma target 2.0</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            #include &quot;UnityUI.cginc&quot;</span><br><span class="line"></span><br><span class="line">            #pragma multi_compile_local _ UNITY_UI_CLIP_RECT</span><br><span class="line">            #pragma multi_compile_local _ UNITY_UI_ALPHACLIP</span><br><span class="line"></span><br><span class="line">            struct appdata_t</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex   : POSITION;</span><br><span class="line">                float4 color    : COLOR;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">                UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex   : SV_POSITION;</span><br><span class="line">                fixed4 color    : COLOR;</span><br><span class="line">                float2 texcoord  : TEXCOORD0;</span><br><span class="line">                float4 worldPosition : TEXCOORD1;</span><br><span class="line">                float2 clipuv :TEXCOORD2;</span><br><span class="line">                UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _TextureSampleAdd;</span><br><span class="line">            float4 _ClipRect;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float _Clip;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_t v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f OUT;</span><br><span class="line">                UNITY_SETUP_INSTANCE_ID(v);</span><br><span class="line">                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);</span><br><span class="line">                OUT.worldPosition = v.vertex;</span><br><span class="line">                OUT.vertex = UnityObjectToClipPos(OUT.worldPosition);</span><br><span class="line">                </span><br><span class="line">                OUT.clipuv=v.texcoord; //记录uv</span><br><span class="line">                OUT.texcoord = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                OUT.color = v.color * _Color;</span><br><span class="line">                return OUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f IN) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                clip (_Clip-IN.clipuv.x); //根据uv进行剔除</span><br><span class="line">                half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;</span><br><span class="line"></span><br><span class="line">                #ifdef UNITY_UI_CLIP_RECT</span><br><span class="line">                color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);</span><br><span class="line">                #endif</span><br><span class="line"></span><br><span class="line">                #ifdef UNITY_UI_ALPHACLIP</span><br><span class="line">                clip (color.a - 0.001);</span><br><span class="line">                #endif</span><br><span class="line"></span><br><span class="line">                return color;</span><br><span class="line">            &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实际效果：-1"><a href="#实际效果：-1" class="headerlink" title="实际效果："></a>实际效果：</h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211129141458108.png" alt="image-20211129141458108"></p><p><span style="color:red">方案2在使用时需要对每个slider新生成一个mat增加了dc，在问了大佬后发现其实有通过RawImageData绘制Texture后通过IParameterTexture来访问ParameterTexture对应像素点获取到任意通道（比如a）作为每个slider的_Clip的思路，后续优化再考虑吧。</span></p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shader学习：基于噪声的消融效果</title>
      <link href="/2021/11/27/Shader%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%99%AA%E5%A3%B0%E7%9A%84%E6%B6%88%E8%9E%8D%E6%95%88%E6%9E%9C/"/>
      <url>/2021/11/27/Shader%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%99%AA%E5%A3%B0%E7%9A%84%E6%B6%88%E8%9E%8D%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    早些时间过了一遍Games101,但是中间间隔了一段长时间的实习后发现自己忘了不少。所以在复习Games101的过程中也去跟着shader入门精要去实现一些毕设Demo可能要用到的效果。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​    <span style="color:red">消融效果常见于游戏中的角色死亡、地图销毁等效果。</span></p><p>​    其原理比较简单，概括来说就是噪声纹理+透明度测试，我们使用对噪声纹理采样的结果和某个控制消融程度的阈值比较，如果小于阈值，就使用clip函数把它对应的像素裁剪掉，这些部分就对应了图中被”销毁”的区域。而镂空区域边缘的烧焦效果则是将两种颜色混合，再用pow函数处理后，与原纹理颜色混合后的效果。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>Dissolve消融：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;BattleEffect/Dissolve&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainColor(&quot;Color&quot;,Color)=(1,1,1,1)</span><br><span class="line">        _Specular(&quot;Specular&quot;,Color)=(1,1,1,1)</span><br><span class="line">        _BurnAmount(&quot;Burn Amount&quot;,Range(0.0,1.0))=0.0 //用于控制消融程度，当值为0时，物体为正常效果，当值为1时，物体会完全消融</span><br><span class="line">        _LineWidth(&quot;Burn Line Width&quot;,Range(0.0,0.2))=0.1 //用于控制模拟烧焦效果时的线宽，它的值越大，火焰边缘的蔓延范围越广</span><br><span class="line">        _MainTex(&quot;Base (RGB)&quot;,2D) = &quot;White&quot;&#123;&#125; //对应物体原本的漫反射纹理</span><br><span class="line">        _BumpMap(&quot;Normal Map&quot;,2D)=&quot;bump&quot;&#123;&#125;  //对应物体原本的法线纹理（凹凸映射并不会真的改变模型的顶点位置，只是修改模型表面的法线，以便为模型提供更多的细节）</span><br><span class="line">                                            //bump是Unity内置的法线纹理，当没有提供任何发现信息是，bump就对应了模型自带的法线信息</span><br><span class="line">        _BurnFirstColor(&quot;Burn First Color&quot;,Color)=(1,0,0,1) //对应了火焰边缘的颜色</span><br><span class="line">        _BurnSecondColor(&quot;Burn Second Color&quot;,Color)=(1,0,0,1)//对应了火焰边缘的颜色</span><br><span class="line">        _Gloss(&quot;Gloss&quot;,Range(8.0,256))=20</span><br><span class="line">        _BurnMap(&quot;Burn Map&quot;,2D)=&quot;White&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">            Pass&#123;</span><br><span class="line">                Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125; //设置类型为前向渲染</span><br><span class="line">                </span><br><span class="line">                Cull Off  //关闭剔除</span><br><span class="line">                </span><br><span class="line">                CGPROGRAM</span><br><span class="line"></span><br><span class="line">                #pragma vertex vert</span><br><span class="line">                #pragma fragment frag</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                #include &quot;Lighting.cginc&quot;</span><br><span class="line">                #include &quot;AutoLight.cginc&quot;</span><br><span class="line"></span><br><span class="line">                #pragma multi_compile_fwdbase //设置pass类型为forwardPass</span><br><span class="line"></span><br><span class="line">                //与定义的Properties相关联</span><br><span class="line">                sampler2D _MainTex;</span><br><span class="line">                sampler2D _BumpMap;</span><br><span class="line">                sampler2D _BurnMap;</span><br><span class="line">                float _BurnAmount;</span><br><span class="line">                float _LineWidth;</span><br><span class="line">                float4 _MainColor;</span><br><span class="line">                float4 _BurnFirstColor;</span><br><span class="line">                float4 _BurnSecondColor;</span><br><span class="line">                float4 _MainTex_ST;</span><br><span class="line">                float4 _BumpMap_ST;</span><br><span class="line">                float4 _BurnMap_ST;</span><br><span class="line">                float _Gloss;</span><br><span class="line">                fixed4 _Specular;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                //定义顶点着色器</span><br><span class="line">                struct a2v</span><br><span class="line">                &#123;</span><br><span class="line">                    float4 vertex:POSITION; //获得顶点模型坐标</span><br><span class="line">                    float3 normal:NORMAL; //获得顶点模型坐标系下法线</span><br><span class="line">                    float4 texcoord:TEXCOORD0; //用第一套纹理坐标来初始化texcoord(自身理解的话像是每一个顶点的映射，然后在像素着色阶段时可以是每一个像素的映射)</span><br><span class="line">                                               //UV本质是把一张平面图像的不同区域（不同位置）映射到3D模型的不同面上</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                &#125;;</span><br><span class="line">                struct v2f</span><br><span class="line">                &#123;</span><br><span class="line">                    float4 pos:SV_POSITION;</span><br><span class="line">                    float2 uvMainTex:TEXCOORD0;</span><br><span class="line">                    float2 uvBumpMap:TEXCOORD1;</span><br><span class="line">                    float2 uvBurnMap:TEXCOORD2;</span><br><span class="line">                    //float3 lightDir:TEXCOORD3;</span><br><span class="line">                    float3 worldNormal:TEXCOORD3;</span><br><span class="line">                    float3 worldPos:TEXCOORD4;</span><br><span class="line">                    SHADOW_COORDS(5)// 相当于float4 _ShadowCoord:TEXCOORD5</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                v2f vert(a2v v)</span><br><span class="line">                &#123;</span><br><span class="line">                    v2f o;</span><br><span class="line">                    o.pos=UnityObjectToClipPos(v.vertex); //获取对应顶点的归一化齐次裁剪坐标</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                    o.uvMainTex=TRANSFORM_TEX(v.texcoord,_MainTex);//计算纹理对应的纹理坐标 </span><br><span class="line">                    o.uvBumpMap=TRANSFORM_TEX(v.texcoord,_BumpMap);</span><br><span class="line">                    o.uvBurnMap=TRANSFORM_TEX(v.texcoord,_BurnMap);</span><br><span class="line">                    </span><br><span class="line">                    //TANGENT_SPACE_ROTATION; //定义从世界坐标到切线坐标的rotation</span><br><span class="line">                    //o.lightDir=mul(rotation,ObjSpaceLightDir(v.vertex)).xyz</span><br><span class="line">                    </span><br><span class="line">                    //o.lightDir=UnityWorldSpaceLightDir(v.vertex); //得到世界空间中这个顶点到光源的方向</span><br><span class="line"></span><br><span class="line">                    o.worldNormal=UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                    o.worldPos=mul(unity_ObjectToWorld,v.vertex).xyz; //计算世界空间下的顶点坐标</span><br><span class="line">                    </span><br><span class="line">                   </span><br><span class="line">                    TRANSFER_SHADOW(o);//计算阴影纹理的采样坐标</span><br><span class="line">                    </span><br><span class="line">                    return o;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //实现片元着色器模拟消融效果</span><br><span class="line">                fixed4 frag(v2f i):SV_Target&#123;</span><br><span class="line">                    fixed3 burn=tex2D(_BurnMap,i.uvBurnMap); //根据得到的纹理坐标进行采样</span><br><span class="line"></span><br><span class="line">                    clip(burn.r-_BurnAmount); //消融的关键，剔除掉小于指定阈值的像素 //对于灰度图来说，其rgb都是相同的</span><br><span class="line"></span><br><span class="line">                    //float3 tangentLightDir=normalize(i.lightDir); </span><br><span class="line">                    //fixed3 tangentNormal=UnpackNormal(tex2D(_BumpMap,i.uvBumpMap));</span><br><span class="line">                    </span><br><span class="line">                    fixed3 worldNormal=normalize(i.worldNormal); //计算世界坐标下像素</span><br><span class="line">                    fixed3 worldLightDir=UnityWorldSpaceLightDir(i.worldPos);</span><br><span class="line">                    </span><br><span class="line">                    fixed3 albedo=tex2D(_MainTex,i.uvMainTex).rgb;//计算材质的反射率</span><br><span class="line"></span><br><span class="line">                    fixed3 ambient=UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;//计算环境光照</span><br><span class="line">                    fixed3 diffuse=_LightColor0.rgb*albedo*max(0,dot(worldNormal,worldLightDir));</span><br><span class="line">                    </span><br><span class="line">                    //fixed3 reflectDir=normalize(reflect(-lightDir,worldNormal));</span><br><span class="line">                    //fixed3 viewDir=normalize(_WorldSpaceCameraPos.xyz-i.worldPos.xyz);</span><br><span class="line">                    //fixed3 specular=_LightColor0.rgb*_Specular.rgb*pow(saturate(dot(viewDir,reflectDir)),_Gloss);</span><br><span class="line">                    </span><br><span class="line">                    fixed t=1-smoothstep(0.0,_LineWidth,burn.r-_BurnAmount);//用t混合两种火焰颜色_BurnFirstColor和_BurnSecondColor(smoothstep可以生成v3从v1到v2对应0到1的平滑过渡值)</span><br><span class="line">                    fixed3 burnColor=lerp(_BurnFirstColor,_BurnSecondColor,t);</span><br><span class="line">                    burnColor=pow(burnColor,5);//对烧焦颜色结果进行了处理</span><br><span class="line"></span><br><span class="line">                    UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);//进行光照衰减适配,对阴影映射纹理进行采样</span><br><span class="line">                    fixed3 finalColor=lerp(ambient+diffuse*atten,burnColor,t*step(0.0001,_BurnAmount)); //用step来保证当_BurnAmount为0时，不显示任何消融效果</span><br><span class="line">                    </span><br><span class="line">                    fixed4 resultColor=fixed4(finalColor,1)*_MainColor; //进行颜色混合</span><br><span class="line">                    </span><br><span class="line">                    return resultColor;</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                ENDCG</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode. 519 随机翻转矩阵</title>
      <link href="/2021/11/27/LeetCode-519-%E9%9A%8F%E6%9C%BA%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/11/27/LeetCode-519-%E9%9A%8F%E6%9C%BA%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="519-随机翻转矩阵"><a href="#519-随机翻转矩阵" class="headerlink" title="519. 随机翻转矩阵"></a><a href="https://leetcode-cn.com/problems/random-flip-matrix/">519. 随机翻转矩阵</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211127122026389.png" alt="image-20211127122026389"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    算法整体主要考察了二维数组的Random洗牌方法，核心思路是将二维数组转换为一维数组，用一维数组的洗牌算法思路来解决。</p><p>​    我们可以联系到一般的洗牌方法：<span style="color:red">假设数组的元素个数为count，则我们从0~count-1随机取任意一个数，将该数作为索引在数组中对应元素与最后一个元素进行交换，并且返回该元素作为当前随机抽选到的数，这样可以保证每次取值都不重复，且当循环count次后可以达到洗牌的效果。</span></p><p>​    得到基本思路后，我们可以通过两种方法来实现：</p><ul><li><p>模拟整个的洗牌过程，初始化一个数组，其索引对应真实值（对应二维数组），每次取到真实值与最后一个元素进行交换，重复过程</p><p><span style="color:blue">根据思路得到的代码：</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _m,_n,_count;</span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//MARKER:类似于洗牌算法的一种思路</span></span><br><span class="line">    <span class="built_in">Solution</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        _m=m;_n=n;_count=m*n;</span><br><span class="line">        arr=<span class="keyword">new</span> <span class="keyword">int</span>[_count];</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;_count;i++)&#123;</span><br><span class="line">            arr[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ran=<span class="built_in">rand</span>()%_count--;</span><br><span class="line">        <span class="keyword">int</span> index=arr[ran];</span><br><span class="line">        <span class="built_in">swap</span>(ran,_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;index/_n,index%_n&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _count=_m*_n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新初始化数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;_count;i++)&#123;</span><br><span class="line">            arr[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[n];</span><br><span class="line">        arr[n]=arr[m];</span><br><span class="line">        arr[m]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果是超时了。。</p></li><li><p>用哈希表代替每次的交换过程，每次random过后得到索引ran，用通过哈希表取到ran对应的真实值index，并且将[ran,GetOrDefault(_count,_count)]在哈希表中添加或修改。</p><p>挺巧妙的一种方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _m,_n,_count;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//MARKER:类似于洗牌算法的一种思路</span></span><br><span class="line">    <span class="built_in">Solution</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        _m=m;_n=n;_count=m*n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ran=<span class="built_in">rand</span>()%_count--;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="built_in">GetOrDefault</span>(ran,ran);</span><br><span class="line">        m[ran] = <span class="built_in">GetOrDefault</span>(_count, _count); <span class="comment">//相当于被抽到的元素与最后一个元素交换</span></span><br><span class="line">        <span class="keyword">return</span> &#123;index/_n,index%_n&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _count=_m*_n;</span><br><span class="line">        m.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现C++的getOrDefault()</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetOrDefault</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> defaultNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m.<span class="built_in">count</span>(index)==<span class="number">1</span>?m[index]:defaultNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><span style="color:red">时间复杂度得到了优化</span></p></li></ul><p>写的时候遇到的一些坑：</p><ul><li>map.insert()在已有对应元素的情况不会去修改对应索引的元素值，一开始用insert写代码思路都没错却不知道为什么没过，后来才发现这个情况。</li><li>m[ran]的赋值必须为GetOrDefault(_count,_count)而非_count,因为在总体范围遍历到_count之前，_count的值可能在之前的遍历中就被随机到并赋值为了之前遍历过程的最后一个元素，因此这里得通过哈希表来获取到实际值。</li></ul><p>​    最后写着写着发现曾经的一次面试中也被问到<span style="color:red">二维数组的随机洗牌</span>问题，当时只想到了第一种转换为一维数组并交换的方法，如今算是摸索到了更好的思路（哈希表存储）</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 859.亲密字符串</title>
      <link href="/2021/11/23/Leetcode-859-%E4%BA%B2%E5%AF%86%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/11/23/Leetcode-859-%E4%BA%B2%E5%AF%86%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="859-亲密字符串"><a href="#859-亲密字符串" class="headerlink" title="859. 亲密字符串"></a><a href="https://leetcode-cn.com/problems/buddy-strings/">859. 亲密字符串</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211123100009764.png" alt="image-20211123100009764"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题主要是考察对题目的理解，跳脱出对s交换得到所有情况判断的思路。</p><p>分为两种情况：</p><ul><li>s==goal且存在某个i!=j使得s[i]==s[j]</li><li>存在某个i!=j使得s[i]==goal[j]且s[j]==goal[i]，并且s与goal的其他字符都相等（前提s[i]!=s[j]，区别于第一种情况）</li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">buddyStrings</span><span class="params">(string s, string goal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分为两种情况：</span></span><br><span class="line">        <span class="comment">//第一种：s==goal且存在某个i!=j使得s[i]==s[j]</span></span><br><span class="line">        <span class="comment">//第二种：存在某个i!=j使得s[i]==goal[j]且s[j]==goal[i]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s==goal)&#123;</span><br><span class="line">            <span class="keyword">int</span> count[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                count[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                <span class="keyword">if</span>(count[s[i]-<span class="string">&#x27;a&#x27;</span>]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>()==goal.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> first=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> second=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]!=goal[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(first==<span class="number">-1</span>)&#123;</span><br><span class="line">                        first=i;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(second==<span class="number">-1</span>)&#123;</span><br><span class="line">                        second=i;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (first!=<span class="number">-1</span>&amp;&amp;second!=<span class="number">-1</span>&amp;&amp;s[first]==goal[second]&amp;&amp;s[second]==goal[first]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ET的UI框架--EGUI项目导入与代码理解</title>
      <link href="/2021/11/16/%E5%9F%BA%E4%BA%8EET%E7%9A%84UI%E6%A1%86%E6%9E%B6-EGUI%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/"/>
      <url>/2021/11/16/%E5%9F%BA%E4%BA%8EET%E7%9A%84UI%E6%A1%86%E6%9E%B6-EGUI%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    拿到ET框架后发现原生的UI框架非常简陋，所以萌生了基于ET去设计UI框架的想法，后续也确实实现了UI的sortingOrder分级、UICamera管理以及生命生命周期的新增、UI栈引入等等（[ET6.0框架初步()]），但是近期在查看ET大佬所写框架时发现自己还是小巫见大巫了，因此还是想先去将比较成熟的EGUI导入项目中使用并且记录下方法、思路，同时对EGUI框架加上一些自己的理解。</p><p>​    同时也放上框架作者字母哥的B站视频链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【ET框架】01-EUI介绍与UI控件获取--字母哥Binaray：https://www.bilibili.com/video/BV12F411e7bP?spm_id_from=333.999.0.0</span><br></pre></td></tr></table></figure><h1 id="项目导入"><a href="#项目导入" class="headerlink" title="项目导入"></a>项目导入</h1><p>项目框架主要区分为五个部分：</p><ul><li>ModelView/GameLogic中对于UI表现层数据的存储，抛弃了传统ET自带Demo中传统UIName+Component的思路，将其进一步细化为UIName+ViewComponent中UIBehaviour的两部分以及UIItemBehaviour，同时将ViewComponent作为组件加入到UI对应的Entity实体中。<ul><li>UIBehaviour<ul><li>CommonUI，表示通用的子UI组件，其能嵌套在不同的UIPrefab中</li><li>ViewComponent，表示主界面展示元素的数据组件，内部存有打上标记的UnityEngine.UI组件</li></ul></li><li>UIItemBehaviour<ul><li>滑动列表数据处理</li></ul></li><li>UI Entity实体<ul><li>其可通过View获取到对应UI的ViewComponent，同时也可用于存储UI中其他逻辑数据，相当于进一步把UI层View与Model区分开来</li></ul></li></ul></li><li>HotfixView中对于UI表现层的逻辑处理，对于每个UI来说具有一个用于实现具体UI函数的System.cs以及实现UI生命周期的接口的Handler.cs</li><li>ModelView/Module中存有对于UI中的基础数据模块，包括用于表示UI类型的AUIEventAttribute、供逻辑层handler实现的IAUIEventHandler接口、红点处理的数据层等等，这部分会在之后细讲。</li><li>HotfixView/Module中对于ModelView层Module数据的具体逻辑实现，同时也包括最上层UI管理器组件UIComponent的逻辑代码实现（ShowWindow、HideWindow等）</li><li>Editor/UI中的UI代码生成拓展，可以对已有的Prefab通过右键生成对应的UI代码</li></ul><p>在分析好基本的UI关联代码结构之后，我们就可以去将关联文件导入到我们自己的项目中。</p><p><span style="color:red">下面我们来进行测试：</span></p><ol><li><p>在Bundles/UI中创建Common、Dlg、Item目录分别对应三种不同类型的UI</p></li><li><p>创建一个DlgLogin的UIPrefab，在View需要获取的GO中打上标签</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211116181241991.png" alt="image-20211116181241991"></p></li><li><p>修改AssetBundle信息，<span style="color:red">这个后续会用Editor右键来方便处理。</span><br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211116182957134.png" alt="image-20211116182957134"></p></li><li><p>在WindowID枚举类中新增对应WindowID_{UIName}的枚举<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211116183159931.png" alt="image-20211116183159931"></p></li><li><p>通过UIComponent.Instance.ShowWindow(WindowID windowId)进行展示同步显示，ShowWindowAsync(WindowId windowId)进行异步显示。</p></li></ol><p><span style="color:red">Tips：如果对应的UIPrefab中有Canvas组件，其Render Mode需要先设置为World Space</span></p><h1 id="框架理解"><a href="#框架理解" class="headerlink" title="框架理解"></a>框架理解</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>​    EGUI的框架本身比起GF的通用性更面向于实际逻辑的开发，其根据实际窗口使用类型已经分为了不同的UIGroup，包括Normal、Fixed、PopUp、Other和Invalid，并根据不同类型在UI生命周期中进行了相应的适配。</p><p>​    UI窗口类型：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211119131302026.png" alt="image-20211119131302026">    </p><p>​    本文的框架图和结构是结合了自身的修改以及拓展后的版本</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/EGUI.drawio_1.png" alt="EGUI.drawio_1"></p><p>​    <span style="color:red">ET的基础思路是用组件代替继承，分发代替多态，因此在EGUI的设计中没有Entity类间的继承关系，所有的UI类都是继承自Entity，通过Component的拆装实现类似于OOP中的继承效果。同时ET中的所有Component默认在池中获取，方便管理内存。</span></p><h2 id="查询接口"><a href="#查询接口" class="headerlink" title="查询接口"></a>查询接口</h2><ul><li>IsWindowVisible()，判断Window是否处于显示状态</li><li>GetDlgLogic()，获取UIBaseWindow中对应类型数据</li></ul><h2 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h2><ul><li>showWindow()，同步展示窗口</li><li>showWindowAsync(),异步展示窗口</li><li>closeWindow(),关闭窗口</li><li>HideWindow(),隐藏窗口</li><li>HideLastWindow(),隐藏popUp窗口类型的最后一个UI</li><li>CloseLastWindow(),关闭popUp窗口类型的最后一个UI</li><li>HideAndShowWindowStack(),将当前UI窗口隐藏并压入栈中，展示新的窗口，在新窗口隐藏或关闭时重新展示</li><li>HideAllShownWindows(),隐藏所有正在展示的窗口</li><li>CloseAllWindow(),清空所有UI</li><li>RemoveAllStackNode(),清空UI栈中所有结点（栈已经拓展为链表）</li><li>RemoveParentStackUI(),递归清除该UI的所有父亲UI，相当于从栈UI窗口（如角色信息、背包等）中回到主界面</li><li>CancelAllLoadingUI(),清除所有加载中的UI，<span style="color:red">和GF相同，EGUI中的UI无法在加载时就取消，只能在加载完成后清除</span></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>​    将上面提到的IAUIEventHandler中各个接口函数的过程进行具体解析。</p><ul><li>OnInitWindowCoreData()：在UIComponent中的show()生命周期中的ReadyToShowBaseWindow()以及ShowAsync()生命周期的showBaseWindowAsync()调用，在过程中若未加载对应的UIData资源则调用该函数</li><li>OnInitComponent():过程同上，若过程中UIBaseWindow未进行加载或者未进行UITransform的preload操作则调用该函数</li><li>OnRegisterComponent():过程同上，若过程中UIBaseWindow未进行加载或者未进行UITransform的preload操作则调用该函数</li><li>OnShowWindow():在UIComponent中的show()和showAsync()生命周期中RealShowWindow()中调用，即在窗口展示时进行调用</li><li>OnHideWindow():在UIComponent中的hide()和CheckDirectlyHide()调用，同时也在UIComponent中HideAllShownWindow()调用，即在窗口隐藏/关闭时调用</li><li>BeforeUnload():在UIComponent中的CloseWindow()以及UIComponent组件被移除时的Destroy()回调中调用，即在窗口关闭/被销毁前调用</li></ul><p>​    </p><p><span style="color:red">UI窗口打开的生命周期：</span></p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/EGUI_OpenUI_.drawio.png" alt="EGUI_OpenUI_.drawio"></p><p><span style="color:red">UI隐藏时的生命周期：</span></p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/EGUI_CloseUI_.drawio.png" alt="EGUI_CloseUI_.drawio"></p><h1 id="自身拓展"><a href="#自身拓展" class="headerlink" title="自身拓展"></a>自身拓展</h1><ul><li><p>将原本框架中的UI栈由Stack数据类型改为链表类型，方便后续可删操作</p></li><li><p>新增操作接口<img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211119160218585.png" alt="image-20211119160218585"></p></li><li><p>WindowCoreData中新增各种状态参数，方便获取状态<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211119160343165.png" alt="image-20211119160343165"></p></li><li><p>UIComponentSystem的Update()中增加对删除加载中UI的处理函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static void HandleCancelLoadingUI(this UIComponent self)</span><br><span class="line">        &#123;</span><br><span class="line">            //MARKER：控制Loading中UI取消</span><br><span class="line">            if (self.LoadingWindowsCancelCache != null &amp;&amp; self.LoadingWindowsCancelCache.Count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                foreach (var windowID in self.LoadingWindowsCancelCache)</span><br><span class="line">                &#123;</span><br><span class="line">                    UIBaseWindow window = self.GetUIBaseWindow(windowID);</span><br><span class="line">                    if (window != null&amp;&amp;window.WindowData.isLoaded)</span><br><span class="line">                    &#123;</span><br><span class="line">                        self.CloseWindow(windowID);</span><br><span class="line">                        self.ReadyToRemove.Add(windowID);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (self.ReadyToRemove.Count &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    foreach (var id in self.ReadyToRemove)</span><br><span class="line">                    &#123;</span><br><span class="line">                        self.LoadingWindowsCancelCache.Remove(id);</span><br><span class="line">                    &#125;</span><br><span class="line">                    self.ReadyToRemove.Clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>更改部分生命周期代码，提供可将WindowID生成在任意WindowType的接口，如ShowWindowInWindowType()，ShowWindowInWindowTypeAsync()</p></li><li><p>新增Editor中对于快捷赋值ABName和清空ABName的小轮子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[MenuItem(&quot;Assets/AssetBundle/NameUIPrefab&quot;)]</span><br><span class="line">        public static void NameAllUIPrefab()</span><br><span class="line">        &#123;</span><br><span class="line">            string suffix = &quot;.unity3d&quot;;</span><br><span class="line">            UnityEngine.Object[] selectAsset = Selection.GetFiltered&lt;UnityEngine.Object&gt;(SelectionMode.DeepAssets);</span><br><span class="line">            for (int i = 0; i &lt; selectAsset.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                string prefabName = AssetDatabase.GetAssetPath(selectAsset[i]);</span><br><span class="line">                //MARKER：判断是否是.prefab</span><br><span class="line">                if (prefabName.EndsWith(&quot;.prefab&quot;))</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.Log(prefabName);</span><br><span class="line">                    AssetImporter importer=AssetImporter.GetAtPath(prefabName);</span><br><span class="line">                    importer.assetBundleName = selectAsset[i].name.ToLower() + suffix;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            AssetDatabase.Refresh();</span><br><span class="line">            AssetDatabase.RemoveUnusedAssetBundleNames();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [MenuItem(&quot;Assets/AssetBundle/ClearABName&quot;)]</span><br><span class="line">        public static void ClearABName()</span><br><span class="line">        &#123;</span><br><span class="line">            UnityEngine.Object[] selectAsset = Selection.GetFiltered&lt;UnityEngine.Object&gt;(SelectionMode.DeepAssets);</span><br><span class="line">            for (int i = 0; i &lt; selectAsset.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                string prefabName = AssetDatabase.GetAssetPath(selectAsset[i]);</span><br><span class="line">                AssetImporter importer=AssetImporter.GetAtPath(prefabName);</span><br><span class="line">                importer.assetBundleName = string.Empty;</span><br><span class="line">                Debug.Log(prefabName);</span><br><span class="line">            &#125;</span><br><span class="line">            AssetDatabase.Refresh();</span><br><span class="line">            AssetDatabase.RemoveUnusedAssetBundleNames();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>11/23更新：<span style="color:red">生命周期中新增OnStart，OnResume两个周期</span></p><ul><li>OnStart 在第一次show且在OnShow前调用</li><li>OnResume在非第一次show且在OnShow前调用</li></ul></li><li><p>11/23更新：将EGUI的code生成中Behaviour部分（View）的生成抽离出来，单独作为一个右键扩展，方便更改UIPrefab内部GO后的代码再生成。</p></li><li><p><span style="color:red">11/28更新：更改子UI代码生成函数，适配ET6.0新版，在一个ViewComponent中可以有多个同类型的子UI</span></p><p>使用步骤：</p><ul><li><p>先设计子UI的UIPrefab，并右键点击SpawnEGUICode<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211128143508070.png" alt="image-20211128143508070"></p></li><li><p>在需要添加这个子UI的Dlg中，通过”子UI名_实际名称”的方法做标识，并右键Dlg点击SpawnEGUICode生成对应的EGUI代码</p><p>DlgTest的测试例子：<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211128143933465.png" alt="image-20211128143933465"></p></li><li><p>若后续有对这个Dlg的View进行更改，则只需要重新右键Dlg点击SpawnEGUIBehaviourCode即可<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211128144215486.png" alt="image-20211128144215486"></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> ET </tag>
            
            <tag> Unity框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ET框架的FSM状态机设计</title>
      <link href="/2021/11/15/%E5%9F%BA%E4%BA%8EET%E6%A1%86%E6%9E%B6%E7%9A%84FSM%E7%8A%B6%E6%80%81%E6%9C%BA%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/11/15/%E5%9F%BA%E4%BA%8EET%E6%A1%86%E6%9E%B6%E7%9A%84FSM%E7%8A%B6%E6%80%81%E6%9C%BA%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    FSM状态机可以说是RPG、ACT等类型游戏的必备架构，而因为ET框架中并不带有基于ECS组件式思想所设计的状态机，因此萌生了自己设计的想法。而在参考了花花的<a href="https://www.drflower.top/posts/87693e2f/">GameFramwork解析：有限状态机（FSM）</a>后想根据GF的思路来进行设计。<br>​    但在设计的过程中也踩了不少坑，首先GF的状态机采取了传统OOP思路，由FSM（状态机管理器，其继承自FsmBase并实现IFSM接口）管理其中的所有FSMState（状态部分），在其生命周期中调用状态中对应的函数（OnEnter、OnUpdate、OnLeave等）。因此在根据GF第一次设计出FSMComponent组件时发现还是离不开OOP的思想，甚至变成了OOP+ECS这种奇怪的组合，ET中Component存储数据与System做逻辑。</p><p>​    后续考虑后根据ECS的思想采用了和ET中UIEvent分发较为相似的思路。采用Attribute标记状态生命周期函数（OnInit、OnEnter、OnUpdate等）+全局FsmMgrComponent进行事件派发的方法。</p><h2 id="基础结构："><a href="#基础结构：" class="headerlink" title="基础结构："></a>基础结构：</h2><ul><li><p>FsmComponent中存储当前状态机名fsmName以及状态名stateName作为标识，同时也可记录下前一个状态名lastStateName，且保留有GF中用于在FSM中传递的数据流data。</p></li><li><p>全局具有FsmComponent，其在进入战斗场景阶段就加入到zoneScene中，在其组件的Awake函数中会搜索所有带有FsmAttribute的类，并将其对应的AFsmState加入到存储字典中，用于后续派发，<span style="color:red">避免了一个FsmComponent存储一个Fsm状态机且需实例化多个FsmState的情况，实现了FsmState的共用。（此时FsmState中仅存有对应的派发函数，不能在其类中设置变量，会造成多个同fsmName的FsmComponent的混用）</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public override void Awake(FsmMgrComponent self)</span><br><span class="line">&#123;</span><br><span class="line">    //将dll中具有Fsm标签的class加入到对应fsm的字典中</span><br><span class="line">    FsmMgrComponent.Instance = self;</span><br><span class="line">    self.allFsm = new Dictionary&lt;string, Fsm&gt;();</span><br><span class="line"></span><br><span class="line">    foreach (Type type in Game.EventSystem.GetTypes(typeof(FsmAttribute)))</span><br><span class="line">    &#123;</span><br><span class="line">        object[] attrs = type.GetCustomAttributes(typeof (FsmAttribute), false);</span><br><span class="line">        if(attrs.Length==0) continue;</span><br><span class="line"></span><br><span class="line">        FsmAttribute fsmAttribute = attrs[0] as FsmAttribute;</span><br><span class="line">        AFsmState aFsmState=Activator.CreateInstance(type) as AFsmState;</span><br><span class="line"></span><br><span class="line">        if (!self.allFsm.ContainsKey(fsmAttribute.fsmType))</span><br><span class="line">        &#123;</span><br><span class="line">            self.allFsm.Add(fsmAttribute.fsmType,new Fsm());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        self.allFsm[fsmAttribute.fsmType].allEvents.Add(type.Name.Split(&#x27;_&#x27;)[1],aFsmState);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AFsmState抽象类中具有OnEnter、Onupdate、OnExit、Ondestroy的对应状态派发函数，其传入值为当前调用的FsmComponent，同时使用data数据流进行不同生命周期函数间的交互。</p></li><li><p>保留了ECS思想中Component的通用性，也维护了GF的状态机中类似于<span style="color:red">FSMState&lt;Player&gt;的泛型标记，</span>转而用stateName来代替（ET中不存在泛型组件）。</p></li></ul><p>△后续进行流程图补充</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E5%9F%BA%E4%BA%8EET%E5%AE%9E%E7%8E%B0%E7%9A%84FSM%E7%8A%B6%E6%80%81%E6%9C%BA.drawio.png" alt="基于ET实现的FSM状态机.drawio"></p><h2 id="具体使用："><a href="#具体使用：" class="headerlink" title="具体使用："></a>具体使用：</h2><p>以一个角色Unit作为例子：</p><ol><li><p>在AfterOfflineUnitCreate的事件中加入FsmComponent，并设定其fsm类型名为FsmType.PlayerFSM，此时只会分发对应类型的FsmState</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AfterOfflineUnitCreate_CreateUnitView:AEvent&lt;EventType.AfterOfflineUnitCreate&gt;</span><br><span class="line">  &#123;</span><br><span class="line">      protected override async ETTask Run(AfterOfflineUnitCreate args)</span><br><span class="line">      &#123;</span><br><span class="line">       ......</span><br><span class="line">          </span><br><span class="line">          //每个Unit中加入FsmComponent用于管理状态机</span><br><span class="line">          FsmComponent fsm=args.unit.AddComponent&lt;FsmComponent,string&gt;(FsmType.PlayerFSM);</span><br><span class="line">          </span><br><span class="line">          ......</span><br><span class="line">          await ETTask.CompletedTask;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>书写好对应的IdleState、WalkState<br>PlayerFSM_IdleState:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace ET</span><br><span class="line">&#123;</span><br><span class="line">    [Fsm(FsmType.PlayerFSM)]</span><br><span class="line">    public class PlayerFSM_IdleState:AFsmState</span><br><span class="line">    &#123;</span><br><span class="line">        public override void OnEnter(FsmComponent fsmComponent)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;Enter idle&quot;);</span><br><span class="line">            </span><br><span class="line">            AnimatorComponent animatorComponent = fsmComponent.Parent.GetComponent&lt;AnimatorComponent&gt;();</span><br><span class="line"></span><br><span class="line">            if (animatorComponent != null)</span><br><span class="line">            &#123;</span><br><span class="line">                animatorComponent.MotionType = MotionType.Idle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void OnUpdate(FsmComponent fsmComponent)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;Update idle&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        public override void OnExit(FsmComponent fsmComponent)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;Exit idle&quot;);</span><br><span class="line">            AnimatorComponent animatorComponent = fsmComponent.Parent.GetComponent&lt;AnimatorComponent&gt;();</span><br><span class="line">            if (animatorComponent != null)</span><br><span class="line">            &#123;</span><br><span class="line">                animatorComponent.ResetMotionType();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public override void OnDestroy()</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PlayerFSM_WalkState:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace ET</span><br><span class="line">&#123;</span><br><span class="line">    [Fsm(FsmType.PlayerFSM)]</span><br><span class="line">    public class PlayerFSM_WalkState:AFsmState</span><br><span class="line">    &#123;</span><br><span class="line">        public override void OnEnter(FsmComponent uiComponent)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;Enter Walk&quot;);</span><br><span class="line">            AnimatorComponent animatorComponent = uiComponent.Parent.GetComponent&lt;AnimatorComponent&gt;();</span><br><span class="line"></span><br><span class="line">            if (animatorComponent != null)</span><br><span class="line">            &#123;</span><br><span class="line">                animatorComponent.MotionType = MotionType.Run;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void OnUpdate(FsmComponent uiComponent)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;Update Walk&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void OnExit(FsmComponent uiComponent)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;Leave Walk&quot;);</span><br><span class="line">            AnimatorComponent animatorComponent = uiComponent.Parent.GetComponent&lt;AnimatorComponent&gt;();</span><br><span class="line">            if (animatorComponent != null)</span><br><span class="line">            &#123;</span><br><span class="line">                animatorComponent.ResetMotionType();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public override void OnDestroy()</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在对应的Command命令的Execute函数中获取Unit的FsmComponent组件并切换状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">namespace ET.Demo.Command</span><br><span class="line">&#123;</span><br><span class="line">    [Command(CommandType.MoveCommand)]</span><br><span class="line">    public class MoveCommand:ACommand</span><br><span class="line">    &#123;</span><br><span class="line">        public override void OnInit(CommandComponent commandComponent)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Execute(CommandComponent commandComponent, TypeEntityPair entityPair,params object[] param)</span><br><span class="line">        &#123;</span><br><span class="line">            Entity entity = entityPair.entity;</span><br><span class="line">            FsmComponent fsm = entity.GetComponent&lt;FsmComponent&gt;();</span><br><span class="line">            if(fsm==null) return;</span><br><span class="line">            </span><br><span class="line">            if (!fsm.isRunning) fsm.Start(&quot;WalkState&quot;);</span><br><span class="line">            else fsm.ChangeState(&quot;WalkState&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="后期拓展："><a href="#后期拓展：" class="headerlink" title="后期拓展："></a>后期拓展：</h2><h3 id="增加类似baseState状态的复用机制："><a href="#增加类似baseState状态的复用机制：" class="headerlink" title="增加类似baseState状态的复用机制："></a>增加类似baseState状态的复用机制：</h3><p>​    <span style="color:red">在实际使用的过程发现无法实现状态机通用状态的复用，比如某个Enemy的攻击state具有特殊定义，也必须重写其他states并分离出一个新的FSM类型，因此对当前的ET状态机的部分逻辑进行更改。</span></p><p>​    以下是新版的FsmComponent，主要是加入了allStates来存储当前Fsm状态机中的所有状态，<span style="color:blue">无需再将FsmType作为一个类型导入，而是仅仅作为分发具体声明周期的查询参数。</span>并在Awake时赋值对其进行赋值</p><p>​    <strong>这里仅放上修改部分的流程图，其他和之前基本无变化</strong></p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E5%9F%BA%E4%BA%8EET%E7%9A%84FSM%E6%9B%B4%E6%94%B9.drawio_.png" alt="基于ET的FSM更改.drawio_"></p><ul><li>fsmName仅作为向FsmMgrComponent查询并分发对应生命周期函数的依据</li><li>allStates中存储状态机中所有可供转换的状态名</li><li>FsmComponent中的fsmName和allStates在AwakeSystem的Awake(…)中进行赋值</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> ET </tag>
            
            <tag> Unity </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode. 375.猜数字大小 II</title>
      <link href="/2021/11/12/Leetcode-375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F-II/"/>
      <url>/2021/11/12/Leetcode-375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="375-猜数字大小-II"><a href="#375-猜数字大小-II" class="headerlink" title="375. 猜数字大小 II"></a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211112102250370.png" alt="image-20211112102250370"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    动态规划的题目，太久没做类似的了没找到合适的思路，后面查看题解后发现能以dp[i][j]表示猜由i到j数的最小现金数。（可以将题目类比为背包，最小金额–最大价值，货物种类&amp;&amp;背包容量–猜数范围）</p><ul><li>递推式子在每次确定范围后为max(dp[k+1][j],dp[i][k-1])，<span style="color:red">因为要保证确保获胜，所以要取max。</span></li><li>当dp[i][i]时，不用支付现金，因此dp[i][i]=0</li><li>外层i确定每次遍历左边界，外层j确定每次遍历右边界，因为初始化时已经让dp中所有元素都为0，所以外层遍历直接保证i!=j即可，无需重复赋值0</li><li>根据范围遍历范围内所有可能的猜数情况，根据递推式求出各个情况的保证获胜的最小金额数，将其最小值赋值给dp[i][j]</li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//动态规划问题，最小现金数可以类比为背包问题中的最大价值</span></span><br><span class="line">        <span class="comment">//设定dp[i][j]为从i到j中猜数所需要的支付的最小现金数</span></span><br><span class="line">        <span class="comment">//递推式子在每次猜数遍历后为min(dp[x+1][j],dp[i][x-1])+x;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化数组(或者用vector来存储)</span></span><br><span class="line">        <span class="keyword">int</span>** dp = <span class="keyword">new</span> <span class="keyword">int</span>* [n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//vector&lt;vector&lt;int&gt;&gt;(n+1,vector&lt;int&gt;(n+1));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++) &#123; </span><br><span class="line">                <span class="comment">//找到在对应范围内的最小现金数</span></span><br><span class="line">                <span class="keyword">int</span> min_cost = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123; </span><br><span class="line">                    <span class="keyword">int</span> cost = <span class="built_in">max</span>(dp[k + <span class="number">1</span>][j], dp[i][k - <span class="number">1</span>]) + k;<span class="comment">//为了保证在所有情况下都能获胜，应考虑最坏情况</span></span><br><span class="line">                    min_cost = <span class="built_in">min</span>(min_cost, cost);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = min_cost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 495.提莫攻击</title>
      <link href="/2021/11/10/Leetcode-495-%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/"/>
      <url>/2021/11/10/Leetcode-495-%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495. 提莫攻击"></a><a href="https://leetcode-cn.com/problems/teemo-attacking/">495. 提莫攻击</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211110100157656.png" alt="image-20211110100157656"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    一开始想着直接用set来去重，结果肯定是直接超时了。<br>​    后续考虑到给出的timeSeries是非递减的形式，可以用单次遍历的方法，用t存储下当前中毒结束时间。</p><ul><li>当t&lt;timeSeries[i]+duration时，表示着这个结束时间需要刷新，因此先对结果res+=timeSeries[i]+duration-t-max(timeSeries[i]-t,0) <span style="color:red">(后续的max是因为考虑到若中途有非中毒时间要减去)</span>，同时更新t=timeSeries[i]+duration</li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用hashset记录下时间节点去重，最后获取其size()即可获得秒数（超时）</span></span><br><span class="line">        <span class="comment">// set&lt;int&gt; s;</span></span><br><span class="line">        <span class="comment">// int len=timeSeries.size();</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;len;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;duration;j++)&#123;</span></span><br><span class="line">        <span class="comment">//         s.insert(timeSeries[i]+j);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return s.size();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历时记录下实际中毒的最大秒数</span></span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=timeSeries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t&lt;timeSeries[i]+duration)&#123;</span><br><span class="line">                res+=timeSeries[i]+duration-t-<span class="built_in">max</span>(timeSeries[i]-t,<span class="number">0</span>);</span><br><span class="line">                t=timeSeries[i]+duration;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 488.祖玛游戏</title>
      <link href="/2021/11/09/Leetcode-488-%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/11/09/Leetcode-488-%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="488-祖玛游戏"><a href="#488-祖玛游戏" class="headerlink" title="488. 祖玛游戏"></a><a href="https://leetcode-cn.com/problems/zuma-game/">488. 祖玛游戏</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211109101310993.png" alt="image-20211109101310993"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    在刚开始看题时虽然想到了可能要用dfs来解决，但是对于每次插入球后的消球过程没有特别好的解决思路，后续参考了其他的题解后才得到了<span style="color:red">快慢指针</span>用于处理插入球后的消除过程的Update思路，并且也考虑到了记忆化搜索优化超时。</p><ul><li>整个解题过程分为两个阶段，DFS+记忆化搜索+回溯与每次插入后的消除过程<ul><li>每次插入后的消除过程采用了快慢指针的方式，设slow指针和fast指针的初始值为0，fast遍历插入球后的整个字符串。<ul><li>若fast&lt;board.size()且board[fast]==board[slow]则代表当前slow和fast所指代的球的颜色是相同的，进行continue的操作</li><li>若fast-slow&gt;=3则代表当前慢指针slow到快指针fast之间为三个或三个颜色相同以上的球，因此用string.erase来进行消除操作，同时设fast=0，需要重新进行遍历</li><li>每次遍历结束的末尾需要将slow=fast，因为当前指代的是fast与slow中指代的不是相同颜色的球，所以slow的判断可以继续往下来搜索。</li></ul></li><li>主函数通过DFS+记忆化搜索+回溯的方式<ul><li>用set&lt;pair&lt;string,int&gt;&gt;的vis来存储对应的board字符串板子对应已经扔球的次数，来防止有重复的DFS过程发生</li><li>对于每次的DFS过程都需要遍历当前的board的每一个位置以及当前手上的所有球，并且创建好新的插入球的板子nb并且进行Update过程，所得到的nb进入下一层的DFS过程，<span style="color:red">并且因为是&amp;hand，记住要进行回溯操作，即在该层dfs结束后把扔进去的球重新加入到hand中。</span></li></ul></li></ul></li></ul><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> min_cnt = INT_MAX;</span><br><span class="line">    set&lt;pair&lt;string, <span class="keyword">int</span>&gt; &gt; vis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//△重点看一下这个面板的更新，消球的过程</span></span><br><span class="line">    <span class="comment">//快慢指针的使用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateBoard</span><span class="params">(string&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了最后一次判断fast需要&lt;=board.size()</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>; fast &lt;= board.<span class="built_in">size</span>(); fast++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (fast &lt; board.<span class="built_in">size</span>() &amp;&amp; board[slow] == board[fast]) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">if</span> (fast - slow &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">               board.<span class="built_in">erase</span>(slow, fast - slow);</span><br><span class="line">               fast = <span class="number">0</span>; <span class="comment">//这里一定要重新从0索引开始寻找，因为可能会因为消球出现新的情况</span></span><br><span class="line">           &#125;</span><br><span class="line">           slow = fast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dfs+记忆化搜索的思路</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(string&amp; board, string&amp; hand, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= min_cnt) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (vis.<span class="built_in">count</span>(&#123;board, cnt&#125;)) <span class="keyword">return</span>; <span class="comment">//剪枝，这里要记下cnt的原因是同一个板子可能是经过了不同次数的插球导致的</span></span><br><span class="line">        vis.<span class="built_in">insert</span>(&#123;board, cnt&#125;); <span class="comment">//将板子对应其插球个数加入到记忆化set中</span></span><br><span class="line">        <span class="keyword">if</span> (board==<span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            min_cnt = <span class="built_in">min</span>(min_cnt, cnt); <span class="comment">//找到了将球全部消除的次数，与当前最小次数取最小值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hand==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>(), m = hand.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">char</span> ch = hand[j];</span><br><span class="line">                hand.<span class="built_in">erase</span>(hand.<span class="built_in">begin</span>() + j); </span><br><span class="line">                <span class="comment">//创建新的插入球后的板子</span></span><br><span class="line">                string nb = board;</span><br><span class="line">                nb.<span class="built_in">insert</span>(nb.<span class="built_in">begin</span>() + i, ch);</span><br><span class="line">                <span class="built_in">UpdateBoard</span>(nb);</span><br><span class="line">                <span class="built_in">DFS</span>(nb, hand, cnt + <span class="number">1</span>); <span class="comment">//dfs过程</span></span><br><span class="line">                hand.<span class="built_in">insert</span>(hand.<span class="built_in">begin</span>() + j, ch); <span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinStep</span><span class="params">(string board, string hand)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(board, hand, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> min_cnt == INT_MAX ? <span class="number">-1</span> : min_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 299.猜数字游戏</title>
      <link href="/2021/11/08/Leetcode-299-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/11/08/Leetcode-299-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299. 猜数字游戏"></a><a href="https://leetcode-cn.com/problems/bulls-and-cows/">299. 猜数字游戏</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211108101910571.png" alt="image-20211108101910571"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题公牛是比较好求的，遍历secret和guess判断对应字符是否相等即可，但是奶牛的思路需要转换，题目中的含义是数字猜对但是位置不对，这里可以分为两种情况。</p><ol><li>在对应位置上不相同时，secret中该数字的出现次数比guess少，这时对于guess来说只能填补secret字符中该数字的个数，guess多出字符无用，所以结果应取secret中该数字的次数</li><li>在对应位置上不相同时，secret中该数字的出现次数比guess多，这时对于guess来说只能填补自身数量的secret字符，secret多出字符无用，所以结果应取guess中该数字出现的次数</li></ol><p>综上所述其实可以把奶牛的求解通过这样的方式：用哈希表arr1和arr2分别存储secret和guess中对应数字的存储次数，而后对于每个数字来说求arr1与arr2中对应数字的最小值，其的和为奶牛的个数。</p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getHint</span><span class="params">(string secret, string guess)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用两个哈希表分别存储secret和guess的对应数字的个数</span></span><br><span class="line">        <span class="keyword">int</span> len=secret.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> arr1[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;,arr2[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ANum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(secret[i]==guess[i])&#123;</span><br><span class="line">                ++ANum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr1[secret[i]-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">            arr2[guess[i]-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到arr1和arr2中对应数字的最小值</span></span><br><span class="line">        <span class="keyword">int</span> BNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            BNum+=<span class="built_in">min</span>(arr1[i],arr2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组合答案</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(ANum)+<span class="string">&quot;A&quot;</span>+<span class="built_in">to_string</span>(BNum)+<span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 598.范围求和 II</title>
      <link href="/2021/11/07/Leetcode-598-%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8C-II/"/>
      <url>/2021/11/07/Leetcode-598-%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8C-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="598-范围求和-II"><a href="#598-范围求和-II" class="headerlink" title="598. 范围求和 II"></a><a href="https://leetcode-cn.com/problems/range-addition-ii/">598. 范围求和 II</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211107100449476.png" alt="image-20211107100449476"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题可以将思路转变为求operations中所表示的所有矩形中相交最多次数的矩形面积，同时根据题目要求，其每个矩形都是以左上角为起点，这样就转换为了<span style="color:red">求operations中代表矩形的长、宽的最小值</span>，其相乘即为最终结果，同时<span style="color:red">长、宽的初始值为m,n</span>。</p><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ops)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这题可以引申为求包围的最小的矩形面积</span></span><br><span class="line">        <span class="keyword">int</span> w=m,h=n;</span><br><span class="line">        <span class="keyword">int</span> len=ops.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            w=<span class="built_in">min</span>(ops[i][<span class="number">0</span>],w);</span><br><span class="line">            h=<span class="built_in">min</span>(ops[i][<span class="number">1</span>],h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w*h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 268.丢失的数字</title>
      <link href="/2021/11/06/Leetcode-268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/11/06/Leetcode-268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a><a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211106165705668.png" alt="image-20211106165705668"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题比较简单，用哈希表记录下出现的次数，然后找到哈希表中value为0的唯一值即可。</p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用哈希表记录下出现的数字</span></span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> *arr=<span class="keyword">new</span> <span class="keyword">int</span>[len]();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            arr[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到arr中值为0的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==<span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 1218.最长定差子序列</title>
      <link href="/2021/11/05/Leetcode-1218-%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2021/11/05/Leetcode-1218-%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1218-最长定差子序列"><a href="#1218-最长定差子序列" class="headerlink" title="1218. 最长定差子序列"></a><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">1218. 最长定差子序列</a></h2><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211105194905197.png" alt="image-20211105194905197"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题是动态规划的题目，其实往深了看可以作为一个背包问题，arr中元素为每件物品的权重，而等差数列则是每件物品权重判断的条件，在内部将背包问题中的max()求最大存储物品数量改为等差数列长度+1。</p><p>方法思路：</p><ul><li>map第一个元素表示符合等差数列的最后一个元素，第二个表示该等差数列的长度</li><li>遍历arr的元素，若m不存在则加入其中，若存在则获取其长度后+1赋值给当前元素对应值</li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="comment">//第一个元素表示符合等差数列的最后一个元素，第二个表示该等差数列的长度</span></span><br><span class="line">        <span class="comment">//遍历arr的元素，若m不存在则加入其中，若存在则获取其长度后+1赋值给当前元素对应值</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:arr)&#123;</span><br><span class="line">            m[num]=m[num-difference]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找最大长度</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter=m.<span class="built_in">begin</span>();iter!=m.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,iter-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 367.有效的完全平方数</title>
      <link href="/2021/11/04/Leetcode-367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
      <url>/2021/11/04/Leetcode-367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数</a></h2><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211104191909465.png" alt="image-20211104191909465"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题主要是优化的方法采取了二分法的方法，是可以作为一些题目中遍历搜索的优化解的。其余的就是注意int的乘法会造成越界，结果应该转换为long类型来存储。</p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二分法思路优化</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=num;</span><br><span class="line">        <span class="keyword">int</span> half;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            half=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> temp=(<span class="keyword">long</span>)half*half;</span><br><span class="line">            <span class="keyword">if</span>(num==temp)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;temp)&#123;</span><br><span class="line">                right=half<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=half+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 575.分糖果</title>
      <link href="/2021/11/01/Leetcode-575-%E5%88%86%E7%B3%96%E6%9E%9C/"/>
      <url>/2021/11/01/Leetcode-575-%E5%88%86%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="575-分糖果"><a href="#575-分糖果" class="headerlink" title="575. 分糖果"></a><a href="https://leetcode-cn.com/problems/distribute-candies/">575. 分糖果</a></h2><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211101124624197.png" alt="image-20211101124624197"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题比较简单，一共有两种解题思路。</p><ul><li>用hash表记录下当前糖果种类，在其与平均分数目之间取最小值</li><li>模拟整个分配过程，现将第一个分给妹妹，后续用leftCount记录下剩余可以分配的数量，并且在排序后通过candyType[i]&gt;candyType[i-1]判断是否是新种类</li></ul><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candyType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法1：</span></span><br><span class="line">        <span class="comment">//用hash表记录下当前糖果种类</span></span><br><span class="line">        <span class="comment">// unordered_map&lt;int,int&gt; m;</span></span><br><span class="line">        <span class="comment">// for(auto type:candyType)&#123;</span></span><br><span class="line">        <span class="comment">//     ++m[type];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int type_count=0;</span></span><br><span class="line">        <span class="comment">// for(auto pair:m)&#123;</span></span><br><span class="line">        <span class="comment">//     ++type_count;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// return min(type_count,(int)candyType.size()/2);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法2</span></span><br><span class="line">        <span class="comment">//模拟整个分配过程</span></span><br><span class="line">        <span class="keyword">int</span> length=candyType.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> leftCount=length/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxType=<span class="number">1</span>;<span class="comment">//现将第一个分给妹妹</span></span><br><span class="line">        <span class="built_in">sort</span>(candyType.<span class="built_in">begin</span>(),candyType.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length&amp;&amp;leftCount&gt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candyType[i]&gt;candyType[i<span class="number">-1</span>])&#123;</span><br><span class="line">                leftCount--;</span><br><span class="line">                maxType++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 500.键盘行</title>
      <link href="/2021/10/31/Leetcode-500-%E9%94%AE%E7%9B%98%E8%A1%8C/"/>
      <url>/2021/10/31/Leetcode-500-%E9%94%AE%E7%9B%98%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="500. 键盘行"></a><a href="https://leetcode-cn.com/problems/keyboard-row/">500. 键盘行</a></h2><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211031150045980.png" alt="image-20211031150045980"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题主要就是用哈希表记录下对应字符的行数，而后遍历所有的words判断字符串是否在同一行即可，时间复杂度为O(n*m)（n为words长度，m为单个word长度）</p><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ch2line[<span class="number">26</span>]=&#123;</span><br><span class="line">        <span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=words.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            string word=words[i];</span><br><span class="line">            <span class="keyword">int</span> len=word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> type=ch2line[<span class="built_in">tolower</span>(word[<span class="number">0</span>])-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(type!=ch2line[<span class="built_in">tolower</span>(word[j])-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==len) res.<span class="built_in">push_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 260:只出现一次的数字 III</title>
      <link href="/2021/10/30/Leetcode-260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-III/"/>
      <url>/2021/10/30/Leetcode-260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-III/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h1><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211030142711412.png" alt="image-20211030142711412"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题首先最简单的方法肯定是遍历+哈希表记录次数的方法，主要说第二种优化了空间复杂度的方法。</p><ul><li><p>遍历nums的所有元素并进行异或处理，得到temp</p></li><li><p>获取temp的最低位1，由此就可以将恰好出现一次的两个元素分成两组</p><ul><li>temp^(-temp)的方法获取最低位1（-temp其实对应二进制的取反+1，若原位为1则变为0，+1后&amp;为1，若原位为0则变为1，+1后向前进位且&amp;结果为0，因此恰好可以获取到最低位1）</li><li>设定lowOne=1，while(lowOne&amp;temp==0) lowOne&lt;&lt;=1; （也就是逐步左移判断）</li></ul></li><li><p>遍历nums的所有元素，根据得到得到lowOne*nums[i]判断所在组，同组的所有元素再进行异或操作，就能得到两个结果，返回即可。</p></li></ul><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用最低位1将得到的结果分成两个部分</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            temp^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最低位1的两种方法</span></span><br><span class="line">        <span class="comment">//方法1</span></span><br><span class="line">        <span class="comment">//int lowOne=temp==INT_MIN?temp:temp&amp;(-temp); </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法2</span></span><br><span class="line">        <span class="keyword">int</span> lowOne=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((lowOne&amp;temp)==<span class="number">0</span>) lowOne&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&amp;lowOne)&#123;</span><br><span class="line">                ans1^=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans2^=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;ans1,ans2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 335.路径交叉</title>
      <link href="/2021/10/29/Leetcode-335-%E8%B7%AF%E5%BE%84%E4%BA%A4%E5%8F%89/"/>
      <url>/2021/10/29/Leetcode-335-%E8%B7%AF%E5%BE%84%E4%BA%A4%E5%8F%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="335-路径交叉"><a href="#335-路径交叉" class="headerlink" title="335. 路径交叉"></a><a href="https://leetcode-cn.com/problems/self-crossing/">335. 路径交叉</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211029102151630.png" alt="image-20211029102151630"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这种归纳的题目是真的不太熟且感觉意义不大。。，根据题解，最多只需要关注最近所画的五条边即可，且总共具有四种可能的情况，如下图所示，分别根据四种可能的情况列出if的判断式子即可。</p><p><img src="https://pic.leetcode-cn.com/1635437888-JuQzXp-007S8ZIlly1ghltxkbce9j30ro0o676d.jpg" alt="示例"></p><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSelfCrossing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; distance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一道类似归纳的题目</span></span><br><span class="line">        <span class="comment">//只需要关注近5条边即可</span></span><br><span class="line">        <span class="keyword">int</span> length=distance.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="comment">//第一种情况</span></span><br><span class="line">            <span class="keyword">if</span> (distance[i<span class="number">-1</span>]&lt;=distance[i<span class="number">-3</span>]&amp;&amp;distance[i]&gt;=distance[i<span class="number">-2</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">4</span>&amp;&amp;distance[i]+distance[i<span class="number">-4</span>]==distance[i<span class="number">-2</span>]&amp;&amp;distance[i<span class="number">-1</span>]==distance[i<span class="number">-3</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">5</span>&amp;&amp;distance[i<span class="number">-4</span>]&lt;=distance[i<span class="number">-2</span>]&amp;&amp;distance[i]&gt;=distance[i<span class="number">-2</span>]-distance[i<span class="number">-4</span>]&amp;&amp;distance[i<span class="number">-1</span>]&gt;=distance[i<span class="number">-3</span>]-distance[i<span class="number">-5</span>]&amp;&amp;distance[i<span class="number">-1</span>]&lt;=distance[i<span class="number">-3</span>]&amp;&amp;distance[i<span class="number">-3</span>]&gt;=distance[i<span class="number">-5</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>869. 重新排序得到2的幂</title>
      <link href="/2021/10/28/869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/"/>
      <url>/2021/10/28/869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="869-重新排序得到-2-的幂"><a href="#869-重新排序得到-2-的幂" class="headerlink" title="869. 重新排序得到 2 的幂"></a><a href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></h2><p><img src="/2021/10/28/869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/image-20211028104103060.png" alt="image-20211028104103060"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题是可以说是把两道题混合在了一起，分别是<a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a>和<a href="https://leetcode-cn.com/problems/power-of-two/">231. 2 的幂</a>，先通过前者求出全排列（回溯），当判断出现了符合要求的数后对后续进行剪枝操作即可。</p><ul><li>注意Swap交换数字位置进行迭代之后要再通过Swap进行还原</li></ul><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isSucc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//求全排列后逐个判断是否是2的幂</span></span><br><span class="line">        isSucc=<span class="literal">false</span>;</span><br><span class="line">        string str=<span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>()); <span class="comment">//先进行排序(减少无用的匹配次数)</span></span><br><span class="line">        <span class="built_in">GetAllOrder</span>(str,<span class="number">0</span>,str.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> isSucc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetAllOrder</span><span class="params">(string&amp; str,<span class="keyword">int</span> index,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(str)) isSucc=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index==<span class="number">0</span>&amp;&amp;str[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//跳过首位为0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Swap</span>(str,index,i);</span><br><span class="line">            <span class="built_in">GetAllOrder</span>(str,index+<span class="number">1</span>,length);</span><br><span class="line">            <span class="built_in">Swap</span>(str,index,i);</span><br><span class="line">            <span class="keyword">if</span>(isSucc) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> string&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> (n&amp;(n<span class="number">-1</span>))==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(string &amp;str,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp=str[n];</span><br><span class="line">        str[n]=str[m];</span><br><span class="line">        str[m]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 301 删除无效的括号</title>
      <link href="/2021/10/27/Leetcode-301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/2021/10/27/Leetcode-301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="301-删除无效的括号"><a href="#301-删除无效的括号" class="headerlink" title="301. 删除无效的括号"></a><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></h2><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211027104415171.png" alt="image-20211027104415171"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题采用了BFS的思路，因为题目要求中需要删除最少的无效括号来满足要求。所以我们采用了层级划分的方法。</p><ul><li>每次递归都会遍历删除相同数量的括号所有字符串，判断其是否合法，合法则将其加入到结果res的向量中</li><li>每次递归都会在第一步后判断ans的数量是否大于0，大于则表示当前层级是删除最少的无效括号的情况，直接return即可</li><li>若无ans，则用nextSet记录下下一个层级的所有可能字符串(用str.substr(0,i)+str.substr(i+1)来进行切割)，<span style="color:red">△注意这里即便判断了s[i]==s[i-1]执行continue，还是需要set来进行去重操作，因为在最后只剩下一个括号时会导致重复情况。</span></li></ul><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//采用BFS的方式遍历,用set+判断来去重</span></span><br><span class="line">        unordered_set&lt;string&gt; set;</span><br><span class="line">        set.<span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="built_in">BFS</span>(set);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(unordered_set&lt;string&gt; &amp;curStr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//BFS层次遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:curStr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(str))&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在某个层级中有解则return</span></span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; nextSet;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:curStr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;s[i]==s[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>||s[i]==<span class="string">&#x27;)&#x27;</span>) nextSet.<span class="built_in">insert</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, i) + s.<span class="built_in">substr</span>(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">BFS</span>(nextSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 496 下一个更大元素 I</title>
      <link href="/2021/10/26/Leetcode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/"/>
      <url>/2021/10/26/Leetcode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h2><p><img src="/2021/10/26/Leetcode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/image-20211026095137887.png" alt="image-20211026095137887"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题通过暴力法的话时间复杂度为O(nums1.length*nums2.length)。</p><p>​    但是能引出一种时间复杂度为O(nums1.length+nums2.length)的思路，即单调栈+哈希表的方法。</p><p>​    整体思路(s为栈,m为哈希表,res为结果向量)：</p><ol><li><p>反向遍历nums2，每次遍历时在栈中令s.top()和nums2[i]进行比较，排出栈中所有比nums2[i]小的元素，将栈顶元素结果存储在m[nums2[i]]中，并在最后将nums2[i]加入到栈中</p></li><li><p>遍历nums1，每次遍历时将其在m中对应结果加入到res中（即res.push_back(m[nums1[i]])）;</p><p><span style="color:red">△这种思路同样能引用于在vector中寻找第一个满足于<strong>某个条件</strong>的元素，只需要通过单调栈+反向遍历的方式即可，在遍历时循环判断若当前栈顶元素满足时遍历元素是否一定满足，若是则弹出栈顶元素即可。最后再将遍历元素加入到栈顶元素中。</span></p><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//考虑使用单调栈+哈希表的方式</span></span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//构建nums2的单调栈和结果哈希表</span></span><br><span class="line">        <span class="keyword">int</span> len2=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> len1=nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len2<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;nums2[i]&gt;=s.<span class="built_in">top</span>())&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums2[i]]=s.<span class="built_in">empty</span>()?<span class="number">-1</span>:s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//nums1根据nums2的结果哈希表获取最终结果加入res</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;++i)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(m[nums1[i]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 240 搜索二维矩阵 II</title>
      <link href="/2021/10/25/Leetcode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/"/>
      <url>/2021/10/25/Leetcode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><p><img src="/2021/10/25/Leetcode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/image-20211025100921484.png" alt="image-20211025100921484"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这道题的关键是找到右上角作为起始点，这样的话整个矩阵就能看做是一个二叉搜索树。</p><ul><li>以n,m为行列，判断情况如下：<ul><li>如果target&lt;matrix[n][m]，则取二叉搜索树中的左子树，即n–</li><li>如果target&gt;matrix[n][m]，则取二叉搜索树中的右子树，即m++</li><li>如果target==matrix[n][m]，则直接返回true</li></ul></li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从右上角开始二叉树搜索</span></span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>,row=matrix.<span class="built_in">size</span>(),m=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;row&amp;&amp;m&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;matrix[n][m])&#123;</span><br><span class="line">                m--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;matrix[n][m])&#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 638大礼包（记忆化DFS）</title>
      <link href="/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/"/>
      <url>/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638. 大礼包"></a><a href="https://leetcode-cn.com/problems/shopping-offers/">638. 大礼包</a></h2><p><img src="/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/image-20211024113701934.png" alt="image-20211024113701934"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><h4 id="基础代码："><a href="#基础代码：" class="headerlink" title="基础代码："></a>基础代码：</h4><p>​    近期花时间比较长的一道题，一开始以为是动态规划的题目，后面发现思路走不通换成DFS的思路。主要还是通过深搜+剪枝来获取所有可能的情况，而后通过min()来获取其最小值。</p><ul><li>用minPrice来作为最小值的记录，在最外层for循环结束（即当前层级的所有可能性结束后）返回</li><li>记录下lastPrice，其作为递归向下寻找可能性的依据，需要作为参数单独传入dfs函数中,<span style="color:red">一开始是把minPrice传进去，思路肯定是不对的（这样的话totalPrice就没办法保存下来了）。</span></li><li>记录下curPackagePrice，表示当前购买礼包所花费的价钱，根据其和needs计算后续的总价格totalPrice。</li><li>在每次循环过后要对needs和curPackagePrice进行还原</li><li><span style="color:red"><strong>注意：minPrice仅代表当前DFS层级上的最小价格。</strong></span></li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dfs递归</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter = <span class="built_in">RemovePackages</span>(price, special, needs);</span><br><span class="line">        <span class="keyword">int</span> lastPrice=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            lastPrice+=needs[i]*price[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, filter, needs,<span class="number">0</span>,lastPrice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">RemovePackages</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs) &#123;</span><br><span class="line">        <span class="comment">//排除掉收益不如单买的special</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; special.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; special[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                temp += price[j]*special[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; special[i].<span class="built_in">back</span>()) &#123;</span><br><span class="line">                filter.<span class="built_in">push_back</span>(special[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; filter, vector&lt;<span class="keyword">int</span>&gt;&amp; needs,<span class="keyword">int</span> curPackagePrice,<span class="keyword">int</span> lastPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalPrice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = lastPrice; <span class="comment">//在当前已有</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filter.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> succ = <span class="literal">true</span>;</span><br><span class="line">            totalPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (needs[j] &lt; filter[i][j]) &#123;</span><br><span class="line">                    succ = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!succ) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//加上礼包和剩余的单买</span></span><br><span class="line">                curPackagePrice += filter[i].<span class="built_in">back</span>();</span><br><span class="line">                totalPrice += curPackagePrice;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; needs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    needs[j] -= filter[i][j];</span><br><span class="line">                    totalPrice += needs[j] * price[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice,<span class="built_in">dfs</span>(price, filter, needs,curPackagePrice,totalPrice));</span><br><span class="line">            <span class="comment">//加回之前减去的package</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>()<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                needs[j] += filter[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            curPackagePrice -= filter[i].<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="优化过程："><a href="#优化过程：" class="headerlink" title="优化过程："></a>优化过程：</h4><p><span style="color:red">△发现还是有可优化的点，可以把curPackagePrice和lastPrice去掉</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dfs递归</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter = <span class="built_in">RemovePackages</span>(price, special, needs);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, filter, needs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">RemovePackages</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs) &#123;</span><br><span class="line">        <span class="comment">//排除掉收益不如单买的special</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; special.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; special[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                temp += price[j]*special[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; special[i].<span class="built_in">back</span>()) &#123;</span><br><span class="line">                filter.<span class="built_in">push_back</span>(special[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; filter, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minPrice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            minPrice+=needs[i]*price[i]; <span class="comment">//△全买情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filter.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> succ = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (needs[j] &lt; filter[i][j]) &#123;</span><br><span class="line">                    succ = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!succ) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; needs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    needs[j] -= filter[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice,<span class="built_in">dfs</span>(price, filter, needs)+filter[i].<span class="built_in">back</span>());</span><br><span class="line">            <span class="comment">//加回之前减去的package</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>()<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                needs[j] += filter[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>附带上官方题解的记忆化深搜</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;vector&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = price.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤不需要计算的大礼包，只保留需要计算的大礼包</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filterSpecial;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; sp : special) &#123;</span><br><span class="line">            <span class="keyword">int</span> totalCount = <span class="number">0</span>, totalPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                totalCount += sp[i];</span><br><span class="line">                totalPrice += sp[i] * price[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (totalCount &gt; <span class="number">0</span> &amp;&amp; totalPrice &gt; sp[n]) &#123;</span><br><span class="line">                filterSpecial.<span class="built_in">emplace_back</span>(sp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, special, needs, filterSpecial, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索计算满足购物清单所需花费的最低价格</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; price,<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp; special, vector&lt;<span class="keyword">int</span>&gt; curNeeds, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp; filterSpecial, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!memo.<span class="built_in">count</span>(curNeeds)) &#123;</span><br><span class="line">            <span class="keyword">int</span> minPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                minPrice += curNeeds[i] * price[i]; <span class="comment">// 不购买任何大礼包，原价购买购物清单中的所有物品</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; curSpecial : filterSpecial) &#123;</span><br><span class="line">                <span class="keyword">int</span> specialPrice = curSpecial[n];</span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; nxtNeeds;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (curSpecial[i] &gt; curNeeds[i]) &#123; <span class="comment">// 不能购买超出购物清单指定数量的物品</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nxtNeeds.<span class="built_in">emplace_back</span>(curNeeds[i] - curSpecial[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nxtNeeds.<span class="built_in">size</span>() == n) &#123; <span class="comment">// 大礼包可以购买</span></span><br><span class="line">                    minPrice = <span class="built_in">min</span>(minPrice, <span class="built_in">dfs</span>(price, special, nxtNeeds, filterSpecial, n) + specialPrice);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[curNeeds] = minPrice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[curNeeds];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><span style="color:red">△查看之后发现自己上面的那种方法还是会出现重复计算的情况，没有去应用到<strong>记忆化</strong>的目的，还是再跟着思路去敲一遍。</span></p><p><span style="color:blue"><strong>稍微简化了一下题解的记忆化深搜：</strong></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;vector&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; memo; <span class="comment">//记忆化数组，记录下对应购买情况下的价格，防止重复计算</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dfs记忆化递归</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter = <span class="built_in">RemovePackages</span>(price, special, needs);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(price, filter, needs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">RemovePackages</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; special, vector&lt;<span class="keyword">int</span>&gt;&amp; needs) &#123;</span><br><span class="line">        <span class="comment">//排除掉收益不如单买的special</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; filter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; special.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; special[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                temp += price[j]*special[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; special[i].<span class="built_in">back</span>()) &#123;</span><br><span class="line">                filter.<span class="built_in">push_back</span>(special[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; filter, vector&lt;<span class="keyword">int</span>&gt;&amp; needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!memo.<span class="built_in">count</span>(needs))&#123;</span><br><span class="line">            <span class="keyword">int</span> minPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;needs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                minPrice+=needs[i]*price[i]; <span class="comment">//△全买情况</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filter.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">bool</span> succ = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (needs[j] &lt; filter[i][j]) &#123;</span><br><span class="line">                        succ = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!succ) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; needs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                        needs[j] -= filter[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                minPrice = <span class="built_in">min</span>(minPrice,<span class="built_in">dfs</span>(price, filter, needs)+filter[i].<span class="built_in">back</span>());</span><br><span class="line">                <span class="comment">//加回之前减去的package</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filter[i].<span class="built_in">size</span>()<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                    needs[j] += filter[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo[needs]=minPrice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo.<span class="built_in">count</span>(needs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后也算优化到比较好的情况：</p><p><img src="/2021/10/24/Leetcode-638%E5%A4%A7%E7%A4%BC%E5%8C%85/image-20211024123941326.png" alt="image-20211024123941326"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET框架：Async和await，ETVoid与ETTask</title>
      <link href="/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/"/>
      <url>/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    看ET框架时发现其广泛使用了ETVoid、ETTask的异步处理方式，同时也有段时间没复习await/async的有关内容了，所以也趁这个机会重新看一看。</p><ul><li>参考资料</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4.1ETTask:</span><br><span class="line">https://www.yuque.com/et-xd/docs/wyr682</span><br><span class="line">ET篇：ETVoid和void，ETTask和Task的区别与使用时机:</span><br><span class="line">https://www.lfzxb.top/et-ettask-etvoid/</span><br><span class="line">C# async 和 await 理解：</span><br><span class="line">https://blog.csdn.net/a462533587/article/details/82261468</span><br><span class="line">字母哥：【ET框架课程】08-异步编程与ETTask的使用</span><br><span class="line">https://www.bilibili.com/video/BV1sV411J7wJ?spm_id_from=333.999.0.0</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ET方面：<ul><li>ET框架是单线程逻辑，ETTask是一个轻量级单线程的Task，相比Task性能更强，本质上可以说是协程</li><li>ETTask就是把回调改成同步的写法，具体是单线程回调还是多线程回调都与ETTask无关</li><li>ETVoid是代替async void ，意思是新开一个<span style="color:red">协程</span></li><li>ETTask的Coroutine方法是为了无GC，ETTask必须<strong>await或者调用coroutine</strong>才能回收重用ETTaskCompletionSource</li></ul></li><li>await/task方面：<ul><li>Task本身与多线程无关，而Task.Run()等创建函数中则会将线程池中的线程分配给创建出来的Task</li><li>await本身与多线程无关，只是会在async函数中根据await切分为几段，做成一个状态机，将其中的每一段都用一个task来分割，在这个task.Complete被执行的时候将状态机.next()方法压入到同步上下文中，最后调用状态机.Next()执行await之后的流程。</li></ul></li></ul><h3 id="await和async"><a href="#await和async" class="headerlink" title="await和async"></a>await和async</h3><p>首先以一个代码例子来作为切入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace asyncTest</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Test();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static async void Test()</span><br><span class="line">        &#123;</span><br><span class="line">            //MARKER:这里创建了一个新的状态机来划分await</span><br><span class="line">            Console.WriteLine(&quot;main:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            await Method4(); //这里做了第一次分割，下一行会用新的task执行</span><br><span class="line">            Method1(); </span><br><span class="line">            //开启一个新的Task</span><br><span class="line">            Task.Run(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;new task:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            &#125;);</span><br><span class="line">            Method2();</span><br><span class="line">            await Method1(); //同理</span><br><span class="line">            Method3();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static async Task Method1()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;method 1:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            await Task.Run(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot; Method 1&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; 10; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;After-------&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static async Task Method4()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;method 4:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            await Task.Run(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot; Method 4&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public static void Method2()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Method2:&quot;+AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            for (int i = 0; i &lt; 30; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot; Method 2&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void Method3()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Method3:&quot; + AppDomain.GetCurrentThreadId().ToString());</span><br><span class="line">            for (int i = 0; i &lt; 30; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot; Method 3&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到的结果为：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211023143024534.png" alt="image-20211023143024534"></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211023143130372.png" alt="image-20211023143130372"></p><p>我们可以来捋一捋发生的情况：</p><ul><li>主线程的线程id为14452，而在等待第一次await结束前的Method4()函数也同时在主线程中执行</li><li>之后的Method1()、Method2()、await Method1() 则被划分到了新的Task内执行，因此三者的线程ID都为新的随机分配的ID，而Task.Run()作为Task创建函数则在创建时根据线程池给task分配了线程ID</li><li>最后的Method3()原因与第二点相同，其被划分到了新的Task内执行，因此其线程ID为新的随机分配的ID</li></ul><h2 id="ETVoid与ETTask"><a href="#ETVoid与ETTask" class="headerlink" title="ETVoid与ETTask"></a>ETVoid与ETTask</h2><p><span style="color:red">其实这点在烟雨大佬的博客中已经写得比较详细了，我主要是在基础上加上一些理解。</span></p><p>备用链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C# Task的GetAwaiter和ConfigureAwait：</span><br><span class="line">https://www.cnblogs.com/majiang/p/7908441.html</span><br></pre></td></tr></table></figure><p>同样以一个代码例子作为切入点（A*寻路算法的测试部分截取）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//测试函数</span><br><span class="line">public static async ETTask NodeGOHandle(this GridComponent self, NodeItem node)</span><br><span class="line">&#123;</span><br><span class="line">    //mapHolder中找到对应GO</span><br><span class="line">    GameObject go = self.GetNodeGO(node);</span><br><span class="line"></span><br><span class="line">    go.transform.Translate(go.transform.InverseTransformDirection(0,0,2));//稍微前移</span><br><span class="line">    Debug.Log($&quot;wait for x:&#123;node.x&#125;,y:&#123;node.y&#125;&quot;);</span><br><span class="line">    //await TimerComponent.Instance.WaitAsync(2000);</span><br><span class="line">    await self.test();</span><br><span class="line">    Debug.Log($&quot;finish for x:&#123;node.x&#125;,y:&#123;node.y&#125;&quot;);</span><br><span class="line">    go.transform.Translate(go.transform.InverseTransformDirection(0,0,-2));//稍微前移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static async ETTask test(this GridComponent self)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 100; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;Test&quot;+i);</span><br><span class="line">        await TimerComponent.Instance.WaitAsync(100);</span><br><span class="line">    &#125;</span><br><span class="line">    await ETTask.CompletedTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据生成找到的路径生成具体的路径展示</span><br><span class="line">public static void GeneratePath(this GridComponent self,NodeItem startNode,NodeItem endNode)</span><br><span class="line">&#123;</span><br><span class="line">    NodeItem curNode = endNode;</span><br><span class="line">    List&lt;NodeItem&gt; nodes = new List&lt;NodeItem&gt;();</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (curNode != startNode)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log($&quot;count:&#123;++count&#125;&quot;);</span><br><span class="line">        if(count==1) self.NodeGOHandle(curNode).Coroutine();</span><br><span class="line">        // nodes.Add(curNode);</span><br><span class="line">        curNode = curNode.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nodes.Reverse();</span><br><span class="line">    self.SetPath(nodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放上输出的结果：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211027132856582.png" alt="image-20211027132856582"></p><p>现在我们来逐步分析：</p><ul><li>调用GeneratePath时，首先输出count:1，然后进入到self.NodeGoHandle(curNode)的异步函数中</li><li>顺序执行NodeGOHandle中await前的部分函数，输出wait for……，进入到self.test()函数</li><li>顺序执行self.test()函数，输出Test0，此时碰到waitAsync(100)，因为waitAsync为异步函数且具有阻塞情况，此时会执行外面将要执行的函数</li></ul><p><span style="color:red">△为什么前面的NodeGoHandle和test都进行了顺序执行，而最后test则返回到原调用函数的后续部分呢？</span></p><ul><li>如果一个异步函数内部仅有await ETTask.CompletedTask或者其嵌套await的函数里面仅有await ETTask.CompletedTask，可以单纯看做一个同步函数。在这种情况下无论是.Coroutine()还是await都与同步函数调用没有区别</li><li>而在例子里，async异步函数test()中调用了waitAsync()，其是阻塞的<span style="color:blue">（对于test()来说）</span>，<span style="color:red">因此会返回到原调用函数的后续部分继续执行 且 等待其任务执行完毕后压入test()函数中的后续部分</span></li></ul><h3 id="异同点："><a href="#异同点：" class="headerlink" title="异同点："></a>异同点：</h3><ul><li><p>共同点</p><ul><li>都具有async修饰符，即都代表了异步函数</li></ul></li><li><p>不同点</p><ul><li>ETTask可以有返回值(&lt;T&gt;作为泛型即可)；可以等待返回结果(具有getAwaiter以及实现awaiter对应接口)；可以通过.Coroutine()执行无需等待返回的异步，也可以通过await执行需要等待异步返回才能继续的情况</li><li>ETVoid不能有返回值，不可以等待返回结果(即不能用await)，也无法等待自身内部任务完成后再执行下面的语句</li></ul></li></ul><h3 id="使用情况："><a href="#使用情况：" class="headerlink" title="使用情况："></a>使用情况：</h3><ul><li>ETTask<ul><li>通常用于ET的EventSystem中的事件函数，同时也用于UI创建的异步函数(ETTask&lt;UI&gt;)，其本身可以通过返回值返回异步创建后的ui</li></ul></li><li>ETVoid<ul><li>通常用于ET中的网络交互的框架，因为基本不可能存在await服务器消息的情况（如果服务器崩了那客户端也会直接卡死），具体可以看C/S中的一些处理网络信息的handler</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> ET </tag>
            
            <tag> Unity </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 492 构造矩形</title>
      <link href="/2021/10/23/Leetcode-492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/"/>
      <url>/2021/10/23/Leetcode-492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="492-构造矩形"><a href="#492-构造矩形" class="headerlink" title="492. 构造矩形"></a><a href="https://leetcode-cn.com/problems/construct-the-rectangle/">492. 构造矩形</a></h2><p><img src="/2021/10/23/Leetcode-492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/image-20211023102717777.png" alt="image-20211023102717777"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    一道非常简单的题目，直接将面积开平方向上取整以后从下往上判断是否符合要求，符合则break即可。</p><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">constructRectangle</span><span class="params">(<span class="keyword">int</span> area)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从sqrt(area)开始计算</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(area));</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;=area;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(area%i==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(area/i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 229.求众数 II</title>
      <link href="/2021/10/22/Leetcode-229-%E6%B1%82%E4%BC%97%E6%95%B0-II/"/>
      <url>/2021/10/22/Leetcode-229-%E6%B1%82%E4%BC%97%E6%95%B0-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="229-求众数-II"><a href="#229-求众数-II" class="headerlink" title="229. 求众数 II"></a><a href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a></h2><p><img src="/2021/10/22/Leetcode-229-%E6%B1%82%E4%BC%97%E6%95%B0-II/image-20211022094507477.png" alt="image-20211022094507477"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ul><li>遍历计数法<ul><li>先遍历vector，用unordered_map记录下每个数出现的次数</li><li>逐个判断出现次数是否&gt;nums.size()/3，符合则加入ans中</li><li>时间复杂度为O(n),空间复杂度为O(n)</li></ul></li><li>摩尔投票法<ul><li>根据出现超过⌊ n/3 ⌋次的元素可以得出最多可能有2个这样的元素</li><li>让互不相同的三个元素互相抵消，最终会得到两个可能符合的元素</li><li>遍历计数，判断两个元素是否符合，符合则将其加入到ans中</li><li>时间复杂度为O(n),空间复杂度为O(1)</li></ul></li></ul><p>以下为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//MARKER:摩尔投票法</span></span><br><span class="line">        <span class="keyword">int</span> vote1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> vote2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出可能的两个num</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vote1&gt;<span class="number">0</span> &amp;&amp; num1==num)&#123;</span><br><span class="line">                vote1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (vote2&gt;<span class="number">0</span> &amp;&amp; num2==num)&#123;</span><br><span class="line">                vote2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (vote1==<span class="number">0</span>)&#123;</span><br><span class="line">                num1=num;</span><br><span class="line">                vote1=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (vote2==<span class="number">0</span>)&#123;</span><br><span class="line">                num2=num;</span><br><span class="line">                vote2=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                vote1--;</span><br><span class="line">                vote2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==num1) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num==num2) count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (count1&gt;nums.<span class="built_in">size</span>()/<span class="number">3</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count2&gt;nums.<span class="built_in">size</span>()/<span class="number">3</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ET6.0的对战游戏demo</title>
      <link href="/2021/10/21/%E5%9F%BA%E4%BA%8EET6-0%E7%9A%84%E5%AF%B9%E6%88%98%E6%B8%B8%E6%88%8Fdemo/"/>
      <url>/2021/10/21/%E5%9F%BA%E4%BA%8EET6-0%E7%9A%84%E5%AF%B9%E6%88%98%E6%B8%B8%E6%88%8Fdemo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    先开个坑，关系到毕业设计的实现。</p><h2 id="游戏类型："><a href="#游戏类型：" class="headerlink" title="游戏类型："></a>游戏类型：</h2><p>战旗类型、分为单机和联网，单机下怪物由AI树驱动，联网进行玩家对战</p><h2 id="暂定的网络同步思路"><a href="#暂定的网络同步思路" class="headerlink" title="暂定的网络同步思路"></a>暂定的网络同步思路</h2><ul><li>状态同步方式<ul><li>位置方面：客户端Unit每隔一段时间将自身的位置、朝向、速度发送给服务器，服务器计算出最终结果后进行广播操作，所有Units对位置结果进行插值处理<br><span style="color:red">12/19更新：现已通过A*方式进行寻路，所以客户端上传位置指令后服务器进行一定的校验、记录后即可进行转发操作，由客户端通过A*寻路移动到指定格子。</span></li><li>状态方面（技能、动画等）：利用一个状态包来进行转发广播操作，与位置包分开处理<br><span style="color:red">12/19更新：因为制作的是战旗类型游戏，所以调整同步方式为同步玩家的输入指令，由服务器计算伤害数值、角色属性等变化进行广播操作（现在已将伤害的显示逻辑与表现逻辑分离）提供给客户端进行表现。</span></li></ul></li></ul><h2 id="目前进度："><a href="#目前进度：" class="headerlink" title="目前进度："></a>目前进度：</h2><ul><li>弃用ET的自带UI，加入了EGUI的基于ET的UI框架并针对其进行修改和适配，加入UI栈、UI队列等</li><li>采用ET框架实现A*寻路算法，将具体寻路功能拆分为在zoneScene中全局的A*地图GridComponent组件与移动控制组件ControlComponent</li><li>初步加入技能系统，可以获取移动/技能范围并对对应格子移动/释放，技能、角色等属性采用导表的方式，方便后期修改</li><li>战斗场景搭建，并针对画面进行了Bloom、环境光遮蔽等后处理</li><li>战斗玩家Unit、怪物Unit设计完成，通过彼此的BattleComponent进行交互，符合ECS思路</li></ul><p><span style="color:red">12/19更新：</span></p><ul><li><p>RoundMgrComponent实现回合管理，回合顺序初步通过角色自身的速度属性进行排序，后期配合Buff技能会在回合中打乱战斗角色的回合顺序。</p></li><li><p>加入Buff状态机以及每个角色的BuffComponent即Buff状态组件，可对角色进行Buff的添加、移除（如加攻、防等机制），可实现每回合开始前的Buff判定Tick()（如中毒、流血等机制）</p></li><li><p>实现四叉树场景管理，对于不在摄像机内的场景Object进行剔除，优化内存</p></li></ul><p>具体文章：<a href="https://songofwing.site/2021/12/19/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E5%9B%9B%E5%8F%89%E6%A0%91%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6/">基于ET的四叉树场景管理组件</a></p><p>  <img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/%E5%9B%9B%E5%8F%89%E6%A0%91%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86.gif" alt="四叉树场景管理"></p><ul><li><p>实现技能派生机制（技能组），在策划表填写时可以填写某技能的子技能，在实际调用时会顺序使用其派生技能，因此在使用组合技能时无需通过Animator对每个技能动画进行再组合<br>技能表的部分参数：<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211219145924703.png" alt="image-20211219145924703"></p></li><li><p>实现可视化模块管理，包括伤害数值/特效模块、相机控制模块、四叉树场景管理模块、声音模块等。<br>其中SoundModule音频管理参考自GameFramework中的思路。<br>具体文章：<br><a href="https://songofwing.site/2021/12/18/%E5%9F%BA%E4%BA%8EET%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%A1%E7%90%86%E5%8F%8A%E5%85%B6%E5%A3%B0%E9%9F%B3%E6%A8%A1%E5%9D%97/">基于ET的模块化管理及其声音模块</a></p></li><li><p>优化UI流程，添加场景切换加载Loading界面，增加UI淡入淡出效果，新增血条展示，人物状态栏、技能栏等</p></li><li><p>实现shader的剔除效果模拟slider，新增子UI预置ESNormalSlider（基于Unity的Slider），ESSlider（基于Shader剔除），实现shader的消融效果等。<br>具体文章：<br><a href="https://songofwing.site/2021/12/08/Shader-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88%EF%BC%8C%E5%B9%B3%E9%9D%A2%E4%B8%8B%E7%9A%84%E5%A4%96-%E5%86%85%E8%BD%AE%E5%BB%93%EF%BC%8C%E7%AB%8B%E4%BD%93%E4%B8%8B%E7%9A%84%E5%A4%96%E8%BD%AE%E5%BB%93%EF%BC%8C%E8%8F%B2%E6%B6%85%E5%B0%94%E7%8E%B0%E8%B1%A1%EF%BC%8C%E5%86%85%E5%8F%91%E5%85%89%E7%8E%B0%E8%B1%A1%E6%80%BB%E5%92%8C/">Shader:透明度混合，平面下的外/内轮廓，立体下的外轮廓，菲涅尔现象，内发光现象总和</a><br><a href="https://songofwing.site/2021/11/29/Shader%E5%89%94%E9%99%A4%E6%A8%A1%E6%8B%9FSlider%E6%95%88%E6%9E%9C/">Shader剔除模拟Slider效果</a></p></li><li><p>实现场景地图障碍物（具体障碍物prefab会在预置Obstacle Prefab中随机选择）、怪物、角色自定义生成，方便随时进行地图信息调整。<span style="color:red">后期拟定会在角色战斗前由玩家自定义调整角色位置。</span><br>地图表格：<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211219152210832.png" alt="image-20211219152210832"></p></li><li><p>实现怪物AI行为树，提供Sequence、Selector、ETTaskAction等多节点任意组合，提供RandomSequence实现怪物逻辑的随机性：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211219152410501.png" alt="image-20211219152410501"></p><p><span style="color:red">怪物一般逻辑：如果范围内有敌人则攻击，若没有则向其仇恨玩家移动（1，最大移动距离），若无仇恨玩家则向第一个地方角色随机移动。仇恨机制表示上一次攻击其的玩家。</span><br>代码逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">m_Ai.OpenBranch(</span><br><span class="line">                BT.If(() =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    if (bc.lastAttackedUnit!=null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        CharacterPropertyComponent lastcpc = bc.lastAttackedUnit.GetComponent&lt;CharacterPropertyComponent&gt;();</span><br><span class="line">                        if (lastcpc!=null)</span><br><span class="line">                        &#123;</span><br><span class="line">                            return !lastcpc.isDead;</span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;).OpenBranch(</span><br><span class="line">                    BT.RunETTask(() =&gt; this.OnAttackToUnit(baseUnit, bc.lastAttackedUnit))</span><br><span class="line">                ),</span><br><span class="line">                BT.If(() =&gt; &#123; return enemyCells.Count &gt; 0;&#125;).OpenBranch(</span><br><span class="line">                    BT.RunETTask(() =&gt; this.OnAttackToPoint(baseUnit,enemyCells.First()))</span><br><span class="line">                ),</span><br><span class="line">                BT.If(() =&gt; &#123; return enemyCells.Count == 0;&#125;).OpenBranch(</span><br><span class="line">                    BT.RunETTask(() =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        //获取随机脚步</span><br><span class="line">                        Random.InitState(DateTime.Now.Millisecond);</span><br><span class="line">                        int footStep = Random.Range(1, cpc.moveRange);</span><br><span class="line">                        </span><br><span class="line">                        //找到距离某个角色的最短路径</span><br><span class="line">                        //TODO:后续应该优化，当前找到的默认是第一个生成的角色</span><br><span class="line">                        BaseUnitComponent buc = aiInput.DomainScene().GetComponent&lt;BaseUnitComponent&gt;();</span><br><span class="line">                        BaseUnit unit=buc.GetFirstPlayerUnit();</span><br><span class="line"></span><br><span class="line">                        CharacterPropertyComponent unit_cpc = unit.ConcreteUnit.GetComponent&lt;CharacterPropertyComponent&gt;();</span><br><span class="line">                        return this.OnChasePoint(baseUnit,unit_cpc.PointPos,footStep);</span><br><span class="line">                    &#125;)</span><br><span class="line">                )</span><br><span class="line">            );</span><br></pre></td></tr></table></figure></li><li><p>实现技能释放的表现和逻辑分离，在释放技能前进行伤害数值计算，<span style="color:red">后期在Server中单独执行伤害技能的伤害数值计算、Buff逻辑计算、并调整角色属性，客户端仅做表现</span>。</p><ul><li>每个技能分为Action和Effect，Action控制使用者动画播放，Effect控制技能特效、战斗数值等表现。</li></ul></li></ul><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211219160917057.png" alt="image-20211219160917057"></p><ul><li><p>游戏主界面设计，目前已完成初步主界面UI，后续拟定通过Camera在游戏实际场景中的巡逻作为背景</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211219162109577.png" alt="image-20211219162109577"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ET </tag>
            
            <tag> Unity </tag>
            
            <tag> 框架 </tag>
            
            <tag> demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 66.加一</title>
      <link href="/2021/10/21/Leetcode-66-%E5%8A%A0%E4%B8%80/"/>
      <url>/2021/10/21/Leetcode-66-%E5%8A%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a href="https://leetcode-cn.com/problems/plus-one/">66. 加一</a></h2><p><img src="/2021/10/21/Leetcode-66-%E5%8A%A0%E4%B8%80/image-20211021100630610.png" alt="image-20211021100630610"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​        方法1：直接从最后一位开始模拟整个加法的过程即可</p><p>​        方法2：逆序查找第一个不为9的数加1，其余都设为0即可<span style="color:red">(感觉更简单)</span></p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans=digits;</span><br><span class="line">        <span class="keyword">int</span> index=ans.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> add=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(add==<span class="number">1</span> &amp;&amp; index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            ans[index]+=add;</span><br><span class="line">            add=ans[index]/<span class="number">10</span>;</span><br><span class="line">            ans[index--]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑最终有进位情况</span></span><br><span class="line">        <span class="keyword">if</span> (add==<span class="number">1</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>(),<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 453: 最小操作次数使数组元素相等</title>
      <link href="/2021/10/20/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/"/>
      <url>/2021/10/20/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/10/20/Leetcode-453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/image-20211020135000199.png" alt="image-20211020135000199"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>考虑到n-1个元素增加1，对于这n-1个元素来说差值的情况是不会变得，因此可以看做是<span style="color:red">这n-1个元素并没有变而是将最后1个元素减1的情况</span>，这时解题的代码就非常明确了。</p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将n-1个元素增加1相当于让1个元素减1</span></span><br><span class="line">        <span class="keyword">int</span> min=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> temp:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp&lt;min)&#123;</span><br><span class="line">                min=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> temp:nums)&#123;</span><br><span class="line">            ans+=temp-min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#:值类型和引用类型的具体类型和区别</title>
      <link href="/2021/10/19/C-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/10/19/C-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先放上一个图表示值类型和引用类型的所有数据类型：</p><p><img src="https://raw.githubusercontent.com/petertan123/cloudimg/master/img/2009020510331710.jpg" alt="img"></p><p>（1）最根本的一个区别：<span style="color:red"><strong>值类型的变量直接存储数据，将数据存储在栈中。而引用类型的变量持有的是数据的引用，数据存储在堆中（对其的实例引用存储在栈中）（面试碰到的话后续还可以引申栈和堆的一些区别，比如GC标记压缩的垃圾回收方法等等）。</strong></span></p><p>（2）<span style="color:red">同时对于struct（值类型）和class（引用类型）来说，struct和class都可以实现接口（函数），但是struct在赋值时（如struct s1=s2）会直接创建s2的副本并赋值给s1，而对于class赋值时（class c1=c2）时会将两个类指向同一个引用，后续操作会同时改变同一个堆中实例。</span></p><p>（3）<span style="color:red">所有的值类型都继承System.ValueType，引用类型继承自System.Object。（其实引用类型和值类型都继承自System.Object类，不同的是，几乎所有的引用类型都直接从System.Object继承，而值类型则继承其子类，即直接继承System.ValueType）</span></p><p><span style="color:blue">△ 如果一个值类型被声明在一个方法体外并且在一个引用类型中，那它就会在堆上进行分配。</span></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> C# </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode记录：211 添加与搜索单词-数据结构设计</title>
      <link href="/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h2><p><img src="/2021/10/19/Leetcode%E8%AE%B0%E5%BD%95%EF%BC%9A211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20211019103409399.png" alt="image-20211019103409399"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    比较典型的一道前缀树的题目，注意在构建前缀树的过程中不要粗心大意即可，前缀树的定义可以参考<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/">208. 实现 Trie (前缀树) 的官方题解</a>。</p><p><span style="color:red">1.用一个is_end来记录是否到达结尾，2.结点向下的多叉树子结点用vector&lt;TrieNode *&gt;来记录</span></p><p>以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TrieNode *&gt; childs;</span><br><span class="line">    <span class="keyword">bool</span> is_end;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>(<span class="keyword">bool</span> _is_end=<span class="literal">false</span>)&#123;</span><br><span class="line">        childs=vector&lt;TrieNode *&gt;(<span class="number">26</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        is_end=_is_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        head_node=<span class="keyword">new</span> <span class="built_in">TrieNode</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于前缀树的word增加</span></span><br><span class="line">        <span class="keyword">int</span> length=word.<span class="built_in">length</span>();</span><br><span class="line">        TrieNode *temp=head_node;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch=word[i];</span><br><span class="line">            <span class="keyword">int</span> index=ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;childs[index]==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                temp-&gt;childs[index]=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp-&gt;childs[index];</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;is_end=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于前缀树的word搜索</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word,<span class="number">0</span>,head_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word,<span class="keyword">int</span> index,TrieNode* node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//循环跳出条件</span></span><br><span class="line">        <span class="keyword">if</span> (index==word.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;is_end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> ch=word[index];</span><br><span class="line">        <span class="keyword">if</span> (ch!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index_=ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            TrieNode* temp=node-&gt;childs[index_];</span><br><span class="line">            <span class="keyword">if</span>(temp!=<span class="literal">nullptr</span>&amp;&amp;<span class="built_in">search</span>(word,index+<span class="number">1</span>,temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                TrieNode* temp=node-&gt;childs[i];</span><br><span class="line">                <span class="keyword">if</span>(temp!=<span class="literal">nullptr</span>&amp;&amp;<span class="built_in">search</span>(word,index+<span class="number">1</span>,temp))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *head_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session和Cookie的区别、联系</title>
      <link href="/2021/10/18/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB/"/>
      <url>/2021/10/18/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考：https://www.cnblogs.com/ITCodeMonkey/p/7874343.html</span><br></pre></td></tr></table></figure><p>有时间回来补充一下</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity服务器--什么是RPC?</title>
      <link href="/2021/10/18/Unity%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%BB%80%E4%B9%88%E6%98%AFRPC/"/>
      <url>/2021/10/18/Unity%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%BB%80%E4%B9%88%E6%98%AFRPC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>在学习ET框架中Client与Server交互时的message信息中碰到的RpcId，之前没有太了解，固趁这个机会了解以下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">知乎参考：https://zhuanlan.zhihu.com/p/76727302</span><br></pre></td></tr></table></figure><p>此篇可能会慢慢更新。。。</p><h2 id="RPC-调用分类"><a href="#RPC-调用分类" class="headerlink" title="RPC 调用分类"></a>RPC 调用分类</h2><p>RPC调用分为以下两种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 同步调用  </span><br><span class="line">   客户方等待调用执行完成并返回结果。 </span><br><span class="line">2. 异步调用  --c2s_new,s2c_new,sreq_new</span><br><span class="line">   客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。 </span><br><span class="line">   若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 网络 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode记录: 476 数字的补数</title>
      <link href="/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/"/>
      <url>/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/10/18/Leetcode%E8%AE%B0%E5%BD%95-476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/image-20211018101215331.png" alt="image-20211018101215331"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    这题的解题思路其实比较清晰，就是求二进制然后取反重新计算新数，可以直接在求解二进制的过程中直接得出最终的结果。</p><p>​    以下是C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先求出其二进制数</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123; <span class="comment">//这里因为题目要求其实num/2!=0也可以</span></span><br><span class="line">            <span class="keyword">int</span> temp=(num%<span class="number">2</span>+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">            result+=<span class="built_in">pow</span>(<span class="number">2</span>,count++)*temp;</span><br><span class="line">            num/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        <span style="color:red">单看这个可能问题已经解决了，但是题目中想让我们实现的位运算其实并没有做到，在看到一些大佬的题解后，其实还有更简单直接的方法。</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp = num, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            c =  (c &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num ^ c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​        <span style="color:blue">这里的思路是：求出temp有多少位以后利用得出一个全1的c，再通过num^c（异或）就能得出最终结果，更符合题目的要求。</span></p><p>​    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++运算符优先级参考：https://www.sojson.com/operation/cxx.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET6.0框架初步</title>
      <link href="/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/"/>
      <url>/2021/10/17/ET6.0%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    因为学校毕设选题选择了Unity游戏开发相关的内容，并且ECS一直是我比较想去了解的方面，所以选择了ET作为毕设游戏所采用的框架。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考：1.&lt;&lt;ET6.0使用手册&gt;&gt; https://www.lfzxb.top/et6-manual/</span><br><span class="line"> 2.&lt;&lt;ET6.0学习笔记&gt;&gt; https://www.lfzxb.top/et6.0-study/</span><br></pre></td></tr></table></figure><h2 id="ECS相对于传统面向对象模式OOP"><a href="#ECS相对于传统面向对象模式OOP" class="headerlink" title="ECS相对于传统面向对象模式OOP"></a>ECS相对于传统面向对象模式OOP</h2><p>​    以前曾开发过ARPG的demo和2D横版过关的demo，所采用的都是传统的面向对象的思路和方法。采用类继承的方式，在前期的开发过程中还是比较轻松，但是在后期的基类逐渐冗余后，也能感觉到面向对象的一些的缺点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考：https://www.cnblogs.com/egametang/p/7511589.html</span><br></pre></td></tr></table></figure><p>​    在看了上面这篇文章以后，更是对一些面向对象的优缺点有了更深的体会，浓缩为以下两点。</p><h3 id="OOP数据结构耦合性强"><a href="#OOP数据结构耦合性强" class="headerlink" title="OOP数据结构耦合性强"></a>OOP数据结构耦合性强</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一旦父类中增加或删除某个字段，可能要影响到所有子类，影响到所有子类相关的逻辑。</span><br></pre></td></tr></table></figure><h3 id="OOP难以热插拔"><a href="#OOP难以热插拔" class="headerlink" title="OOP难以热插拔"></a>OOP难以热插拔</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">继承结构无法在运行时动态增加或删除字段，比如有时会需要取消player的某个功能，但这时只能进行禁用，而不能把功能完完全全的剥离出去。</span><br></pre></td></tr></table></figure><p>​    这点在lua中其实得到了很好的解决，在实习阶段我也是基本用的lua来进行minigame的开发，相对于C#来说，Lua语言其实可以选择抛弃传统的纯粹继承的方式，采用类似于<span style="color:red">单例类+require</span>的方式来进行逻辑开发，而实际上在除游戏实际角色、技能、状态机之外的情况下我也确实采用了这种方法来编写（登入，选服，匹配等等）。可以说这段经历对我来说是一段新的体验，也更加深了我想要去了解ECS组件式开发的兴趣。</p><p>​    <span style="color:blue">ET框架作为一个Unity的双端框架，采用了ECS的组件式概念来进行设计，其ECS的概念也曾经应用于热门的商业游戏守望先锋等，即实体(Entity)-组件(Component)-系统(system),其将Entity中所具有的Component抽象出来，遵循组合大于继承的原则，每位实体都通过一个或多个组件ID连接多个功能组件,避免了一些不必要的开销。</span></p><p>​    <span style="color:red"><strong>这篇文章仅用于记录下ECS学习过程中的一些心得体会，主要还是对烟雨大佬视频的一些自身收获。</strong></span></p><h2 id="环境配置和demo运行"><a href="#环境配置和demo运行" class="headerlink" title="环境配置和demo运行"></a>环境配置和demo运行</h2><p><span style="color:red"><strong>在ET/Book中已经有各种ET框架指南，本篇主要是记录一些具体过程。</strong></span></p><p>先放一下工程中整体的目录截图：</p><p>分为两个主要的sln，Unity和Server：</p><p>Unity：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017140008420.png" alt="image-20211017140008420"></p><p>Server：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017140040074.png" alt="image-20211017140040074"></p><p><strong>△Unity和Server中所有的project都要进行build的操作</strong></p><p>服务器：</p><p>​    需要安装MongoDB数据库（对于ET的初始demo来说不需要，因为其将数据库交互部分注释了）</p><p>​    需要安装Net Core 或Net Framework（我用的是Net5.0）</p><p>​    在build后启动Server.App即可开启服务器</p><p>客户端：</p><p>​    在UnityHub中打开对应项目工程后，首先在Assets/Scenes中找到启动的Init场景</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017143237959.png" alt="image-20211017143237959"></p><p>运行后即可输入账号密码进入游戏场景</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017143405871.png" alt="image-20211017143405871"></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017143434676.png" alt="image-20211017143434676"></p><h2 id="ET框架结构总览："><a href="#ET框架结构总览：" class="headerlink" title="ET框架结构总览："></a>ET框架结构总览：</h2><h3 id="Unity-sln项目结构："><a href="#Unity-sln项目结构：" class="headerlink" title="Unity.sln项目结构："></a>Unity.sln项目结构：</h3><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211107102409848.png" alt="image-20211107102409848"></p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211108135131078.png" alt="image-20211108135131078"></p><ul><li>Hotfix对应Model中Component的System实现，如demo中的XunLuoPathComponentSystem，为逻辑层方法</li><li>HotfixView对应ModelView中Component的具体实现，如demo中的各种UIComponentSystem，为表现层方法</li><li>Model为游戏中一些数据Component的存储目录，如demo中的MoveComponent，为逻辑层数据</li><li>ModelView为游戏中一些外部View展示Component的存储目录，如demo中的各种UI界面Component，也包括GameObject、Animator等，为表现层数据</li></ul><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/1600236623-436564-image.png" alt="img"></p><h2 id="导表部分"><a href="#导表部分" class="headerlink" title="导表部分"></a>导表部分</h2><p>先上一张导表方法图：</p><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211110105429222.png" alt="image-20211110105429222"></p><p><span style="color:red">与烟雨大佬视频中的不同，现在的ET版本中导表工具已经由之前的Assets/Editor/ExcelExporterEditor/ExcelExporterEditor.cs迁移到Server/Model/ExcelExporter/ExcelExporter.cs，而在Unity中的Editor拓展也已经移除了。</span></p><h3 id="过程理解："><a href="#过程理解：" class="headerlink" title="过程理解："></a>过程理解：</h3><h4 id="导出JSON-暂存信息-："><a href="#导出JSON-暂存信息-：" class="headerlink" title="导出JSON(暂存信息)："></a>导出JSON(暂存信息)：</h4><p>让我们先打开这个ExcelExporter.cs，其在调用时已经被包含在<span style="color:red">ET/Bin/Server.dll</span>的动态链接库中，因此我们当前的目录其实就是Bin，接下来看下图中的Excel表，Json表等存放的路径就非常清晰了。</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017153220996.png" alt="image-20211017153220996"></p><p>对于Excel的读取采用了OfficeOpenXml中的ExcelPackage类来进行处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C#excelpackage读写Excel文件：https://www.cnblogs.com/sange0708/p/15005370.html</span><br></pre></td></tr></table></figure><p>先来看一下在demo中给出的AIConfig.xlsx的表格例子：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017162205295.png" alt="image-20211017162205295"></p><p>对应在ExcelPackage读取后的JSON导出代码：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017162408170.png" alt="image-20211017162408170"></p><p>可以得知对应Excel中<span style="color:blue">第二行为是否不导出为JSON，第三行的内容为变量描述、第四行为变量名、第五行为导出类型</span></p><p><span style="color:red">#作为中断读取的标志，有#的变量都不会导出为Json</span></p><p>之后是对具体变量内容的读取和写入：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017163109993.png" alt="image-20211017163109993"></p><p>根据之前读取到的头文件信息，从Excel表中的第六行开始进行读取，而后在StringBuffer中写入对应的json信息。</p><h4 id="导出类-用于反序列化-："><a href="#导出类-用于反序列化-：" class="headerlink" title="导出类(用于反序列化)："></a>导出类(用于反序列化)：</h4><p>其对<span style="color:red">headInfo</span>的读取与导出JSON是相同的，关键点在于对于class读取类的导出，用到了在Export中读取到的template.txt，它其实是一个类class的代码模板(继承自ProtoObject)，导出类做的主要工作就是将类名、域名等的信息套到这个模板代码中，并生成对应的cs文件。</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017164315689.png" alt="image-20211017164315689"></p><h4 id="根据生成的类，动态编译把JSON转译成protobuf："><a href="#根据生成的类，动态编译把JSON转译成protobuf：" class="headerlink" title="根据生成的类，动态编译把JSON转译成protobuf："></a>根据生成的类，动态编译把JSON转译成protobuf：</h4><p>比起之前版本的ET，新版本的ET是通过<strong>protobuf</strong>来作为序列化数据的。因此最关键的一步就是转译，具体的代码过程就不贴出来了。</p><h3 id="导表所支持的类型："><a href="#导表所支持的类型：" class="headerlink" title="导表所支持的类型："></a>导表所支持的类型：</h3><p><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211110124718506.png" alt="image-20211110124718506"></p><h3 id="使用例子："><a href="#使用例子：" class="headerlink" title="使用例子："></a>使用例子：</h3><h4 id="导表："><a href="#导表：" class="headerlink" title="导表："></a>导表：</h4><p>​    在cmd中cd到对应的<strong>根目录/Bin</strong>文件夹中，而后执行dotnet Server.dll –AppType=ExcelExporter即可，导出的表格会分别存放在./Client/Json文件夹和./Server/Json文件夹中。</p><p>​    <img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017164636195.png" alt="image-20211017164636195"></p><h4 id="脚本使用："><a href="#脚本使用：" class="headerlink" title="脚本使用："></a>脚本使用：</h4><p>​    在具体CS脚本中的通过<span style="color:red">表格名+Category</span>的单例类就可以获取对应的表格信息（key值对应ID）。</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211017170048269.png" alt="image-20211017170048269"></p><h2 id="Proto生成CS与拓展"><a href="#Proto生成CS与拓展" class="headerlink" title="Proto生成CS与拓展"></a>Proto生成CS与拓展</h2><p><span style="color:red">ET框架采用了分布式服务器的方式。</span></p><p>同样列出上方的一张图：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211018155809927.png" alt="image-20211018155809927"></p><p>我们先来找到ET/Model/Proto2CS/Program.cs文件，与导表的cs文件相同，其在具体使用的时候同样是被打成了dll放在了ET/Bin文件夹下，因此文件的根目录同样是Bin文件夹。</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211018160111894.png" alt="image-20211018160111894"></p><p>​        对于客户端和服务器的生成路径如上图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">之前在实习阶段也对proto的定义有了一些理解，但是在实际看到ET框架内的proto的时候还是和之前所认知的有一些差别，</span><br><span class="line">之前的框架是基于lua脚本因此对proto来说无需转换到CS，而如今ET框架的热更等是面向ILRuntime的。</span><br></pre></td></tr></table></figure><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211018163131915.png" alt="image-20211018163131915"></p><p>看到具体的Proto2CS的生成函数：</p><p>1.InnerMessage是服务器内部的协议生成，可能是用于分布式的多服务器沟通</p><p>2.OuterMessage则是针对于C2S和S2C之间的交互了</p><p><span style="color:red">ET客户端与服务端的交互总览：（取自烟雨大佬的视频）</span></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020153521006.png" alt="image-20211020153521006"></p><p>网关服：用于做消息转发，与Actor信息配套</p><p>验证服：账号的登入，注册</p><p>战斗服：寻路、战斗信息</p><p>1.<span style="color:red"><strong>Domain指这个entity属于哪个scene，一个进程可以容纳多个scene</strong></span></p><p>2.<span style="color:red">对于客户端和服务端来说，其最大的scene都为Game.scene，在客户端中，目前通过Game.scene来作为全局通用的Component的存储(比如UIComponent、UIEventComponent等)，而对于服务器来说一个功能对应ET中的一个scene,具体的配置方法在Excel/StartSceneConfig中。</span></p><p>3.<span style="color:red">每个客户端的Game.scene在服务端会在随机分配的gate中生成一个key，后续客户端可以通过这个key连接到服务端。</span></p><h3 id="使用例子：-1"><a href="#使用例子：-1" class="headerlink" title="使用例子："></a>使用例子：</h3><h4 id="脚本使用：-1"><a href="#脚本使用：-1" class="headerlink" title="脚本使用："></a>脚本使用：</h4><p><span style="color:red">客户端调用：</span></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211018171843943.png" alt="image-20211018171843943"></p><p><span style="color:red">服务器处理：</span></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211019135845225.png" alt="image-20211019135845225"></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211019141256527.png" alt="image-20211019141256527"></p><p>△可以看到在服务器的Handler中有分布式服务器之间的交互处理</p><h3 id="实际使用过程："><a href="#实际使用过程：" class="headerlink" title="实际使用过程："></a>实际使用过程：</h3><ul><li>定义proto文件</li><li>生成C#代码</li><li>编写双端收发逻辑代码</li></ul><h4 id="在OuterMessage-proto中添加新的协议"><a href="#在OuterMessage-proto中添加新的协议" class="headerlink" title="在OuterMessage.proto中添加新的协议"></a>在OuterMessage.proto中添加新的协议</h4><p>这里没有采用actor的方式，添加了三个协议</p><ul><li>C2R_TestSend</li><li>C2R_TestCall</li><li>R2C_TestResponse</li></ul><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020234524827.png" alt="image-20211020234524827"></p><h4 id="在客户端的LoginHelper的异步Login中添加相应session-Call和Send："><a href="#在客户端的LoginHelper的异步Login中添加相应session-Call和Send：" class="headerlink" title="在客户端的LoginHelper的异步Login中添加相应session.Call和Send："></a>在客户端的LoginHelper的异步Login中添加相应session.Call和Send：</h4><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020154921586.png" alt="image-20211020154921586"></p><h4 id="在服务器的Hotfix-Demo中加入对应的CallHandler和SendHandler"><a href="#在服务器的Hotfix-Demo中加入对应的CallHandler和SendHandler" class="headerlink" title="在服务器的Hotfix/Demo中加入对应的CallHandler和SendHandler"></a>在服务器的Hotfix/Demo中加入对应的CallHandler和SendHandler</h4><ul><li>C2R_TestCallHandler</li></ul><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020234051973.png" alt="image-20211020234051973"></p><ul><li>C2R_TestSendHandler</li></ul><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020234029225.png" alt="image-20211020234029225"></p><ul><li>注意点<ul><li>Request和Response的应实现AMRpcHandler接口，而用于处理Request的则实现AMHandler接口。</li><li>在写入新的协议handler以后要对重新build Hotfix</li><li>要在对应的Handler类上打上[MessageHandler]的标签</li><li>Log.Info进行了进一步封装，其结果存放在ET/Logs目录的日志文件中</li></ul></li></ul><p>现在服务器和客户端都能输出正确回应：</p><p>server:</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020234220037.png" alt="image-20211020234220037"></p><p>client:</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211020232241622.png" alt="image-20211020232241622"></p><h2 id="Actor机制"><a href="#Actor机制" class="headerlink" title="Actor机制"></a>Actor机制</h2><p>同样先放上在烟雨大佬视频的思维导图：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211021101415991.png" alt="image-20211021101415991"></p><ul><li>关键点<ul><li>Entity InstanceID是唯一的，即对应的每个居住证是唯一的，仅代表了当前所在进程以及自身Entity</li><li>Entity上挂载的MailboxComponent组件就是一种Actor，只需要知道Entity的InstanceId就可以给这个Entity发送消息</li><li>Actor模型固然方便，但是在有时我们无法知道对方的InstanceId或者对方的InstanceId进行了改变，这时候就需要ActorLocation发挥作用，Actor对象在一个进程创建时或者迁移到一个新的进程时，都需要把自己的Id跟新的InstanceId注册到Location Server上去，<span style="color:red">ActorLocationSender提供两种方法，Send跟Call，Send一个信息也需要接受者返回一个消息，只有收到返回的消息才会发送下一个消息。</span></li><li>Actor模型是<span style="color:red">纯粹的服务器消息通信机制</span>，ET客户端使用这个Actor完全是因为Gate需要对客户端消息进行转发，我们可以正好利用服务端actor模型来进行转发，所以客户端有些消息也是继承了actor的接口。</li><li>Actor和ActorLocation的一个最大的区别在于ActorLocation需要先在Location服务器中获取到Entity的真实的InstanceId，<span style="color:blue">其在LocationProxyComponentSystem.cs中体现，通过key:UnitId对应value:InstanceId</span></li></ul></li></ul><h3 id="具体例子："><a href="#具体例子：" class="headerlink" title="具体例子："></a>具体例子：</h3><p>下面是一个在进入map服后创建战斗Unit的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[ActorMessageHandler]</span><br><span class="line">public class G2M_CreateUnitHandler : AMActorRpcHandler&lt;Scene, G2M_CreateUnit, M2G_CreateUnit&gt;</span><br><span class="line">&#123;</span><br><span class="line">protected override async ETTask Run(Scene scene, G2M_CreateUnit request, M2G_CreateUnit response, Action reply)</span><br><span class="line">&#123;</span><br><span class="line">UnitComponent unitComponent = scene.GetComponent&lt;UnitComponent&gt;();</span><br><span class="line">Unit unit = Entity.CreateWithId&lt;Unit, int&gt;(unitComponent, IdGenerater.Instance.GenerateId(), 1001);</span><br><span class="line">unit.AddComponent&lt;MoveComponent&gt;();</span><br><span class="line">unit.Position = new Vector3(-10, 0, -10);</span><br><span class="line"></span><br><span class="line">NumericComponent numericComponent = unit.AddComponent&lt;NumericComponent&gt;();</span><br><span class="line">numericComponent.Set(NumericType.Speed, 6f); // 速度是6米每秒</span><br><span class="line"></span><br><span class="line">unit.AddComponent&lt;MailBoxComponent&gt;();</span><br><span class="line">await unit.AddLocation();</span><br><span class="line">unit.AddComponent&lt;UnitGateComponent, long&gt;(request.GateSessionId);</span><br><span class="line">unitComponent.Add(unit);</span><br><span class="line">response.UnitId = unit.Id;</span><br><span class="line"></span><br><span class="line">// 把自己广播给周围的人</span><br><span class="line">M2C_CreateUnits createUnits = new M2C_CreateUnits();</span><br><span class="line">createUnits.Units.Add(UnitHelper.CreateUnitInfo(unit));</span><br><span class="line">MessageHelper.Broadcast(unit, createUnits);</span><br><span class="line"></span><br><span class="line">// 把周围的人通知给自己</span><br><span class="line">createUnits.Units.Clear();</span><br><span class="line">Unit[] units = scene.GetComponent&lt;UnitComponent&gt;().GetAll();</span><br><span class="line">foreach (Unit u in units)</span><br><span class="line">&#123;</span><br><span class="line">createUnits.Units.Add(UnitHelper.CreateUnitInfo(u));</span><br><span class="line">&#125;</span><br><span class="line">//△通过GateSessionActorId向对应的unit发送消息</span><br><span class="line">MessageHelper.SendActor(unit.GetComponent&lt;UnitGateComponent&gt;().GateSessionActorId, createUnits);</span><br><span class="line"></span><br><span class="line">reply();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">    其中的MessageHelper.SendActor已经很明了了，其通过对应Unit的网关InstanceId来向对应Unit发送信息，那么对于MessageHelper呢？</span></p><p>​    查看MessageHelper源码中的Broadcast发现，其同样使用了SendActor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void Broadcast(Unit unit, IActorMessage message)</span><br><span class="line">&#123;</span><br><span class="line">    //获取在相同Scene中的所有Units(也就是同处于战斗服)</span><br><span class="line">    var units = unit.Domain.GetComponent&lt;UnitComponent&gt;().GetAll();</span><br><span class="line"></span><br><span class="line">    if (units == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foreach (Unit u in units)</span><br><span class="line">    &#123;</span><br><span class="line">        UnitGateComponent unitGateComponent = u.GetComponent&lt;UnitGateComponent&gt;();</span><br><span class="line">        SendActor(unitGateComponent.GateSessionActorId, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ActorLocation机制："><a href="#ActorLocation机制：" class="headerlink" title="ActorLocation机制："></a>ActorLocation机制：</h2><ul><li>其相对于actor消息加入了Location服务器用于查询当前对象所处的进程（如不同地图进程map），防止玩家Player在不同地图中传送后的消息丢失<img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20220116202349042.png" alt="image-20220116202349042"></li><li><span style="color:red">于Actor消息的区分</span>：Actor消息主要用于外围系统，如聊天系统，而ActorLocation消息主要用于地图传送等系统</li></ul><h2 id="ET-6-0-demo中的网络交互流程："><a href="#ET-6-0-demo中的网络交互流程：" class="headerlink" title="ET 6.0 demo中的网络交互流程："></a>ET 6.0 demo中的网络交互流程：</h2><ul><li>交互流程<ul><li>客户端发送C2R_Login协议(账号密码)到服务端，服务端在大区中随机分配一个gate，并且在服务器内部向gate请求一个key，客户端可以拿着这个key连接gate，服务器将Address，网关key，网关Id回传给客户端</li><li>客户端发送G2C_LoginGate(网关key和网关Id)到服务端，服务端通过网关key获取对应的账号，同时获取Game中的PlayerComponent，创建Player的Entity并加入其中，同时返回playerId</li><li>客户端发送G2C_EnterMap到服务器，服务器在zone中找到对应的map scene后在map上创建战斗Unit<span style="color:red">（同时会向客户端发送M2C_CreateUnits令其在Game中创建Unit）</span>，并且将UnitId赋值给player.UnitId，同时将其作为返回值回传给客户端，客户端收到后在Game的unitComponent获取对应Unit并赋值给MyUnit</li></ul></li></ul><h2 id="异步处理Async和Await"><a href="#异步处理Async和Await" class="headerlink" title="异步处理Async和Await"></a>异步处理Async和Await</h2><p><span style="color:red">这部分的内容比较多，放在了一篇新的文章中。</span></p><ul><li>链接：<a href="https://songofwing.site/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/">https://songofwing.site/2021/10/23/ET%E6%A1%86%E6%9E%B6%EF%BC%9AAsync%E5%92%8Cawait%EF%BC%8CETVoid%E4%B8%8EETTask/</a></li></ul><h2 id="事件系统-EventSystem"><a href="#事件系统-EventSystem" class="headerlink" title="事件系统(EventSystem)"></a>事件系统(EventSystem)</h2><h3 id="使用过程："><a href="#使用过程：" class="headerlink" title="使用过程："></a>使用过程：</h3><p>ET中的事件系统相对比较简单，其定义方式分为三个步骤：</p><ul><li><p>在EventType中定义事件结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace EventType</span><br><span class="line">&#123;</span><br><span class="line">    public struct TestEvent</span><br><span class="line">    &#123;</span><br><span class="line">        public string message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个类用于处理指定时间，泛型类型订阅的事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestEvent_Action: AEvent&lt;EventType.TestEvent&gt;</span><br><span class="line">&#123;</span><br><span class="line"> protected override async ETTask Run(EventType.TestEvent args)</span><br><span class="line">    &#123;</span><br><span class="line">        Log.Info($&quot;TestEvent事件触发了 : &#123;args.Type&#125;&quot;);</span><br><span class="line">        //虽然这个函数是async的，但是我们内部没有异步操作，就可以这样调用，相当于直接return</span><br><span class="line">await ETTask.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抛出事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Game.EventSystem.Publish(new EventType.TestEvent()&#123;Message=&quot;测试&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a>代码解析：</h3><p>​    ![ET EventSystem](ET6.0框架初步/ET EventSystem.png)</p><ul><li>在EventSystem的Add(Assembly assembly)中在程序集内获取到所有打上了Attribute的class，并在从中挑选出打了[Event]标签的class(即实现了IEvent接口的AEvent&lt;A&gt;抽象类)，并将其订阅事件结构体类型Type对应List&lt;obj&gt;()存储在AllEvents字典中<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022105434483.png" alt="image-20211022105434483"></li><li>在Publish时将所有ETTask的Run()函数加入到ListComponent.Create()创建的list中，而后调用ETTaskHelper.WaitAll(list.List);执行<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022105925399.png" alt="image-20211022105925399"></li><li>注意在WaitAll中所有的事件是异步执行的，内部通过CoroutineBlocker来阻塞未执行完的所有Task，在count==0时继续之前所有阻塞的tcs<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022110531535.png" alt="image-20211022110531535"></li></ul><p>关键点：</p><ul><li><p>ETTask重写了传统Task，将自身作为Awaiter，并通过枚举的AwaiterStatus判断是否结束。<img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/dd0f615f0d5b6fef48bbbac88276c8d.jpg" alt="dd0f615f0d5b6fef48bbbac88276c8d"></p><p>上图是可等待模式的处理，对应ETTask分别为：</p><p><strong>GetAwaiter()：</strong></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022141746640.png" alt="image-20211022141746640"></p><p><strong>IsCompleted():</strong></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022141852539.png" alt="image-20211022141852539"></p><p>​    <span style="color:red">其中的AwaiterStatus可以在SetResult()中进行更改。</span></p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022142017462.png" alt="image-20211022142017462"></p></li></ul><h2 id="UI系统"><a href="#UI系统" class="headerlink" title="UI系统"></a>UI系统</h2><p>还是很想吐槽一下ET的UI系统实在是有点过于简洁了，其UI生命周期中的事件只有OnCreate和OnRemove两种，后续还需要继续拓展。</p><ul><li>通过UIComponent组件类管理Scene上的UI<ul><li>通过.Create(this UIComponent self,string uiType)函数进行创建，同时在创建时会执行UIEvents字典中通过自定义标签导入进来的onCreate()函数，<span style="color:red">其外部通过UIHelper.Create(Scene scene,string uiType)在指定scene中创建</span></li><li>通过.Remove(this UIComponent self,string uiType)函数进行移除，同时在创建时会执行UIEvents字典中通过自定义标签导入进来的onRemove()函数，<span style="color:red">其外部通过UIHelper.Create(Scene scene,string uiType)在指定scene中移除</span></li></ul></li><li>通过ReferenceCollector可以获取UIPrefab上面的引用，可以直接在prefab里加入RC方便后续获取子物体<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211022153257071.png" alt="image-20211022153257071"></li></ul><hr><p><span style="color:red">对ET自带的UI部分进行了拓展。</span></p><ul><li>将原先的mid、hidden、low等变为普通GO，用代码设定sortingOrder</li><li>加入UICamera方便管理，代码设定UICamera</li><li>新增onShow(),onHide()</li></ul><p>10/24更新：</p><ul><li>新增UI栈</li><li>UIComponent、UIComponentSystem、UIHelper代码拓展</li></ul><p>10/25更新：</p><ul><li>引入新的UIStatesComponent组件，记录UIForm(UI类型)，isShow(是否展示中)等信息</li><li>处理UI栈与UI字典的关系</li></ul><p>10/26更新：</p><ul><li>加入UI栈中UI对应次数的字典，处理同一UI多次入栈的情况</li></ul><h2 id="场景管理"><a href="#场景管理" class="headerlink" title="场景管理"></a>场景管理</h2><p>ET场景切换整体思路和代码也不多，后续可能要结合Loading进度条拓展</p><p>先放上流程图：</p><p><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/ET%EF%BC%9AScene.drawio.png" alt="ET：Scene.drawio"></p><p><span style="color:red">针对其加载回调做了一些拓展处理：</span></p><ul><li>在ChangeSceneAsync完成时会进行EventType.ChangeSceneFinish事件广播处理，广播内容为sceneName和zoneScene</li><li>在ChangeSceneFinish_SceneCallBack的事件处理函数中根据场景名进行组件添加处理<br><img src="http://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211028001327798.png" alt="image-20211028001327798"></li></ul><h2 id="AB包配置"><a href="#AB包配置" class="headerlink" title="AB包配置"></a>AB包配置</h2><ul><li>对于ET来说有自带的AB包配置打包工具，其在项目的Tools/打包工具中<br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211113151829342.png" alt="image-20211113151829342"></li><li>打包前需要配置完成对应的AssetBundle名，若不太了解可以先去学习一下Unity的AB包打包和加载部分。</li></ul><h3 id="使用例子：-2"><a href="#使用例子：-2" class="headerlink" title="使用例子："></a>使用例子：</h3><p><span style="color:red">以Demo中UI打包与加载为例子。</span></p><ul><li>打包<ul><li>在Bundle/UI/UILogin.prefab中配置好对应的AB包名，demo这里配置为了uilogin.unity3d。<img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211113152457652.png" alt="image-20211113152457652"></li><li>在打包工具中点击开始打包（以打包的BuildType选择为Release为例子）</li><li><span style="color:red">打出的AB包会根据打包时选择的BuildType存放在对应的路径中，因此这里对应存储在<strong>ET/Release/PC/StreamingAssets</strong>中</span><br><img src="https://petertan-imgsubmit.oss-cn-guangzhou.aliyuncs.com/img/image-20211113162252071.png" alt="image-20211113162252071"></li></ul></li><li>加载<ul><li><p>在Editor状态下代码中默认采用的是真实路径来进行加载，因此如果要测试打出的AB包，需要注释ResourceComponent中LoadOneBundle(string assetBundleName)中相应的代码。</p><p>ResourcesComponent.cs:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">   private void LoadOneBundle(string assetBundleName)</span><br><span class="line">        &#123;</span><br><span class="line">            assetBundleName = assetBundleName.BundleNameToLower();</span><br><span class="line">            ABInfo abInfo;</span><br><span class="line">            if (this.bundles.TryGetValue(assetBundleName, out abInfo))</span><br><span class="line">            &#123;</span><br><span class="line">                ++abInfo.RefCount;</span><br><span class="line">                //Log.Debug($&quot;---------------load one bundle &#123;assetBundleName&#125; refcount: &#123;abInfo.RefCount&#125;&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!Define.IsAsync)</span><br><span class="line">            &#123;</span><br><span class="line">//----------------------注释部分-----------------------------</span><br><span class="line">// #if UNITY_EDITOR</span><br><span class="line">// string[] realPath = null;</span><br><span class="line">//                 realPath = AssetDatabase.GetAssetPathsFromAssetBundle(assetBundleName);</span><br><span class="line">//</span><br><span class="line">//                 foreach (string s in realPath)</span><br><span class="line">//                 &#123;</span><br><span class="line">//                     string assetName = Path.GetFileNameWithoutExtension(s);</span><br><span class="line">//                     UnityEngine.Object resource = AssetDatabase.LoadAssetAtPath&lt;UnityEngine.Object&gt;(s);</span><br><span class="line">//                     AddResource(assetBundleName, assetName, resource);</span><br><span class="line">//                 &#125;</span><br><span class="line">//</span><br><span class="line">//                 if (realPath.Length &gt; 0)</span><br><span class="line">//                 &#123;</span><br><span class="line">//                     abInfo = Entity.Create&lt;ABInfo, string, AssetBundle&gt;(this, assetBundleName, null);</span><br><span class="line">//                     this.bundles[assetBundleName] = abInfo;</span><br><span class="line">//                     //Log.Debug($&quot;---------------load one bundle &#123;assetBundleName&#125; refcount: &#123;abInfo.RefCount&#125;&quot;);</span><br><span class="line">//                 &#125;</span><br><span class="line">//                 else</span><br><span class="line">//                 &#123;</span><br><span class="line">//                     Log.Error($&quot;assets bundle not found: &#123;assetBundleName&#125;&quot;);</span><br><span class="line">//                 &#125;</span><br><span class="line">// #endif</span><br><span class="line">//                 return;</span><br><span class="line">//----------------------注释部分-----------------------------</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            string p = Path.Combine(PathHelper.AppHotfixResPath, assetBundleName);</span><br><span class="line">            AssetBundle assetBundle = null;</span><br><span class="line">            if (File.Exists(p))</span><br><span class="line">            &#123;</span><br><span class="line">                assetBundle = AssetBundle.LoadFromFile(p);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                p = Path.Combine(PathHelper.AppResPath, assetBundleName);</span><br><span class="line">                assetBundle = AssetBundle.LoadFromFile(p);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (assetBundle == null)</span><br><span class="line">            &#123;</span><br><span class="line">                // 获取资源的时候会抛异常，这个地方不直接抛异常，因为有些地方需要Load之后判断是否Load成功</span><br><span class="line">                Log.Warning($&quot;assets bundle not found: &#123;assetBundleName&#125;&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!assetBundle.isStreamedSceneAssetBundle)</span><br><span class="line">            &#123;</span><br><span class="line">                // 异步load资源到内存cache住</span><br><span class="line">                var assets = assetBundle.LoadAllAssets();</span><br><span class="line">                foreach (UnityEngine.Object asset in assets)</span><br><span class="line">                &#123;</span><br><span class="line">                    AddResource(assetBundleName, asset.name, asset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            abInfo = Entity.Create&lt;ABInfo, string, AssetBundle&gt;(this, assetBundleName, assetBundle);</span><br><span class="line">            this.bundles[assetBundleName] = abInfo;</span><br><span class="line"></span><br><span class="line">            Log.Debug($&quot;---------------load one bundle &#123;assetBundleName&#125; refcount: &#123;abInfo.RefCount&#125;&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>通过以下代码进行AB包的读取，这里以UILogin.prefab所在的uilogin.unity3d的ab包为例子</p><p>在其OnCreate()的声明周期中进行AB包加载和对应的GO生成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public override async ETTask&lt;UI&gt; OnCreate(UIComponent uiComponent)</span><br><span class="line">        &#123;</span><br><span class="line">    //异步加载过程（ETTask仍为单线程）</span><br><span class="line">            await ResourcesComponent.Instance.LoadBundleAsync(UIType.UILogin.StringToAB());</span><br><span class="line">            GameObject bundleGameObject = (GameObject) ResourcesComponent.Instance.GetAsset(UIType.UILogin.StringToAB(), UIType.UILogin);</span><br><span class="line">            GameObject gameObject = UnityEngine.Object.Instantiate(bundleGameObject);</span><br><span class="line"></span><br><span class="line">            UI ui = Entity.Create&lt;UI, string, GameObject&gt;(uiComponent, UIType.UILogin, gameObject);</span><br><span class="line"></span><br><span class="line">            ui.AddComponent&lt;UILoginComponent&gt;();</span><br><span class="line">            return ui;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习心得 </tag>
            
            <tag> ET </tag>
            
            <tag> Unity </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-first-blog</title>
      <link href="/2021/10/16/my-first-blog/"/>
      <url>/2021/10/16/my-first-blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>测试—Test</p><p><span style="color:red">新的开始</span></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
